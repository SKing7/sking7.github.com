
        <!doctype html>
        <html>
        <head>
            <meta charset="utf-8"/>
            <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
            <title>Inspecting a repository</title>
            <link rel="stylesheet" href="../css/article.css" />;
        </head>
        <body>
            <div class="m-content">
                <h1>Inspecting a repository</h1>
                <div class="g-column g-12-12 g-centered"><span> </span><h2 id="git-status">git status</h2><span> </span><p>The <code>git status</code> command displays the state of the working directory and the staging area. It lets you see which changes have been staged, which haven’t, and which files aren’t being tracked by Git. Status output does <em>not</em> show you any information regarding the committed project history. For this, you need to use <a href="https://www.atlassian.com/git/tutorials/inspecting-a-repository/git-log"><code>git log</code></a>.</p><span> </span><h3>Usage</h3><span> </span><pre><code>git status</code></pre><span> </span><p>List which files are staged, unstaged, and untracked.</p><span> </span><h3>Discussion</h3><span> </span><p>The <code>git status</code> command is a relatively straightforward command. It simply shows you what's been going on with <code>git add</code> and <code>git commit</code>. Status messages also include relevant instructions for staging/unstaging files. Sample output showing the three main categories of a <code>git status</code> call is included below:</p><span> </span><pre><code># On branch master # Changes to be committed: # (use "git reset HEAD &lt;file&gt;..." to unstage) # #modified: hello.py # # Changes not staged for commit: # (use "git add &lt;file&gt;..." to update what will be committed) # (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) # #modified: main.py # # Untracked files: # (use "git add &lt;file&gt;..." to include in what will be committed) # #hello.pyc</code></pre><span> </span><h4>Ignoring Files</h4><span> </span><p>Untracked files typically fall into two categories. They're either files that have just been added to the project and haven't been committed yet, or they're compiled binaries like <code>.pyc</code>, <code>.obj</code>, <code>.exe</code>, etc. While it's definitely beneficial to include the former in the <code>git status</code> output, the latter can make it hard to see what’s actually going on in your repository.</p><span> </span><p>For this reason, Git lets you completely ignore files by placing paths in a special file called <a href="https://www.atlassian.com/git/tutorials/gitignore"><code>.gitignore</code></a>. Any files that you'd like to ignore should be included on a separate line, and the * symbol can be used as a wildcard. For example, adding the following to a <code>.gitignore</code> file in your project root will prevent compiled Python modules from appearing in <code>git status</code>:</p><span> </span><pre><code>*.pyc</code></pre><span> </span><h3>Example</h3><span> </span><p>It's good practice to check the state of your repository before committing changes so that you don't accidentally commit something you don't mean to. This example displays the repository status before and after staging and committing a snapshot:</p><span> </span><pre><code># Edit hello.py git status # hello.py is listed under "Changes not staged for commit" git add hello.py git status # hello.py is listed under "Changes to be committed" git commit git status # nothing to commit (working directory clean)</code></pre><span> </span><p>The first status output will show the file as unstaged. The <code>git add</code> action will be reflected in the second <code>git status</code>, and the final status output will tell you that there is nothing to commit—the working directory matches the most recent commit. Some Git commands (e.g., <a href="https://www.atlassian.com/git/tutorials/using-branches/git-merge"><code>git merge</code></a>) require the working directory to be clean so that you don't accidentally overwrite changes.</p><span> </span><h2 id="git-log">git log</h2><span> </span><p>The <code>git log</code> command displays committed snapshots. It lets you list the project history, filter it, and search for specific changes. While <code>git status</code> lets you inspect the working directory and the staging area, <code>git log</code> only operates on the committed history.</p><span> </span><img src="https://wac-cdn.atlassian.com/dam/jcr:52d530ce-7f51-48e3-920b-a18f776048d3/01.svg?cdnVersion=da" alt="Git Tutorial: git status vs. git log"><span> </span><p>Log output can be customized in several ways, from simply filtering commits to displaying them in a completely user-defined format. Some of the most common configurations of <code>git log</code> are presented below.</p><span> </span><h3>Usage</h3><span> </span><pre><code>git log</code></pre><span> </span><p>Display the entire commit history using the default formatting. If the output takes up more than one screen, you can use <code>Space</code> to scroll and <code>q</code> to exit.</p><span> </span><pre><code>git log -n &lt;limit&gt;</code></pre><span> </span><p>Limit the number of commits by <code>&lt;limit&gt;</code>. For example, <code>git log -n 3</code> will display only 3 commits.</p><span> </span><pre><code>git log --oneline</code></pre><span> </span><p>Condense each commit to a single line. This is useful for getting a high-level overview of the project history.</p><span> </span><pre><code>git log --stat</code></pre><span> </span><p>Along with the ordinary <code>git log</code> information, include which files were altered and the relative number of lines that were added or deleted from each of them.</p><span> </span><pre><code>git log -p</code></pre><span> </span><p>Display the patch representing each commit. This shows the full diff of each commit, which is the most detailed view you can have of your project history.</p><span> </span><pre><code>git log --author="&lt;pattern&gt;"</code></pre><span> </span><p>Search for commits by a particular author. The <code>&lt;pattern&gt;</code> argument can be a plain string or a regular expression.</p><span> </span><pre><code>git log --grep="&lt;pattern&gt;"</code></pre><span> </span><p>Search for commits with a commit message that matches <code>&lt;pattern&gt;</code>, which can be a plain string or a regular expression.</p><span> </span><pre><code>git log &lt;since&gt;..&lt;until&gt;</code></pre><span> </span><p>Show only commits that occur between <code>&lt;since&gt;</code> and <code>&lt;until&gt;</code>. Both arguments can be either a commit ID, a branch name, <code>HEAD</code>, or any other kind of <a href="http://www.kernel.org/pub/software/scm/git/docs/gitrevisions.html">revision reference</a>.</p><span> </span><pre><code>git log &lt;file&gt;</code></pre><span> </span><p>Only display commits that include the specified file. This is an easy way to see the history of a particular file. </p><span> </span><pre><code>git log --graph --decorate --oneline</code></pre><span> </span><p>A few useful options to consider. The --graph flag that will draw a text based graph of the commits on the left hand side of the commit messages. --decorate adds the names of branches or tags of the commits that are shown. --oneline shows the commit information on a single line making it easier to browse through commits at-a-glance.</p><span> </span><h3>Discussion</h3><span> </span><p>The <code>git log</code> command is Git's basic tool for exploring a repository’s history. It’s what you use when you need to find a specific version of a project or figure out what changes will be introduced by merging in a feature branch.</p><span> </span><pre><code>commit 3157ee3718e180a9476bf2e5cab8e3f1e78a73b7 Author: John Smith</code></pre><span> </span><p>Most of this is pretty straightforward; however, the first line warrants some explanation. The 40-character string after <code>commit</code> is an SHA-1 checksum of the commit’s contents. This serves two purposes. First, it ensures the integrity of the commit—if it was ever corrupted, the commit would generate a different checksum. Second, it serves as a unique ID for the commit.</p><span> </span><p>This ID can be used in commands like <code>git log &lt;since&gt;..&lt;until&gt;</code> to refer to specific commits. For instance, <code>git log 3157e..5ab91</code> will display everything between the commits with ID's <code>3157e</code> and <code>5ab91</code>. Aside from checksums, branch names (discussed in the <a href="https://www.atlassian.com/git/tutorials/using-branches">Branch Module</a>) and the HEAD keyword are other common methods for referring to individual commits. <code>HEAD</code> always refers to the current commit, be it a branch or a specific commit.</p><span> </span><p>The ~ character is useful for making relative references to the parent of a commit. For example, <code>3157e~1</code> refers to the commit before <code>3157e</code>, and <code>HEAD~3</code> is the great-grandparent of the current commit.</p><span> </span><p>The idea behind all of these identification methods is to let you perform actions based on specific commits. The <code>git log</code> command is typically the starting point for these interactions, as it lets you find the commits you want to work with.</p><span> </span><h3>Example</h3><span> </span><p>The <em>Usage</em> section provides many examples of <code>git log</code>, but keep in mind that several options can be combined into a single command:</p><span> </span><pre><code>git log --author="John Smith" -p hello.py</code></pre><span> </span><p>This will display a full diff of all the changes John Smith has made to the file <code>hello.py</code>.</p><span> </span><p>The .. syntax is a very useful tool for comparing branches. The next example displays a brief overview of all the commits that are in <code>some-feature</code> that are not in <code>master</code>.</p><span> </span><pre><code>git log --oneline master..some-feature</code></pre><span> </span></div>
            </div>
            <script>var _gaq = _gaq || []; _gaq.push(['_setAccount', 'UA-34802167-1']); _gaq.push(['_setDomainName', 'liuzhe.co']); _gaq.push(['_trackPageview']); (function() { var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true; ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'; var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s); })();</script>
        </body>
        </html>