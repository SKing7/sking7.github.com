<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Performance Calendar</title>
<link rel="stylesheet" href="../css/article.css" />
</head>
<body>
<div class="m-content">
<h1>Performance Calendar</h1>
<div class="entry unit"><p>Everyone is fascinated with the smooth animation at <a href="http://paulbakaus.com/tutorials/performance/the-illusion-of-motion/">60 frames/second</a>. It is hardly a surprise that one of the most prevalent performance advices to web developers is to <a href="http://www.smashingmagazine.com/2012/06/21/play-with-hardware-accelerated-css/">use hardware accelerated CSS</a>. In some extreme cases, it is not uncommon to imply that forcing it via translate3d will automatically boost your application performance (hint: it is <a href="http://aerotwist.com/blog/css-triggers/">not the case</a>).</p><span>
</span><p>Modern web browsers can take advantage of the GPU (<a href="https://en.wikipedia.org/wiki/Graphics_processing_unit">graphics processing unit</a>) to accelerate <a href="http://blogs.msdn.com/b/ie/archive/2010/09/10/the-architecture-of-full-hardware-acceleration-of-all-web-page-content.aspx">page rendering</a>. Among many different features of a GPU, it can hold a limited number of <em>textures</em> (a rectangle of pixels) and manipulate those textures <em>efficiently</em>, including applying a certain transformation (translation, scaling, rotating, etc). This is extremely useful to achieve a <a href="http://ariya.ofilabs.com/2013/06/optimizing-css3-for-gpu-compositing.html">fluid animation</a>. Instead of drawing the pixels for every animation frame, the browser will “snapshot” the DOM element and store it as a GPU texture (often called as <strong>layer</strong>). Later, the browser will simply tell the GPU to transform the said texture to give the perception of an animating DOM element. This is called <strong>GPU compositing</strong>, naturally referred to as “hardware acceleration”.</p><span>
</span><p>Unfortunately, a web browser is a <a href="http://www.html5rocks.com/en/tutorials/internals/howbrowserswork/">complex</a> piece of software (Firefox comprises <a href="https://www.openhub.net/p/firefox/analyses/latest/languages_summary">millions of lines of code</a>). Because of this, a blanket simplified statement such as “use translate3d for performance” is likely a hit-and-miss. It is thus imperative to understand a little more as to what happens under hood so that you can understand the situation better.</p><span>
</span><p>Imagine for a moment that using a GPU-accelerated animation is like Vin Diesel driving Dominic’s iconic car, the Dodge Charger. Sure, with its custom <a href="http://fastandfurious.wikia.com/wiki/Dodge_Charger_R/T">900 hp engine</a>, it goes from 0 to 60 in a blink of an eye. But what’s the use of it when you are crawling with many other cars in a <em>packed freeway</em> during the rush hour? Your choice of vehicle – in this case, the Charger – is just fine. The problem is that you are still at the mercy of the <strong>traffic</strong> condition.</p><span>
</span><p>The same goes for GPU compositing. Many aspects of the animation still require the intervention of the CPU. After all, this is where the browser code is being executed. The bus connecting the CPU and GPU has a finite bandwidth, hence it is important to pay attention to the data transfer between them to prevent a congested channel. In other words, you should always mind the <strong>pixel traffic</strong>.</p><span>
</span><p><a href="http://calendar.perfplanet.com/wp-content/uploads/2014/12/layers.png"><img src="http://calendar.perfplanet.com/wp-content/uploads/2014/12/layers.png" alt="layers" width="557" height="266" class="alignnone size-full wp-image-1812" /></a></p><span>
</span><p>The first and foremost thing to be aware of is the <strong>number of composited layers</strong> being created. Since every layer is mapped as a GPU texture, having too many layers will exhaust the memory. This may lead to an unexpected behavior, everything from frame skipping to a potential crash. Fortunately, you can easily check those layers using the web browser itself. With Firefox, go to <code>about:config</code> and toggle <em>layers.draw-borders</em> to true. If you are a Chrome user, open <code>chrome://flags/#composited-layer-borders</code> and enable it. For Safari fans, first run this on your OS X terminal: <code>defaults write com.apple.Safari IncludeInternalDebugMenu 1</code>.  Relaunch Safari and there will be an additional top-level menu <em>Debug</em> where you can find <em>Drawing/Compositing Flags, Show Compositing Borders</em>. You can also get the memory consumption of every layer by looking at the <a href="https://developer.apple.com/library/safari/documentation/AppleApplications/Conceptual/Safari_Developer_Guide/ResourcesandtheDOM/ResourcesandtheDOM.html#//apple_ref/doc/uid/TP40007874-CH3-SW8">Layer sidebar</a> in Web Inspector.</p><span>
</span><p>When those web browsers are configured with the appropriate flag, every DOM element that is composited by the GPU will be marked with the additional <em>colored border</em> (as a quick test, try it on this <a href="http://ariya.github.io/css/spinningcube/">Spinning Cube</a> demo). This way, it is easy to verify whether your web page has too many layers.</p><span>
</span><p>Another important aspect of this GPU compositing business is to keep the traffic between GPU and CPU to the minimum. In other words, <strong>the amount of layer updates</strong> is ideally a constant. Every time there is an update, a new set of pixels potentially needs to be transferred to the GPU. Thus, for performance reasons, it is important to avoid any layer updates after the animation already starts. This is possible by carefully <a href="http://www.html5rocks.com/en/tutorials/speed/high-performance-animations/">choosing the properties</a> to be animated: <a href="http://dev.w3.org/csswg/css-transforms/">transformation</a> (translate, scale, rotate), <a href="http://dev.w3.org/csswg/css-color/#transparency">opacity</a>, or <a href="http://dev.w3.org/fxtf/filters/">filters</a>.</p><span>
</span><p>If you use Safari’s Web Inspector, the <a href="https://developer.apple.com/library/safari/documentation/AppleApplications/Conceptual/Safari_Developer_Guide/ResourcesandtheDOM/ResourcesandtheDOM.html#//apple_ref/doc/uid/TP40007874-CH3-SW8">Layer sidebar</a> reveals the layer updates in the Paints field. It indicates how many times Safari uploads a new texture to reflect the content of the layer. Try it on the <a href="http://codepen.io/ariya/full/xuwgy">Colorful Boxes</a> demo where each box alternates its color between blue and green. Unfortunately, changing the box’s background color forces a layer update and hence is why the paints number keeps increasing during the animation. With just one box it might be fine, but a hundred boxes like that will bring the GPU to its knees. While this is a contrived case, it serves as a reminder that no amount of translate3d will save the day if your pixel traffic is disastrous to begin with!</p><span>
</span><p>Necessity is the mother of invention. The constraints of working with layers often lead to creative and surprising ways to exploit the system. A variant of “terraforming” can be achieved by having the initial and final portions of the UI reside in the same layer with a <a href="https://www.youtube.com/watch?v=RCFQu0hK6bU">clipping rectangle</a> showing one part and hiding the other. Another slightly similar illusion is employing <a href="http://ariya.ofilabs.com/2014/02/tricks-for-gpu-composited-css.html">two layers superimposed</a> on top each other. The animation is carried out by simply changing the opacity of both layers so that the result is a tweening of both, as demonstrated in this <a href="http://codepen.io/ariya/full/nFADe">Glowing Effect</a> demo.</p><span>
</span><p>Another common practice to maintain a reasonable pixel traffic is by having a pool of layers. When some layers are not needed, they are not disposed completely as they can be moved off-screen or set to fully transparent. In some cases, the user interface design implicitly permits a finite number of layers. The following screenshot shows the <a href="http://ariya.github.io/kinetic/5/index.html">Cover Flow</a> example where only 9 (nine) images are visible at any given time. Even if it is supposed to display hundreds of book covers (as the user <a href="http://ariya.ofilabs.com/2014/01/javascript-kinetic-scrolling-part-5-cover-flow-effect.html">swipes</a> left and right), you do not need to build tons of layers at once. With a little bit of trick, you can swap the content of a layer with the new image at the right time and the user will not notice it.</p><span>
</span><p><a href="http://calendar.perfplanet.com/wp-content/uploads/2014/12/cover_flow.png"><img src="http://calendar.perfplanet.com/wp-content/uploads/2014/12/cover_flow.png" alt="cover_flow" width="500" height="183" class="alignnone size-full wp-image-1800" /></a></p><span>
</span><p>Also, never forget that you must always run a profiler to double check your theory. Performance is a serious matter and it will be a mistake to rely only on gut feelings. Chrome users should enable <code>chrome://flags/#show-fps-counter</code>. Its equivalent in Firefox is <em>layers.acceleration.draw-fps</em> from <code>about:config</code>. With the frame rate counter, run your animation and watch it carefully. If the frame rate drops below 60 fps (or whatever threshold you are aiming for), then it is time to investigate the issue. For this, Chrome’s <a href="https://developer.chrome.com/devtools/docs/timeline#frames-mode">Timeline feature</a> or Safari’s <a href="https://developer.apple.com/library/safari/documentation/AppleApplications/Conceptual/Safari_Developer_Guide/Instruments/Instruments.html#//apple_ref/doc/uid/TP40007874-CH4-SW4">Timeline panel</a> will give a detailed insight of every rendering operations: layout, painting, and compositing.</p><span>
</span><p>To prevent performance regressions, an automatic variant of the above step is necessary. This is where <a href="https://github.com/axemclion/browser-perf">browser-perf</a> from <a href="http://nparashuram.com/">Parashuram</a> becomes extremely handy. As he already <a href="http://calendar.perfplanet.com/2014/automating-web-page-rendering-performance/">wrote</a> a few weeks ago, browser-perf gathers some important rendering statistics from running the tests on the web page. For this context, metrics for <a href="http://blog.nparashuram.com/2014/06/gpu-composited-css-and-browser-perf.html">layer counts and paint counts</a> are extremely valuable. The data enables you to trigger an alert if those values regress over time.</p><span>
</span><p>While many articles have been written on the subject of hardware accelerated CSS, hopefully this post serves as another quick reference on how to (ab)use GPU composited animation in such a way that it does not land us in the naughty list of 2015. Stay out of trouble and happy accelerating!</p><span>
</span></div></div>
<script>var _gaq = _gaq || []; _gaq.push(['_setAccount', 'UA-34802167-1']); _gaq.push(['_setDomainName', 'liuzhe.co']); _gaq.push(['_trackPageview']); (function() { var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true; ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'; var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s); })();</script></body>
</html>