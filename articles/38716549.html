<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Frontend SPOF | High Performance Web Sites</title>
</head>
<body>
<div id="post-1300"><p>June 1, 2010 7:49 pm | <a href="http://www.stevesouders.com/blog/2010/06/01/frontend-spof/#comments" title="Comment on Frontend SPOF">9 Comments</a></p><!-- .entry-meta --><p>My evangelism of high performance web sites started off in the context of quality code and development best practices. It’s easy for a style of coding to permeate throughout a company. Developers switch teams. Code is copied and pasted (especially in the world of web development). If everyone is developing in a high performance way, that’s the style that will characterize how the company codes.</p><p>This argument of promoting development best practices gained traction in the engineering quarters of the companies I talked to, but performance improvements continued to get backburnered in favor of new features and content that appealed to the business side of the organization. Improving performance wasn’t considered as important as other changes. Everyone assumed users wanted new features and that’s what got the most attention.</p><p>It became clear to me that we needed to show a business case for web performance. That’s why the theme for <a href="http://en.oreilly.com/velocity2009">Velocity 2009</a> was “the impact of performance on the bottom line”. Since then there have been <a href="http://blog.mozilla.com/metrics/category/website-optimization/">numerous</a> <a href="http://radar.oreilly.com/2009/07/velocity-making-your-site-fast.html">studies</a> <a href="http://www.stevesouders.com/blog/2009/07/27/wikia-fast-pages-retain-users/">released</a> <a href="http://carsonified.com/blog/business/fred-wilsons-10-golden-principles-of-successful-web-apps/">that</a> <a href="http://www.watchingwebsites.com/archives/proof-that-speeding-up-websites-improves-online-business">have</a> <a href="http://googlewebmastercentral.blogspot.com/2010/04/using-site-speed-in-web-search-ranking.html">shown</a> that improving performance <em>does</em> improve the bottom line. As a result, I’m seeing the business side of many web companies becoming strong advocates for <a href="http://www.stevesouders.com/blog/2010/05/07/wpo-web-performance-optimization/">Web Performance Optimization</a>.</p><p>But there are still occasions when I have a hard time convincing a team that focusing on web performance, specifically frontend performance, is important. Shaving off hundreds (or even thousands) of milliseconds just doesn’t seem worthwhile to them. That’s when I pull out the big guns and explain that <em>loading scripts and stylesheets in the typical way creates a frontend single point of failure that can bring down the entire site</em>.</p><h2>Examples of Frontend SPOF</h2><p>The thought that simply adding a script or stylesheet to your web page could make the entire site unavailable surprises many people. Rather than focusing on CSS mistakes and JavaScript errors, the key is to think about what happens when a resource request times out. With this clue, it’s easy to create a test case:</p><pre>&lt;html&gt;
&lt;head&gt;
&lt;script src="http://www.snippet.com/main.js" type="text/javascript"&gt;
  &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
Here's my page!
&lt;/body&gt;
&lt;/html&gt;</pre><p>This HTML page looks pretty normal, but if snippet.com is overloaded the entire page is blank waiting for main.js to return. This is true in all browsers.</p><p>Here are some examples of frontend single points of failure and the browsers they impact. You can click on the Frontend SPOF test links to see the actual test page.</p><p>* Internet Explorer 9 does not display a blank page, but does “flash” the element.</p><p>The failure cases are highlighted in red. Here are the four possible outcomes sorted from worst to best:</p><ul>
<li><em>totally blank</em> – Nothing in the page is rendered – the entire page is blank.</li>
<li><em>blank below</em> – All the DOM elements below the resource in question are not rendered.</li>
<li><em>delayed</em> – Text that uses the @font-face style is invisible until the font file arrives.</li>
<li><em>flash</em> – DOM elements are rendered immediately, and then redrawn if necessary after the stylesheet or font has finished downloading.</li>
</ul><h2>Web Performance avoids SPOF</h2><p>It turns out that there are web performance best practices that, in addition to making your pages faster, also avoid most of these frontend single points of failure. Let’s look at the tests one by one.</p><dl>
<dt><strong><a href="http://stevesouders.com/tests/spof/slow-script.php">External Script</a></strong>&nbsp;</dt>
<dd>All browsers block rendering of elements below an external script until the script arrives and is parsed and executed. Since many sites put scripts in the HEAD, this means the entire page is typically blank. That’s why I believe the most important web performance coding pattern for today’s web sites is to <a href="http://www.stevesouders.com/blog/2009/04/27/loading-scripts-without-blocking/">load JavaScript asynchronously</a>. Not only does this improve performance, but it avoids making external scripts a possible SPOF.&nbsp;</dd>
<dt><strong><a href="http://stevesouders.com/tests/spof/slow-stylesheet.php">Stylesheet</a></strong>&nbsp;</dt>
<dd>Browsers are split on how they handle stylesheets. Firefox and Opera charge ahead and render the page, and then flash the user if elements have to be redrawn because their styling changed. Chrome, Internet Explorer, and Safari delay rendering the page until the stylesheets have arrived. (Generally they only delay rendering elements below the stylesheet, but in <a href="http://stevesouders.com/hpws/css-bottom.php">some cases</a> IE will delay rendering everything in the page.) If rendering is blocked and the stylesheet takes a long time to download, or times out, the user is left staring at a blank page. There’s not a lot of advice on loading stylesheets without blocking page rendering, primarily because it would introduce the <a href="http://www.bluerobot.com/web/css/fouc.asp/">flash of unstyled content</a>.</dd>
<dt><strong><a href="http://stevesouders.com/tests/spof/slow-font.php">inlined @font-face</a></strong>&nbsp;</dt>
<dd>I’ve blogged before about the <a href="http://www.stevesouders.com/blog/2009/10/13/font-face-and-performance/">performance implications of using @font-face</a>. When the @font-face style is declared in a STYLE block in the HTML document, the SPOF issues are dramatically reduced. Firefox, Internet Explorer, and Opera avoid making these custom font files a SPOF by rendering the affected text and then redrawing it after the font file arrives. Chrome and Safari don’t render the customized text at all until the font file arrives. I’ve drawn these cells in yellow since it could cause the page to be unusable for users using these browsers, but most sites only use custom fonts on a subset of the page.</dd>
<dt><strong><a href="http://stevesouders.com/tests/spof/slow-font-stylesheet.php">Stylesheet with @font-face</a></strong>&nbsp;</dt>
<dd>Inlining your @font-face style is the key to avoiding having font files be a single point of failure. If you inline your @font-face styles and the font file takes forever to return or times out, the worst case is the affected text is invisible in Chrome and Safari. But at least the rest of the page is visible, and everything is visible in Firefox, IE, and Opera. Moving the @font-face style to a stylesheet not only slows down your site (by requiring two sequential downloads to render text), but it also creates a special case in Internet Explorer 7 &amp; 8 where the entire page is blocked from rendering. IE 6 is only slightly better – the elements below the stylesheet are blocked from rendering (but if your stylesheet is in the HEAD this is the same outcome).</dd>
<dt><strong><a href="http://stevesouders.com/tests/spof/slow-font-script.php">Script then @font-face</a></strong>&nbsp;</dt>
<dd>Inlining your @font-face style isn’t enough to avoid the entire page SPOF that occurs in IE. You also have to make sure the inline STYLE block isn’t preceded by a SCRIPT tag. Otherwise, your entire page is blank in IE waiting for the font file to arrive. If that file is slow to return, your users are left staring at a blank page.</dd>
</dl><h2>SPOF is bad</h2><p>Five years ago most of the attention on web performance was focused on the backend. Since then we’ve learned that 80% of the time users wait for a web page to load is the responsibility of the frontend. I feel this same bias when it comes to identifying and guarding against single points of failure that can bring down a web site – the focus is on the backend and there’s not enough focus on the frontend. For larger web sites, the days of a single server, single router, single data center, and other backend SPOFs are way behind us. And yet, most major web sites include scripts and stylesheets in the typical way that creates a frontend SPOF. Even more worrisome – many of these scripts are from third parties for social widgets, web analytics, and ads.</p><p>Look at the scripts, stylesheets, and font files in your web page from a worst case scenario perspective. Ask yourself:</p><ul>
<li>Is your web site’s availability dependent on these resources?</li>
<li>Is it possible that if one of these resources timed out, users would be blocked from seeing your site?</li>
<li>Are any of these single point of failure resources from a third party?</li>
<li>Would you rather embed resources in a way that avoids making them a frontend SPOF?</li>
</ul><p>Make sure you’re aware of your frontend SPOFs, track their availability and latency closely, and embed them in your page in a non-blocking way whenever possible.</p><div><strong>Update Oct 12:</strong><p style="display: inline;"> Pat Meenan created a </p><a href="http://blog.patrickmeenan.com/2011/10/testing-for-frontend-spof.html">blackhole server</a><p style="display: inline;"> that you can use to detect frontend SPOF in webpages.</p></div></div></body>
</html>