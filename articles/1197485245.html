
        <!doctype html>
        <html>
        <head>
            <meta charset="utf-8"/>
            <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
            <title>Implementing HTTP/2 in Production Environments</title>
            <link rel="stylesheet" href="../css/article.css" />;
        </head>
        <body>
            <div class="m-content">
                <h1>Implementing HTTP/2 in Production Environments</h1>
                <div class="post-body"><span>
												</span><p><em>This post is part two of a two-part series detailing HTTP/2 best practices. Part one—</em><em><a href="https://blog.newrelic.com/2016/02/09/http2-best-practices-web-performance/">How HTTP/2 is Changing Web Performance Best Practice</a>s—</em><em>introduced HTTP/2 and explained how it changes Web-performance best practices.</em></p><span>
</span><p>In the first post in this series about HTTP/2, we discussed different ways the new protocol affects Web performance best practices. Although HTTP/2 offers several improvements over its predecessor—including new features like TCP connection multiplexing, header compression, and server push—an instant performance boost when making the transition isn’t guaranteed as Web developers are still determining best practices. This post covers what’s required to implement and debug HTTP/2-capable Web applications in production environments.</p><span>
</span><h3>4/4 major browser vendors agree: HTTPS is required</h3><span>
</span><p>Firefox, Internet Explorer, Safari, and Chrome all agree: HTTPS is required to use HTTP/2 in the first place. This is critical because of a new extension to Transport Layer Security (TLS) that allows browsers and clients to negotiate which application-layer protocol to use. When a TLS connection is established for the first time, the server broadcasts support for HTTP 1.1, SPDY, or HTTP/2 without an additional round trip.</p><span>
</span><p>Because of <a href="http://blog.chromium.org/2016/02/transitioning-from-spdy-to-http2.html" target="_blank">changes Google recently announced</a>, it’s critical that backend SSL libraries are updated before Chrome drops support for the older <a href="https://tools.ietf.org/html/draft-agl-tls-nextprotoneg-00" target="_blank">Next Protocol Negotiation</a> standard in favor of <a href="https://en.wikipedia.org/wiki/Application-Layer_Protocol_Negotiation" target="_blank">Application Layer Protocol Negotiation</a>. Unfortunately, for almost every modern Linux distribution, this means compiling Web server software from source code with OpenSSL version 1.0.2 (not a trivial task).</p><span>
</span><p>With the latest version of OpenSSL installed on servers, however, it’s possible it check hosts for HTTP/2 support from the command line:</p><span>
</span><p><code>me@ubuntu-trusty-64:~$ echo | openssl s_client -alpn h2 -connect google.com:443 | grep ALPN<br>ALPN protocol: h2<br>DONE</code></p><span>
</span><p>A <a href="https://tools.keycdn.com/http2-test" target="_blank">Web-based tool from KeyCDN</a> and the <a href="https://github.com/stefanjudis/is-http2-cli" target="_blank">is-http2 package</a> can also help determine host support.</p><span>
</span><p>The transition to the new protocol is relatively straightforward for sites that are already delivered securely. For non-secure sites, Web servers (and potentially CDNs) will need to be correctly configured for HTTPS. New open-source projects such as <a href="https://letsencrypt.org/" target="_blank">Let’s Encrypt</a> aim to make this process as easy, free, and automated as possible. Of course, regardless of HTTP/2 support, moving to HTTPS is becoming more important. Some search engines now use secure sites as a <a href="https://googlewebmastercentral.blogspot.co.uk/2014/08/https-as-ranking-signal.html" target="_blank">positive signal in page ranking</a> and privacy advocates and industry experts strongly recommend it.</p><span>
</span><h3>Determining backend and content-delivery network support</h3><span>
</span><p>If HTTPS is properly configured, the next step is determining if the server or proxy software supports HTTP/2. The IETF HTTP Working Group <a href="https://github.com/http2/http2-spec/wiki/Implementations" target="_blank">maintains a comprehensive list</a> of known implementations on its website and popular Web servers have all released or committed to support. Most popular application development languages have HTTP/2 packages as well.</p><span>
</span><p><img class="aligncenter size-full wp-image-29201" src="https://blog.newrelic.com/wp-content/uploads/server-chart.jpg" alt="server chart" width="700" height="272"></p><span>
</span><p>Support for the full suite of HTTP/2 features, especially server push, is not guaranteed. It’s necessary to read the releases notes to determine which features are fully supported.</p><span>
</span><p>If your site uses assets delivered by a Content Delivery Network (CDN), major vendors like <a href="https://www.cloudflare.com/" target="_blank">CloudFlare</a> and <a href="https://www.keycdn.com/" target="_blank">KeyCDN</a> already support the new protocol even if your backend doesn’t. With some providers, enabling HTTP/2 between your client and the edge locations can be as easy as toggling a radio button on a Web form.</p><span>
</span><p><img class="aligncenter size-full wp-image-29202" src="https://blog.newrelic.com/wp-content/uploads/CDN-chart.jpg" alt="CDN chart" width="700" height="186"></p><span>
</span><h3>Using Wireshark for debugging</h3><span>
</span><p>HTTP/2 tooling still has a long way to go before catching up with HTTP 1.1. Because HTTP/2 is a binary protocol, simple debugging using telnet won’t work and standard debugging proxies like <a href="https://www.charlesproxy.com/" target="_blank">Charles</a> and <a href="http://www.telerik.com/fiddler" target="_blank">Fiddler</a> do not offer support as of January 2016.</p><span>
</span><p>In <a href="https://blog.newrelic.com/2016/02/09/http2-best-practices-web-performance/">part one of our HTTP/2 series</a>, we discussed how to use Chrome Net Internals (<code>chrome://net-internals#http2</code>) to debug traffic. For more advanced analysis, using the low-level C (or Python bindings) of the <a href="https://nghttp2.org/" target="_blank">nghttp2 library</a> or Wireshark 2.0 is needed. Here, we’ll focus on <a href="https://www.wireshark.org/" target="_blank">Wireshark</a>.</p><span>
</span><p>Configuring Wireshark to view HTTP/2 frame requires additional setup because all traffic is encrypted. To view Firefox or Chrome HTTP/2 traffic, you have to log TLS session information to a file specified by the environment variable <code>SSLKEYLOGFILE</code>. On Mac OS X, set the environment variable before launching the browser from the command line (you can see Windows instructions <a href="https://jimshaver.net/2015/02/11/decrypting-tls-browser-traffic-with-wireshark-the-easy-way/" target="_blank">here</a>):</p><span>
</span><p><code>$ export SSLKEYLOGFILE=~/Desktop/tls_fun.log<br>$ open -a Google\ Chrome https://nghttp2.org/</code></p><span>
</span><p>Wireshark must be configured to use the SSLKEYLOGFILE in the preferences menu under the “SSL” protocol listing:</p><span>
</span><div id="attachment_29196" class="wp-caption aligncenter"><img class="wp-image-29196 size-full" src="https://blog.newrelic.com/wp-content/uploads/wireshark-screen.jpg" alt="wireshark screen" width="600" height="396"><p class="wp-caption-text"><em>Configuring Wireshark for the location of SSLKEYLOGFILE</em></p></div><span>
</span><p>When starting Wireshark for the first time, a network interface needs to be selected. Filtering only on port 443 is a good idea since all HTTP/2 traffic in Chrome is secure.</p><span>
</span><div id="attachment_29197" class="wp-caption aligncenter"><img class="size-full wp-image-29197" src="https://blog.newrelic.com/wp-content/uploads/wireshark-screen-2.jpg" alt="wireshark screen 2" width="417" height="265"><p class="wp-caption-text"><em>Filtering HTTPS traffic on a Wi-Fi network card</em></p></div><span>
</span><p>After clicking on the shark icon, recording begins for all traffic sent over that interface. The output can be overwhelming, but it’s easy to filter HTTP/2-only traffic by typing “http2” into the filter text box. When HTTP/2 packets are captured, they can now be decrypted into individual HTTP2 binary frames:</p><span>
</span><div id="attachment_29198" class="wp-caption aligncenter"><img class="size-full wp-image-29198" src="https://blog.newrelic.com/wp-content/uploads/debugging-encrypted.jpg" alt="debugging encrypted" width="700" height="520"><p class="wp-caption-text"><em>Debugging encrypted HTTP/2 traffic in Wireshark</em></p></div><span>
</span><p>Using the tabs at the bottom of the data panel, it’s possible to see the decrypted frames. HEADERS frames, which are always compressed, can also be displayed decompressed.</p><span>
</span><h3>The transition is not yet straightforward</h3><span>
</span><p>For many Web applications in early 2016, transitioning to HTTP/2 is not yet straightforward. Not only is HTTPS required in order to use the new protocol in browsers, it’s likely that server software will also need to be upgraded. In some cases, particularly with Backend-as-a-Service providers or Content Delivery Networks, HTTP/2 support might not be available—or even promised—yet. Lastly, easy-to-use debugging tools are still being worked on.</p><span>
</span><p>As many teams have already discovered, it is likely that migrating any large site to HTTP/2 will likely contain surprises. Despite these challenges, many large Web properties have successfully launched HTTP/2 support with <a href="http://blog.chromium.org/2013/11/making-web-faster-with-spdy-and-http2.html" target="_blank">significant performance benefits</a>. Carefully measuring real-user performance and understanding the limitations of current tooling is helpful to making the transition as smooth as possible.</p><span>
</span><h3>Additional resources</h3><span>
</span><span>
</span><p><strong>Be sure to read part one of this two-part series:&nbsp;<a href="https://blog.newrelic.com/2016/02/09/http2-best-practices-web-performance/">How HTTP/2 Is Changing Web Performance Best Practices</a></strong></p><span>
</span><p><a href="https://blog.newrelic.com/author/jeffmartens/" target="_blank"><em>Jeff Martens</em></a><em>, Product Manager for </em><a href="http://newrelic.com/browser-monitoring" target="_blank"><em>New Relic Browser</em></a><em>, and Web performance expert </em><a href="http://andydavies.me/" target="_blank"><em>Andy Davies</em></a><em> contributed to this post with technical feedback and invaluable suggestions.</em></p><span>
</span><p><em><a href="http://www.shutterstock.com/pic-372773749.html" target="_blank">Background image</a> courtesy of <a href="http://www.shutterstock.com/" target="_blank">Shutterstock.com</a>.</em></p><span>
											</span></div>
            </div>
            <script>var _gaq = _gaq || []; _gaq.push(['_setAccount', 'UA-34802167-1']); _gaq.push(['_setDomainName', 'liuzhe.co']); _gaq.push(['_trackPageview']); (function() { var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true; ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'; var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s); })();</script>
        </body>
        </html>