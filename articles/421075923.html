<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>HTML5 Canvas Fingerprinting</title>
<link rel="stylesheet" href="../css/article.css" />
</head>
<body>
<div class="m-content">
<h1>HTML5 Canvas Fingerprinting</h1>
<div id="canvas-fingerprint" class="JS"><header></header><ins class="adsbygoogle" data-ad-slot="1319586667"></ins><noscript><p>JavaScript Disabled — Canvas element is part of HTML5, but it also requires JavaScript</p></noscript><p>This browser does not support HTML5 Canvas</p><p>This is a simple Proof-of-Concept that Browser Fingerprinting is possible without any of User-Agent identifiers.</p><p>The method is based on the fact that the same HTML5 Canvas element can produce exceptional pixels on a different web browsers, depending on the system on which it was executed.</p><p>This happens for several reasons: at the image format level — web browsers uses different image processing engines, export options, compression level, final images may got different hashes even if they are pixel-perfect; at the pixmap level — operating systems use different algorithms and settings for anti-aliasing and sub-pixel rendering. We don't know all the reasons, but we have already collected more than a thousand unique signatures.</p><p>Well, let's begin. After the tables we give a brief explanation…</p><table><tr class="thead"><td colspan="2"></td></tr><tr><td>Canvas (basic support)</td><td colspan="3" id="mzr-canvas"><span class="bad">×</span> False</td></tr><tr><td>Text API for Canvas</td><td colspan="3" id="mzr-canvas-text"><span class="bad">×</span> False</td></tr></table><table><tr class="thead"><td colspan="2"></td></tr><tr><td>Total Visitors Processed</td><td id="db-visitors"></td></tr><tr><td>Total Sets (User-Agents)</td><td id="db-sets"></td></tr><tr><td>Total Groups (Signatures)</td><td id="db-groups"></td></tr></table><table class="NOCANVAS"><tr class="thead"><td colspan="2"></td></tr><tr><td>Signature</td><td id="crc"></td></tr><tr><td>Found in DB</td><td colspan="3" id="crc-detect"></td></tr><tr><td>General Conclusion</td><td id="crc-verdict"><span id="crc-verdict-true" class="none">It is very likely that you are using <span id="crc-verdict-ua">Web Browser</span> on <span id="crc-verdict-os">Operating System</span></span> <span id="crc-verdict-false" class="none">Your system fingerprint appears to be unique, yet we don't collect signatures here, just check.</span></td></tr></table><table id="canvas-table" class="NOCANVAS"><tr class="thead"><td colspan="6"></td></tr><tr><td colspan="2">Sets in this Group</td><td colspan="4" id="crc-count"></td></tr></table><h3 class="warn-help" id="scope-of-the-issue" name="scope-of-the-issue"><a href="http://www.browserleaks.com/canvas#scope-of-the-issue" title="Click to expand">Scope of the Issue</a></h3><div><p>Unlike the other «browser detection» tricks, it deals with many OS features related on graphics environment. Potentially it can be used to identify the video adapter, especially if you are use WebGL profiling, not just Canvas 2D Context. By the way different graphics card drivers can also sometimes affect to regular fonts rendering.</p><p>This technique is good to make a unique/trackable signature when it is combined with other common methods, e.g. in systems such as EFF's Panopticlick or PET's Fingerprinting.</p><p>Much more difficult to obtain specific parameters of the system. It is signature-based, and the problem of signature collection is the main limiting factor why it is not so easy at the moment. We can produce Canvas/WebGL pixmap, and associate its fingerprint with own machine, but we cannot ask each visitor individually about his system and hardware. Certainly, there are ways to get such info: malware, social engineering, mturk, but for now we do not consider them, for now :)</p></div><h3 class="warn-help" id="how-does-it-work" name="how-does-it-work"><a href="http://www.browserleaks.com/canvas#how-does-it-work" title="Click to expand">How Does It Work</a></h3><div><p>First of all, there will be no any ready-to-embed solutions, this is only demo. We are just going to share some snippets how it works under the hood.</p><p>Our signatures DB is based on a simple association between «Canvas Fingerprint» and «HTTP User-Agent», so it is very prone to false positives because of the faked headers, etc. If your fingerprint matches one that is stored in database, the program will show you which User-Agents have the same signature. Otherwise, well, your browser seems unique for our modest DB, but we cannot sign you here in any way, because we do not collect signatures from this website.</p><p>Here is the javascript code that produce the pixels:</p><ol class="code" contenteditable="true" spellcheck="false"><li><span><span class="c">// text with lowercase/uppercase/punctuation symbols</span></span></li><li><span><span class="z">var</span> txt = <span class="x">"BrowserLeaks,com &lt;canvas&gt; 1.0"</span>;</span></li><li><span>ctx.textBaseline = <span class="x">"top"</span>;</span></li><li><span><span class="c">// the most common type</span></span></li><li><span>ctx.font = <span class="x">"14px 'Arial'"</span>;</span></li><li><span>ctx.textBaseline = <span class="x">"alphabetic"</span>;</span></li><li><span>ctx.fillStyle = <span class="x">"#f60"</span>;</span></li><li><span>ctx.fillRect(125,1,62,20);</span></li><li><span><span class="c">// some tricks for color mixing</span></span></li><li><span>ctx.fillStyle = <span class="x">"#069"</span>;</span></li><li><span>ctx.fillText(txt, 2, 15);</span></li><li><span>ctx.fillStyle = <span class="x">"rgba(102, 204, 0, 0.7)"</span>;</span></li><li><span>ctx.fillText(txt, 4, 17);</span></li><li><span><span class="c">// more explanation? see the Further Reading below...</span></span></li></ol><table><tr><td>The result will be the image</td><td><p><span class="bad">×</span><noscript>JavaScript Disabled or </noscript>Your browser does not support HTML5 Canvas</p></td></tr></table><p>To create a signature from the canvas, we must export the pixels from the application's memory using the toDataURL() method, which will return the base64-encoded string of the binary image file. Then we can just create MD5 hash of this string.</p><p>But for the PoC we came up with a slightly more interesting decision. As we know, PNG files is divided into chunks, and last part of each chunk is a 32-bit CRC checksum calculated on the preceding bytes. So all we need is to extract the IDAT CRC — that will be the browser fingerprint:</p><ol class="code" contenteditable="true" spellcheck="false"><li><span><span class="c">// code is simple but we must provide some conversion functions</span></span></li><li><span><span class="c">// it is still less and faster than md5</span></span></li><li><span> </span></li><li><span><span class="z">function</span> bin2hex (s) {</span></li><li><span>    <span class="c">// ... bin-to-hex conversion code ...</span></span></li><li><span>}</span></li><li><span> </span></li><li><span><span class="z">if</span> (typeof window.atob == <span class="x">"undefined"</span>) {</span></li><li><span>    <span class="z">function</span> atob(a) {</span></li><li><span>    <span class="c">// IE9 still has not atob() function (base64-to-binary)</span></span></li><li><span>    <span class="c">// ... you must put some replacement here ...</span></span></li><li><span>    }</span></li><li><span>}</span></li><li><span> </span></li><li><span><span class="z">var</span> b64 = canvas.toDataURL.replace(<span class="x">"data:image/png;base64,"</span>,<span class="x">""</span>);</span></li><li><span><span class="z">var</span> bin = atob(b64);</span></li><li><span> </span></li><li><span><span class="c">// crc32 takes only 4 bytes and placed from 16 to 12 byte from the end of file</span></span></li><li><span><span class="z">var</span> crc = bin2hex(bin.slice(-16,-12));</span></li></ol></div></div></div>
<script>var _gaq = _gaq || []; _gaq.push(['_setAccount', 'UA-34802167-1']); _gaq.push(['_setDomainName', 'liuzhe.co']); _gaq.push(['_trackPageview']); (function() { var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true; ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'; var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s); })();</script></body>
</html>