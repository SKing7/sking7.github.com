<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>How To Reduce Image Size With WebP Automagically » MaxCDN Blog</title>
<link rel="stylesheet" href="../css/article.css" />
</head>
<body>
<div class="m-content">
<h1>How To Reduce Image Size With WebP Automagically » MaxCDN Blog</h1>
<div><blockquote>This guest post is by&nbsp;<a href="https://twitter.com/adamdbradley" target="_blank">Adam Bradley</a>, founder and developer of&nbsp;<a href="http://www.cdnconnect.com/" target="_blank">CDN Connect</a>. He specializes in image optimization, resizing, content-aware cropping, and responsive web design, with the goal of keeping content strategies and workflows simple.</blockquote><b>tl;dr</b><p style="display: inline;">&nbsp;Browsers may use the </p><code>Accept</code><p style="display: inline;"> header to indicate supported content types. This lets you serve optimized images to minimize bandwidth and improve page load, without any changes to HTML/CSS or the images themselves. Here's how:</p><ul><li>The WebP image format offers better compression and smaller file sizes</li><li>The HTTP <code>Accept</code> header lets origin servers determine the best image format to send the browser<b><b> </b></b></li><li>Services like CDN Connect can send back WebP images (where supported), without a single site change<span id="more-2460"></span></li></ul><h2>The Problem: Big Images</h2><p style="display: inline;"> It’s common to minify CSS and JavaScript files by removing whitespace and comments, renaming variables, and a few other tricks. The main benefit is reducing download times and providing visitors with a faster page load. But on the average webpage, we're overlooking the gigantic elephant in the room: images.
Images can dwarf text files like CSS and JavaScript: </p><a href="http://httparchive.org/interesting.php#bytesperpage">according to httparchive.org</a><p style="display: inline;">, they comprise over 60% of the transfer of average webpage. </p><a href="http://gigaom.com/2012/05/23/the-growing-epidemic-of-page-bloat/">GigaOM reports</a><p style="display: inline;"> that webpages grew by 50% between November 2010 and May 2012, and estimates an average size of 2MB by 2015. Combine this growth with the increasing use of mobile devices (i.e., expensive, capped bandwidth), and we're heading in the wrong direction.</p><h2>The Solution: Optimize Images With WebP</h2><p style="display: inline;"> Fortunately, Google and other companies are working to reduce bandwidth usage. A major achievement is a new image format,&nbsp;</p><a href="https://developers.google.com/speed/webp/" target="_blank">WebP</a><p style="display: inline;">,&nbsp;which handles lossy (JPEG) and lossless (PNG) images, all while reducing file sizes. According to Google:</p><blockquote>WebP lossless images are <strong>26% smaller</strong> in size compared to PNGs. WebP lossy images are <strong>25-34% smaller</strong> in size compared to JPEG images at equivalent SSIM index. WebP supports lossless transparency (also known as alpha channel) with just 22% additional bytes. Transparency is also supported with lossy compression and typically provides 3x smaller file sizes compared to PNG when lossy compression is acceptable for the red/green/blue color channels.<b><b>&nbsp;</b></b></blockquote><p style="display: inline;"> Chrome and Opera support WebP, and&nbsp;</p><a href="http://news.cnet.com/8301-17939_109-57578813-2/why-mozilla-had-a-change-of-heart-about-webp-images/" target="_blank">Firefox is considering support</a><p style="display: inline;">&nbsp;as well. With increasing adoption and bandwidth benefits, WebP may become the go-to web image format.</p><b><b>&nbsp;</b></b><p style="display: inline;"> This is great news, but WebP raises several questions, especially for graphic designers, web designers and developers. How can we use WebP without an involved manual process? How can we serve images to browsers that don't support WebP? How can we update existing references to our &nbsp;</p><code>.jpg</code><p style="display: inline;">, </p><code>.png</code><p style="display: inline;"> and </p><code>.gif</code><p style="display: inline;"> files?</p><h3>Wouldn’t it be great if we could upgrade to WebP Automagically?</h3><p style="display: inline;"> Don't believe me? Let's see it in action.
The example image below looks the same for all visitors: it's served as WebP if supported, and PNG otherwise. The original PNG file (exported from Photoshop) was 52kb. </p><a href="http://jdorfman.cdnconnect.com/maxcdn/MaxCDN-WebP.png" target="_blank"><img alt="saveforweb-maxcdn" src="http://jdorfman.cdnconnect.com/maxcdn/MaxCDN-WebP.png" width="294" height="254" /></a><p style="display: inline;"> But with&nbsp;</p><a href="http://www.cdnconnect.com" target="_blank">CDN Connect</a><p style="display: inline;">’s automatic image re-encoding, this 52kb PNG shrunk to a 11kb WebP image. </p><strong>That's a 78% size reduction</strong><p style="display: inline;">! Just imagine this image was referenced on every page of your site, and you had handfuls of similar images to download. The potential bandwidth savings and performance improvements are enormous.
Additionally, there were no site changes:</p><ul><li>No JavaScript hacks</li><li>No DOM manipulation</li><li>No edits to HTML or CSS</li><li><strong>CDN Connect + WebP just works</strong></li></ul><p style="display: inline;"> For this image, the 78% size reduction worked extremely well. Google found the average savings around 25-34%, still a sizable improvement.</p><h2>The “Accept” Header Has The Goods<b><b>&nbsp;</b></b></h2><p style="display: inline;"> CDN Connect and </p><a title="CDN" href="http://www.maxcdn.com" target="_blank">MaxCDN</a><p style="display: inline;"> collaborated to make using WebP seamless, and it boils down to using the </p><code>Accept</code><p style="display: inline;"> HTTP request header. Every browser request includes details like the software platform, cookies, language settings, and so on. For us, the </p><code>Accept</code><p style="display: inline;"> header is the key: the browser tells the server, “Hey, here are the file types I understand.”</p><b><b>&nbsp;</b></b><p style="display: inline;"> Officially, the HTTP/1.1 protocol solved&nbsp;</p><a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec12.html" target="_blank">server-driven content negotiation</a><p style="display: inline;">&nbsp;years ago (fancy jargon, I know). But until recently, the </p><code>Accept</code><p style="display: inline;"> header has been overlooked by most browsers. </p><a href="http://twitter.com/igrigorik" target="_blank">Ilya Grigorik</a><p style="display: inline;">, developer advocate on the </p><em><a href="https://developers.google.com/speed/" target="_blank">Make The Web Faster</a></em><p style="display: inline;"> team at Google, summarized the </p><code>Accept</code><p style="display: inline;"> headers </p><a href="http://www.igvita.com/2012/12/18/deploying-new-image-formats-on-the-web/">sent by various browsers</a><p style="display: inline;">:</p><div><table><thead><tr><th>Browser</th><th>Accept Header Values</th></tr></thead><tbody><tr><td>Chrome</td><td>*/*</td></tr><tr><td>Safari</td><td>*/*</td></tr><tr><td>Firefox</td><td>image/png,image/*;q=0.8,*/*;q=0.5</td></tr><tr><td>Internet Explorer</td><td>image/png,image/svg+xml,image/*;q=0.8, */*;q=0.5</td></tr><tr><td>Opera</td><td>text/html, application/xml;q=0.9, application/xhtml+xml, image/png, image/webp, image/jpeg, image/gif, image/x-xbitmap, */*;q=0.1</td></tr></tbody></table></div><p style="display: inline;"> Opera is the only browser that can both view WebP images and officially accepts the&nbsp;</p><code>image/webp</code><p style="display: inline;"> content type.&nbsp;Chrome can view WebP, but at the time of this writing, doesn’t specify it in the header.
The good news is that according to&nbsp;</p><a href="https://code.google.com/p/chromium/issues/detail?id=169182" target="_blank">this Chromium bug</a><p style="display: inline;">,&nbsp;</p><code>image/webp</code><p style="display: inline;">&nbsp;will be added to the </p><code>Accept</code><p style="display: inline;"> header soon (and given the amazing rate of Chrome's development, we're not worried about waiting long). The Firefox </p><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=856375" target="_blank">bug for WebP support</a><p style="display: inline;">&nbsp;includes the suggestion “it would he helpful if your changes also included modifying the </p><code>Accept</code><p style="display: inline;"> header for image and HTML requests”. Because Firefox made a similar change when supporting PNG (adding&nbsp;</p><code>image/png</code><p style="display: inline;">&nbsp;to the accept header), we imagine the same will happen for </p><code>image/webp</code><p style="display: inline;">. In summary, </p><a href="http://arstechnica.com/business/2011/04/opera-1110-gets-webp-support-faster-turbo-mode/" target="_blank">Opera supports WebP</a><p style="display: inline;"> today, </p><a href="https://code.google.com/p/chromium/issues/detail?id=169182" target="_blank">Chrome will implement</a><p style="display: inline;"> the Accept&nbsp;header soon, and&nbsp;</p><a href="http://news.cnet.com/8301-1023_3-57578408-93/mozilla-takes-a-fresh-look-at-googles-webp-image-format/">Mozilla is taking a closer look</a><p style="display: inline;">.</p><h2>Server-side Content Negotiation In Action</h2><p style="display: inline;"> Let's load images with Opera, which supports WebP, and see the request and response headers (screenshot below). Even though the request for&nbsp;"MaxCDN-WebP.png" includes &nbsp;</p><code>image/png</code><p style="display: inline;">&nbsp;in the </p><code>Accept</code><p style="display: inline;"> header, the content-type of the response is still </p><code>image/webp</code><p style="display: inline;">. Even though every browser requests the same url (the ".png"), the server decided the WebP format was the best one to send back. Remember, a filename is just a name: the content-type determines what sort of file it is.</p><div id="attachment_2463"><img alt="opera-dragon-fly-webp" src="http://blog.maxcdn.com/blog-assets/opera-dragon-fly-webp.png" width="678" height="320" /><p>Opera Dragonfly: Request and Response</p></div><strong>Nginx Log (11kb transferred):</strong><span>"GET /maxcdn/MaxCDN-WebP.png HTTP/1.1" 200&nbsp;<strong>11581</strong>&nbsp;HIT - "Opera/9.80 (Macintosh; Intel Mac OS X 10.8.3) Presto/2.12.388 Version/12.15"</span><p style="display: inline;"> Now let's try Firefox. Notice that </p><code>image/webp</code><p style="display: inline;"> is missing from the </p><code>Accept</code><p style="display: inline;"> header, and the server responds with the default image encoding (PNG). Any browser without declared WebP support will get the PNG version.&nbsp;Additionally, notice the file was correctly cached by Nginx (</p><code>X-Cache: HIT</code><p style="display: inline;">).</p><div id="attachment_2464"><img alt="Firefox ..." src="http://blog.maxcdn.com/blog-assets/firefox-firebug-webp.png" width="566" height="311" /><p>Firefox Firebug: Request and Response</p></div><strong>Nginx Log (52kb transferred):</strong><span>"GET /maxcdn/MaxCDN-WebP.png HTTP/1.1" 200 <strong>52779</strong> HIT - "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.8; rv:19.0) Gecko/20100101 Firefox/19.0"</span><h2>Caching on the Edge</h2><p style="display: inline;"> MaxCDN has a worldwide network of Nginx servers, but it can be tricky to cache different content types at the same URL as we did above (both image versions showed X-Cache: HIT). If done incorrectly, a cached WebP image could be sent to a browser that doesn't support it.</p><b><b> </b></b><p style="display: inline;"> We worked with Google's </p><a href="https://developers.google.com/speed/"><em>Make The Web Faster</em></a><p style="display: inline;">&nbsp;team and quickly found a solution. Similar to how the </p><a href="http://blog.netdna.com/opensource/bootstrapcdn/accept-encoding-its-vary-important/">Accept-Encoding</a><p style="display: inline;"> header informs the server whether the browser can handle GZIP compression, we'll use the </p><code>Accept</code><p style="display: inline;"> header to distinguish the image formats internally.
Here's how MaxCDN configured Nginx to cache images:</p><div id="crayon-536dab0bc2b1d641004038" data-settings=" minimize scroll-mouseover"><p><textarea wrap="off" data-settings="dblclick" readonly="">
server {
   listen 80;
   server_name ei8gd7lwnymbl2d.cdnconnect.netdna-cdn.com jdorfman.cdnconnect.com;
   set $webp "";
   if ($http_accept ~* image/webp) {
           set $webp "webp";
   }
   location ~ /purge(/.*) {
           allow 192.168.0.1/24;
           deny all;
           proxy_cache_purge my_diskcached ei8gd7lwnymbl2d.cdnconnect10$myae$webp$1$is_args$args;
   }
   location / {
     [clipped]
	   proxy_cache_key ei8gd7lwnymbl2d.cdnconnect10$myae$webp$uri$is_args$args;
   }
}</textarea></p><div><table><tr><td data-settings="show"><div><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p></div></td><td><div><p><span>server</span><span> </span><span>{</span></p><p><span>&nbsp;&nbsp; listen</span><span> </span><span>80</span><span>;</span></p><p><span>&nbsp;&nbsp; server_name</span><span> </span><span>ei8gd7lwnymbl2d</span><span>.</span><span>cdnconnect</span><span>.</span><span>netdna-cdn</span><span>.</span><span>com</span><span> </span><span>jdorfman</span><span>.</span><span>cdnconnect</span><span>.</span><span>com</span><span>;</span></p><p><span>&nbsp;&nbsp; set</span><span> </span><span>$webp</span><span> </span><span>""</span><span>;</span></p><p><span>&nbsp;&nbsp; if</span><span> </span><span>(</span><span>$http_accept</span><span> </span><span>~</span><span>*</span><span> </span><span>image</span><span>/</span><span>webp</span><span>)</span><span> </span><span>{</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set</span><span> </span><span>$webp</span><span> </span><span>"webp"</span><span>;</span></p><p><span>&nbsp;&nbsp; </span><span>}</span></p><p><span>&nbsp;&nbsp; location</span><span> </span><span>~</span><span> </span><span>/</span><span>purge</span><span>(</span><span>/</span><span>.</span><span>*</span><span>)</span><span> </span><span>{</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; allow</span><span> </span><span>192.168.0.1</span><span>/</span><span>24</span><span>;</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; deny</span><span> </span><span>all</span><span>;</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; proxy_cache_purge</span><span> </span><span>my_diskcached</span><span> </span><span>ei8gd7lwnymbl2d</span><span>.</span><span>cdnconnect10</span><span>$myae</span><span>$webp</span><span>$1</span><span>$is_args</span><span>$args</span><span>;</span></p><p><span>&nbsp;&nbsp; </span><span>}</span></p><p><span>&nbsp;&nbsp; location</span><span> </span><span>/</span><span> </span><span>{</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp; </span><span>[clipped]</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; proxy_cache_key</span><span> </span><span>ei8gd7lwnymbl2d</span><span>.</span><span>cdnconnect10</span><span>$myae</span><span>$webp</span><span>$uri</span><span>$is_args</span><span>$args</span><span>;</span></p><p><span>&nbsp;&nbsp; </span><span>}</span></p><p><span>}</span></p></div></td></tr></table></div></div><p style="display: inline;">Notice how the "</p><code>$webp</code><p style="display: inline;">" variable gives us different cache keys for the various versions.
Previously, similar content negotiation required a giant database of User-Agent strings to determine browser capabilities (which, as you can imagine, needs constant maintenance for new devices and browsers). And server-driven content negotiation often results in the fragmentation of cached data, or constant image processing. But with </p><a title="CDN" href="http://www.maxcdn.com/why/network/" target="_blank">MaxCDN's network</a><p style="display: inline;">, you can take advantage of powerful, globally-available caching methods available today.</p><h2>Opt-In for the Win Win</h2><p style="display: inline;"> Modern browsers with the </p><code>Accept</code><p style="display: inline;"> header let origin servers optimize image delivery. With server-side content negotiation, your entire organization gets awesome benefits:</p><ul><li>Graphic designers do not have to change workflows or manually resave files as WebP</li><li>Web designers do not have to update any HTML or CSS</li><li>Web developers do not need hacks to manually check for WebP support</li><li>Existing caching mechanisms can be used</li><li>Outbound bandwidth cost will be lowered</li><li>Visitors will experience your site with better load times</li></ul><p style="display: inline;"> Want to try WebP? </p><a href="http://www.cdnconnect.com" target="_blank">CDN Connect</a><p style="display: inline;">&nbsp;will dynamically convert images to WebP without any code changes, providing the benefits above. For customers who opt-in to this feature, all configuration happens automatically.
CDN Connect removes the burden of image resizing, content-aware cropping, image optimisation and file format conversion, all while hosting files from a fast, worldwide content delivery network built for a team environment.&nbsp;Start using WebP today!</p></div></div>
<script>var _gaq = _gaq || []; _gaq.push(['_setAccount', 'UA-34802167-1']); _gaq.push(['_setDomainName', 'liuzhe.co']); _gaq.push(['_trackPageview']); (function() { var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true; ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'; var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s); })();</script></body>
</html>