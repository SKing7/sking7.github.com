<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Client-Side Security Best Practices | Nettuts+</title>
<link rel="stylesheet" href="../css/article.css" />
</head>
<body>
<div class="m-content">
<h1>Client-Side Security Best Practices | Nettuts+</h1>
<div><p>Thanks to HTML5, more and more of an applications’ logic is transferred from server-side to client-side. This requires front-end developers to focus more on security. In this article I will show you how to make your apps more secure. I will focus on techniques that you may not have heard about, instead of just telling you that you have to escape HTML data entered in by users.</p><hr /><h2>Don’t Even Think About HTTP</h2><p>Of course I don’t want you to serve your content with FTP or plain TCP. What I mean is that if you want your users to be safe when using your website, you need to use SSL (HTTPS). And not only for login sites, or valuable information. For all of your content. Otherwise, when someone is accessing your app from a public network, what they see may be malformed by some hacker inside this network. This is called a main-in-the-middle attack:</p><figure> <img src="http://cdn.tutsplus.com/net/uploads/2013/11/main-in-the-middle.png" alt="main-in-the-middle" width="600" height="500" /><br /></figure><p>When you use SSL, all of the data is encrypted before it’s sent, so even if the attacker gets it, he would not be able to modify or capture it. This is by far the most important step in securing your app.</p><h3>Strict Transport Security</h3><p>This HTTP header can come in handy if you want to serve your content using only SSL. When it’s issued by the server (or a <code>&lt;meta&gt;</code> tag, but that will allow at least one request to be HTTP), no insecure traffic will come from the browser to your server. It is used like this:</p><pre title="">Strict-Transport-Security: max-age=3600; includeSubDomains</pre><p>The <code>includeSubDomains</code> part is optional, it allows you to declare that you also want all of the sub-domains to be accessed using HTTPS. The <code>max-age</code> option sets how long (in seconds) the pages should be served using SSL. Sadly, only Firefox, Chrome and Opera are supporting Strict Transport Security.</p><h3>Secure and HttpOnly</h3><p>Another way to further improve the security on both HTTP and HTTPS are these two cookie attributes: <code>Secure</code> and <code>HttpOnly</code>. The first one allows a cookie to be sent only on SLL connection. The second one may sound as the exact opposite, but it’s not. It’s telling the browser that the cookie can only be accessed using HTTP(S) protocol, so it cannot be stolen using, for example, JavaScript’s <code>document.cookie</code>.</p><hr /><h2>Make XSS Less Harmful With Content Security Policy</h2><blockquote><p> Content Security Policy allows you to define the origin of all scripts, images etc. on your site.</p></blockquote><p>If you think your XSS filter will stop all possible XSS attacks check <a href="https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet" onclick="javascript:_gaq.push(['_trackEvent','outbound-article','www.owasp.org']);">how many ways there are to perform these attacks</a> and think again. Of course securing your app to stop all of these may be a problem and may slow it down, but there is a solution.</p><p>It’s called Content Security Policy. It allows you to define the origin of all scripts, images etc. on your site. It also blocks all inline scripts and styles, so even if someone can inject a script tag into a comment or post, the code would not be executed. The CSP is an HTTP header (which can also be set using HTML <code>&lt;meta&gt;</code> tag), which looks like this:</p><pre title="">
Content-Security-Policy: policy
</pre><p>Where <code>policy</code> is a set of CSP directives. Here are the possible options:</p><ul><li><b>script-src</b> – sets acceptable sources of JavaScript code</li><li><b>style-src</b> – defines acceptable origins of CSS styles</li><li><b>connect-src</b> – specifies the servers the browser can connect to using XHR, WebSockets and EventSource</li><li><b>font-src</b> – lists allowed sources of fonts</li><li><b>frame-src</b> – defines what origins should be allowed in iframes</li><li><b>img-src</b> – sets allowed image sources</li><li><b>media-src</b> – lists origins that can serve video and audio files</li><li><b>object-src</b> – same as above but for Flash and other plugins</li></ul><p>If a directive is not set, the browser assumes that all origins are allowed. This can be changed by setting the <code>default-src</code> option. What you set there will be applied to all unset directives. There is also a <code>sandbox</code> option, which makes the webpage load as an iframe with the <code>sandbox</code> attribute. An example usage of the CSP header would look like this:</p><pre title="">
Content-Security-Policy: default-src: 'self'; script-src: https://apis.google.com;
</pre><p>It allows all of the assets to be loaded only from the application’s origin (the <code>'self'</code> attribute) and also allows you to load scripts from the Google APIs server. There is a lot of flexibility when defining CSP, and when used properly it will greatly improve the security of your webpage.</p><h3>Drawbacks</h3><p>The thing to remember when using CSP is that, by default, all inline JavaScript will not be executed. This also includes:</p><ul><li><b>inline event listeners</b>: like <code>&lt;body onload="main();"&gt;</code></li><li><b>all <code>javascript</code> URLs</b>: like <code>&lt;a href="javascript:doTheClick()"&gt;</code></li></ul><p>This is because the browser cannot distinguish your inline code from the hacker’s inline code. You will have to replace them by adding event listeners with <code>addEventListener</code> or some framework’s equivalent. This is not a bad thing ultimately, as it forces you to separate your application’s logic from its graphical representation which you should be doing anyway. CSP also (by default) blocks all <code>eval()</code>-ish code, including strings in <code>setInterval</code>/<code>setTimeout</code> and code like <code>new Function('return false')</code>.</p><h3>Availability</h3><p>CSP is available in most of the modern browsers. Firefox, Chrome and Opera (mobile too) use the standard <code>Content-Security-Policy</code> header. Safari (iOS too) and Chrome for Android use the <code>X-WebKit-CSP</code> header. IE10 (with support limited only to the <code>sandbox</code> directive) uses <code>X-Content-Security-Policy</code>. So, thanks to Internet Explorer, you can’t just use only CSP (unless you will use something like Google Chrome Frame), but you can still use it to improve the security on the real browsers and to prepare your app for the future.</p><hr /><h2>Use Cross Origin Resource Sharing Instead of JSONP</h2><p>JSONP is currently the most used technique to get resources from other servers despite the same-origin policy. Usually, you just create the callback function in your code and pass the name of that function to the URL from which you want to get the data, like this:</p><pre title="">
function parseData(data) {
	...
}
</pre><pre title="">
&lt;script src="http://someserver.com/data?format=jsonp&amp;callback=parseData"&gt;&lt;/script&gt;
</pre><p>But by doing this, you are creating a big security risk. If the server that you are getting data from is compromised, a hacker can add his malicious code and for example, steal your user’s private data, because actually, you are getting JavaScript using this request – and the browser will run all of the code just like with a normal script file.</p><p>The solution here is Cross Origin Resource Sharing. It allows your data provider to add a special header in responses so that you can use XHR to retrieve that data, then parse and verify it. This removes the risk of getting malicious code executed on your site.</p><p>The implementation requires the provider only to add the following special header in responses:</p><pre title="">
Access-Control-Allow-Origin: allowed origins
</pre><p>This can be just a few allowed origins separated with spaces, or a wildcard character: <code>*</code> to let every origin request the data.</p><h3>Availability</h3><p>All current versions of modern browsers support CORS, with the exception of Opera Mini.</p><p>Of course, the bigger problem here is that service providers would have to add CORS support, so it’s not completely dependent on the developer.</p><hr /><h2>Sandbox Potentially Harmful Iframes</h2><blockquote><p> An iframe with the <code>sandbox</code> attribute will not be able to navigate the window, execute scripts, lock the pointer, show pop-ups or submit forms.</p></blockquote><p>If you are using iframes to load content from external sites, you may want to secure them too. This can be done using the <code>sandbox</code> iframe attribute. An iframe with such an attribute empty (but present) will not be allowed to navigate the window, execute scripts, lock the pointer, show pop-ups or submit forms. The frame will also have a  unique origin, so it can’t use <code>localStorage</code> or anything related to the same-origin policy. You can of course allow some of them, if you want, by adding one or more of these values into the attribute:</p><ul><li><b>allow-same-origin</b> – the frame will have the same origin as the site, instead of the unique one</li><li><b>allow-scripts</b> – the frame will be allowed to execute JavaScript</li><li><b>allow-forms</b> – the frame will be able to submit forms</li><li><b>allow-pointer-lock</b> – the frame will have access to the Pointer Lock API</li><li><b>allow-popups</b> – the frame will be allowed to show pop-ups</li><li><b>allow-top-navigation</b> – the frame will be able to navigate the window</li></ul><h3>Availability</h3><p>The <code>sandbox</code> iframe attribute is supported in all modern browsers, with the exception of Opera Mini.</p><hr /><h2>Conclusion</h2><p>So that’s it. I hope you’ve learned some new techniques that you can use in your future projects to protect your applications. Thanks to HTML5, we can now do amazing things with our websites, but we have to think about security from the first line of code if we want them to be resistant against attacks.</p></div></div>
<script>var _gaq = _gaq || []; _gaq.push(['_setAccount', 'UA-34802167-1']); _gaq.push(['_setDomainName', 'liuzhe.co']); _gaq.push(['_trackPageview']); (function() { var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true; ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'; var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s); })();</script></body>
</html>