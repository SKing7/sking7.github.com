<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>JavaScript Performance | High Performance Web Sites</title>
</head>
<body>
<div id="post-2375"><p>January 13, 2012 10:09 pm | <a href="http://www.stevesouders.com/blog/2012/01/13/javascript-performance/#comments" title="Comment on JavaScript Performance">20 Comments</a></p><!-- .entry-meta --><p>Last night I spoke at the <a href="http://www.meetup.com/jsmeetup/events/38563112/">San Francisco JavaScript Meetup</a>. I gave a brand new talk called <a href="http://www.slideshare.net/souders/javascript-performance-at-sfjs">JavaScript Performance</a> that focuses on script loading and async snippets. The snippet example I chose was the <a href="http://code.google.com/apis/analytics/docs/tracking/asyncTracking.html">Google Analytics async snippet</a>. The script-loading part of that snippet is only six lines, but a lot of thought and testing went into it. It’s a great prototype to use if you’re creating your own async snippet. I’ll tweet if/when the video of my talk comes out, but in the meantime the slides (<a href="http://www.slideshare.net/souders/javascript-performance-at-sfjs">Slideshare</a>, <a href="http://stevesouders.com/docs/sfjs-20120112.pptx">pptx</a>) do a good job of relaying the information.</p><p>There are two new data points from the presentation that I want to call out in this blog post.</p><h2>Impact of JavaScript</h2><p>The presentation starts by suggesting that JavaScript is typically the #1 place to look for making a website faster. My anecdotal experience supports this hypothesis, but I wanted to try to do some quantitative verification. As often happens, I turned to <a href="http://webpagetest.org/">WebPagetest</a>.</p><p>I wanted to test the Alexa Top 100 URLs with and without JavaScript. To load these sites withOUT JavaScript I used WebPagetest’s “block” feature. I entered “.js” which tells WebPagetest to ignore every HTTP request with a URL that contains that string. Each website was loaded three times and the median page load time was recorded. I then found the median of all these median page load times.</p><p>The median page load <em>with JavaScript</em> is 3.65 seconds. <em>Without JavaScript</em> the page load time drops to 2.487 seconds – a 31% decrease. (Here’s the data in WebPagetest: <a title="with JavaScript" href="http://www.webpagetest.org/result/120111_GR_2TW90/">with JavaScript</a>, <a title="without JavaScript" href="http://www.webpagetest.org/result/120111_0P_2TW4Q/">without JavaScript</a>.) It’s not a perfect analysis: Some script URLs don’t contain “.js” and inline script blocks are still executed. I think this is a good approximation and I hope to do further experiments to corroborate this finding.</p><p><center><img title="Top 100 sites with and without JS" src="http://stevesouders.com/images/withoutjs.png" alt="" width="460" height="291" /></center></p><h2>Async Execution Order &amp; Onload</h2><p>The other new infobyte has to do with the <code>async=true</code> line from the GA async snippet. The purpose of this line is to cause the <code>ga.js</code>&nbsp;script to not block other async scripts from being executed. It turns out that some browsers preserve the execution order of scripts loaded using the insertBefore technique, which is the technique used in the GA snippet:</p><p>var ga = document.createElement(‘script’);<br />ga.type = ‘text/javascript’;<br />ga.async = true;<br />ga.src = (‘https:’ == document.location.protocol ? ‘https://ssl’ : ‘http://www’) + ‘.google-analytics.com/ga.js’;<br />var s = document.getElementsByTagName(‘script’)[0];<br />s.parentNode.insertBefore(ga, s);</p><p>Preserving execution order of async scripts makes the page slower. If the first async script takes a long time to download, all the other async scripts are blocked from executing, even if they download sooner. Executing async scripts immediately as they’re downloaded results in a faster page load time. I knew old versions of Firefox had this issue, and setting <code>async=true</code> fixed the problem. But I wanted to see if any other browsers also preserved execution order of async scripts loaded this way, and whether setting <code>async=true</code> worked.</p><p>To answer these questions I created a <a href="http://www.browserscope.org/user/tests/howto">Browserscope user test</a> called <a href="http://stevesouders.com/tests/jsorder.php">Async Script Execution Order</a>. I tweeted the test URL and got 348 results from 60+ different browsers. (Thanks to all the people that ran the test! I still need results from more mobile browsers so please run <a href="http://stevesouders.com/tests/jsorder.php">the test</a> if you have a browser that’s not covered.) Here’s a snapshot of <a href="http://www.browserscope.org/user/tests/table/agt1YS1wcm9maWxlcnINCxIEVGVzdBjrq90MDA?v=3&amp;layout=simple&amp;highlight=1">the results</a>:</p><p>The second column shows the results of loading two async scripts with the insertBefore pattern AND setting <code>async=true</code>. The third column shows the results if <code>async</code> is NOT set to <code>true</code>. Green means the scripts execute immediately (good) and red indicates that execution order is preserved (bad).</p><p>The results show that Firefox 3.6, OmniWeb 622, and all versions of Opera preserve execution order. Setting <code>async=true</code> successfully makes the async scripts execute immediately in Firefox 3.6 and OmniWeb 622, but not in Opera. Although this fix only applies to a few browsers, its small cost makes it worthwhile. Also, if we get results for more mobile browsers I would expect to find a few more places where the fix is necessary.</p><p>I also tested whether these insertBefore-style async scripts block the onload event. The results, shown in the fourth column, are mixed if we include older browsers, but we see that newer browsers generally block the onload event when loading these async scripts – this is true in Android, Chrome, Firefox, iOS, Opera, Safari, and IE 10. This is useful to know if you wonder why you’re still seeing long page load times even after adopting async script loading. It also means that code in your onload handler can’t reliably assume async scripts are loaded because of the many browsers out there that do <em>not</em> block the onload event, including IE 6-9.</p><p>And a final shout out to the awesomeness of the Open Source community that makes tools like <a href="http://webpagetest.org/">WebPagetest</a> and <a href="http://www.browserscope.org/">Browserscope</a> available – thanks <a href="https://twitter.com/#!/patmeenan">Pat</a> and <a href="https://twitter.com/#!/elsigh">Lindsey</a>!</p></div></body>
</html>