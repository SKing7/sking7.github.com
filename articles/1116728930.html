
        <!doctype html>
        <html>
        <head>
            <meta charset="utf-8"/>
            <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
            <title>Forgo JS packaging? Not so fast</title>
            <link rel="stylesheet" href="../css/article.css" />;
        </head>
        <body>
            <div class="m-content">
                <h1>Forgo JS packaging? Not so fast</h1>
                <div class="section" id="bundling-javascript-files"><span> </span><h2>Bundling JavaScript files</h2><span> </span><p>The traditional advice for web developers is to bundle the JavaScript files used by their webpages into one or (at most) a few "packages." Multiple tools have been developed to do this, such as <a class="reference external" href="http://browserify.org/">Browserify</a> and <a class="reference external" href="http://webpack.github.io/docs/motivation.html">Webpack</a>. They tend to work like this: for a given HTML page, you write a single JavaScript source file that provides all the JS logic needed for that page. You then use a bundler to create a package that includes that JavaScript source file plus all its dependencies; that package is then served via a single HTTP request.</p><span> </span><p>The opposite of bundling is to just serve all those JavaScript source files separately: your HTML page has a <tt class="docutils literal">&lt;script&gt;</tt> tag for your "main" JS source file, but before that it has <tt class="docutils literal">&lt;script&gt;</tt> tags for each of its dependencies as well.</p><span> </span><p>There is also a middle ground -- this is what Khan Academy does -- of bundling together JavaScript source files into packages, but into a small number of semantically related packages, rather than a single package per HTML page.</p><span> </span><p>There are reasons in favor of each of these approches:</p><span> </span><table border="1" class="docutils"> <colgroup> <col width="29%"> <col width="35%"> <col width="35%"> </colgroup> <thead valign="bottom"> <tr><th class="head">Approach</th> <th class="head">Pros</th> <th class="head">Cons</th> </tr> </thead> <tbody valign="top"> <tr><td>Package per page</td> <td><ul class="first last simple"> <li>No unused files</li> <li>Only 1 HTTP request</li> </ul> </td> <td> </td> </tr> <tr><td>Separate JS files</td> <td><ul class="first last simple"> <li>No unused files</li> <li>Optimal caching</li> </ul> </td> <td><ul class="first last simple"> <li>Many HTTP requests</li> <li>Limited parallelism</li> </ul> </td> </tr> <tr><td>Hybrid</td> <td><ul class="first last simple"> <li>Few HTTP requests</li> <li>OK caching</li> </ul> </td> <td><ul class="first last simple"> <li>Some unused files</li> <li>OK caching</li> </ul> </td> </tr> </tbody> </table><span> </span><p>Basically, the package-per-page approach gives up cacheability in favor of minimizing HTTP requests: if you visit a second page on the same website, you'll have to download a whole new JavaScript package, even though it includes many of the same dependencies as the old page. If it sticks in your craw that your users have to re-download jQuery every time they click on a new page on your site, per-page packages are not for you.</p><span> </span><p>But if you don't do any packaging at all, while cacheability is excellent, your HTTP performance goes down the tubes; if your page requires dozens of JavaScript source files, you have to download each separately, paying HTTP (plus maybe SSL) overhead each time. Plus, most browsers limit the number of simultaneous fetches they'll do, meaning these downloads can't even all happen in parallel. This ends up being very slow.</p><span> </span><p>Khan Academy uses a hybrid approach: we combine JavaScript source files into packages, but we do so based on what files are used together. So we have one package that has JavaScript specific to video pages, and another specific to our CS content, and another specific to internationalization, and so forth. A given HTML page will need several such packages, and often will need only some of the source files in each package. On a given page, you waste time downloading extra bytes for unused JavaScript source files, but hopefully save time due to some packages being cached in the browser.</p><span> </span></div><div class="section" id="http-2-0-changes-the-calculus-or-does-it"><span> </span><h2>HTTP/2.0 changes the calculus...or does it?</h2><span> </span><p>HTTP/2.0 (and its predecessor SPDY) changes all the considerations here. HTTP/2.0 has advanced flow control techniques like multiplexing. This means that you can use a single connection to download dozens of JavaScript files, and download them all in parallel. Suddenly the "cons" column of the "separate JS files" approach empties out.</p><span> </span><p>As more and more browsers support HTTP/2.0 (<a class="reference external" href="http://caniuse.com/#search=http2">over 60%</a> of all browsers worldwide), you'd expect there to be a groundswell of support for leaving JavaScript packaging behind and moving to just serving JavaScript source files directly. And indeed, there is a <a class="reference external" href="http://chimera.labs.oreilly.com/books/1230000000545/ch13.html#OPTIMIZING_HTTP2">mini-groundswell</a>, at least.</p><span> </span><p>Khan Academy spent several months rearchitecting its system to move from a package-based scheme to one that just served JavaScript source files directly, at least for clients that support HTTP/2.0. And here's what we found:</p><span> </span><p>Performance got worse.</p><span> </span><p>On investigation we found out there were two reasons for this:</p><span> </span><ol class="arabic simple"> <li>We were serving more bytes due to reduced compression quality</li> <li>The server had unexplained delays serving dozens of JS files</li> </ol><span> </span><p>The sections below explore these issues in more detail.</p><span> </span><p>Our conclusion is it is premature to give up on bundling JavaScript files at this time, even for HTTP/2.0 clients. In particular, bundling into packages will continue to perform better than serving individual JavaScript source files until HTTP/2 has a better story around compression.</p><span> </span><div class="section" id="bundling-improves-compression"><span> </span><h3>Bundling improves compression</h3><span> </span><p>All modern servers and browsers compress (most) data being sent over the wire, typically using the zlib DEFLATE algorithm (colloquially, "zlib"). This results in major time savings: for one Khan Academy HTML page, the associated JavaScript content is 2,421,176 bytes uncompressed, but only (!) 646,806 bytes compressed, or about a quarter the size.</p><span> </span><p>When we changed that page to download JavaScript source files individually rather than as packages, the uncompressed size went down to 2,282,839 bytes (a nice 5% savings). This is because we could omit JavaScript files that were not actually needed on this page, but were included in one of the required packages regardless. But the compressed size went <em>up</em>, to 662,754 bytes!</p><span> </span><table border="1" class="docutils"> <colgroup> <col width="30%"> <col width="23%"> <col width="25%"> <col width="22%"> </colgroup> <thead valign="bottom"> <tr><th class="head">Size</th> <th class="head">Packages</th> <th class="head">Individual files</th> <th class="head">Pct difference</th> </tr> </thead> <tbody valign="top"> <tr><td>uncompressed JS</td> <td>2,421,176 bytes</td> <td>2,282,839 bytes</td> <td>-5.7%</td> </tr> <tr><td>compressed JS</td> <td>646,806 bytes</td> <td>662,754 bytes</td> <td><span class="red">+2.5%</span></td> </tr> <tr><td>number of files</td> <td>28 files</td> <td>296 files</td> <td>(+921%)</td> </tr> </tbody> </table><span> </span><p>On reflection, this is no surprise: due to how zlib operates, using a <a class="reference external" href="http://www.cs.helsinki.fi/u/tpkarkka/opetus/12k/dct/lecture07.pdf">sliding window</a> of previous text to guide its compression, it does much better on big files than small ones. In particular, it will always compress 100 1K files worse (in aggregate) than the single 100K file you get by concatenating them all together.</p><span> </span><p>(More details: at a high level, zlib compresses like this: it goes through a document, and for every sequence of text it's looking at, it sees if that text had occurred previously in the document. If so, it replaces that sequence of text by a (space-efficient) pointer to that previous occurrence. It stands to reason that the further along in the document it goes, the more "previous text" there is for finding a potential match and thus an opportunity for compression.</p><span> </span><p>This discussion omits some details, like the limited size of the sliding window, that do not affect the overall conclusion. For more details on zlib, and the LZ77 algorithm it implements, see <a class="reference external" href="https://en.wikipedia.org/wiki/LZ77_and_LZ78">Wikipedia</a>.)</p><span> </span><p>zlib actually has a mechanism built in for improving compression in the case of many small files: you can specify a <a class="reference external" href="https://blog.cloudflare.com/improving-compression-with-preset-deflate-dictionary/">"preset dictionary"</a>, which is just a big string of bytes. Basically, when compressing with a preset dictionary, you can replace text either with a pointer to earlier in the document, <em>or</em> into the preset dictionary. With a preset dictionary, early parts of the document have more opportunities to find a good pointer match.</p><span> </span><p>HTTP/2 actually takes advantage of this feature by <a class="reference external" href="https://www.eecis.udel.edu/~amer/PEL/poc/pdf/SPDY-Fan.pdf">hard-coding a preset dictionary</a> that servers and browsers must use when talking HTTP/2. Unfortunately for us, that preset dictionary has text related to HTTP headers, and is useless at improving the compression quality of JavaScript files.</p><span> </span><p>Preset dictionaries are hard to use as part of HTTP because both the server and client must agree on the contents of the preset dictionary or the data will get corrupted. HTTP/2 solves this problem by hard-coding a single value in both places. For our application, though, of improving compression of many JavaScript files, there would have to be some way for the server to communicate the preset dictionary to the client.</p><span> </span><p>This takes time, of course, and really only works well if it's supported at the protocol layer. That said, for cases like this it would be a significant net win overall. But it likely wouldn't be easy to augment the HTTP/2 spec to allow for something like this in a safe way!</p><span> </span></div><span> </span><div class="section" id="http-2-0-has-service-issues"><span> </span><h3>HTTP/2.0 has service issues</h3><span> </span><p>In addition to increasing bandwidth, moving away from packages increased latency due to sub-optimal behavior of our webserver when serving hundreds of JavaScript source files. Our analysis of this behavior was not entirely satisfactory, since we do not control our webserver (we use Google App Engine).</p><span> </span><p>However, by analyzing <a class="reference external" href="https://www.maxcdn.com/one/visual-glossary/har-file/">HAR files</a> we could see the effect plainly:</p><span> </span><a class="reference external image-reference" href="http://engineering.khanacademy.org/images/js-packaging-http2/static-perfile-waterfall-gae.png"><img alt="HAR-file waterfall when downloading JS as individual files" src="http://engineering.khanacademy.org/images/js-packaging-http2/static-perfile-waterfall-gae.png"></a><span> </span><p>Not all the JavaScript files are requested at the same time, there's a small gap between requesting each one. About halfway down the image (you can click on it to see this more clearly), there is a large gap. Those files also require over a second to download, though it's difficult to tell exactly what's going on due to HTTP/2 multiplexing. But clearly something is not as efficient as it could be.</p><span> </span><p>These tests were done on a recent Chrome browser. It's possible other browsers would have different effects. And the test was emulating a super-fast FiOS connection; you can see that all the time is taken in the green part of the bars (time to first byte) and not the blue part (time to download the full file).</p><span> </span><p>Furthermore, reloading the page gave HAR files looking substantially different each time. But the end result was the same: a page that had much more latency than when using packages.</p><span> </span><p>When we stuck with a relatively small number of packages, the waterfall was consistent and reliable (and much shorter!):</p><span> </span><a class="reference external image-reference" href="http://engineering.khanacademy.org/images/js-packaging-http2/static-manual-waterfall-gae.png"><img alt="HAR-file waterfall for downloading JS as packages" src="http://engineering.khanacademy.org/images/js-packaging-http2/static-manual-waterfall-gae.png"></a><span> </span><p>The time-to-first byte is still longer than we would like, for reasons we are not entirely sure of, but it's much more consistent than in the individual-source-file case!</p><span> </span><p>(If you are curious, entry #7, with the longest blue bar, is for our 'core' JavaScript package which includes jQuery, React, and a few other large, rarely-changing libraries. For our test, we disabled the browser cache, but our hope is most of our users will need to download that package only once, getting the contents from their browser cache after that.)</p><span> </span></div><span> </span></div><div class="section" id="it-s-all-about-the-bytes"><span> </span><h2>It's all about the bytes</h2><span> </span><p>It may not have escaped your notice that 662,754 bytes is a lot of bytes for JavaScript for a single HTML page, and 296 files is a lot of files. "What are you doing on that page?" you may well be wondering.</p><span> </span><p>We are wondering that too. The page in question is the Khan Academy homepage for logged in users, and it's acquired a lot of, um, functionality over the years.</p><span> </span><p>The end result of our analysis is that our page isn't going to load any faster until we reduce the amount of JavaScript we use on the page. Tricks like trying to load a bunch of stuff in parallel, or aggressive caching, might seem like appealing shortcuts, but nothing replaces just auditing the code and making it need less "stuff."</p><span> </span></div><div class="section" id="summary"><span> </span><h2>Summary</h2><span> </span><p>HTTP/2.0, with its multiplexing, header compression, and the like, offers the promise of the best of all worlds when it comes to downloading JavaScript: great local caching, great download efficiency, no wasted bytes, and a simpler serving infrastructure to boot. All you have to do is give up your packaging system and download all your JavaScript source files individually.</p><span> </span><p>The reality is not so rosy. Due to degraded compression performance, the size of the data download with individual source files ends up being higher than with packages, despite having achieved 'no wasted bytes'. Likewise, the promised download efficiency has yet to show up in the wild, at least for us. It seems that, for the moment at least, JavaScript packaging is here to stay.</p><span> </span></div>
            </div>
            <script>var _gaq = _gaq || []; _gaq.push(['_setAccount', 'UA-34802167-1']); _gaq.push(['_setDomainName', 'liuzhe.co']); _gaq.push(['_trackPageview']); (function() { var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true; ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'; var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s); })();</script>
        </body>
        </html>