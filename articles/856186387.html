<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Handy Bash feature: Process Substitution</title>
<link rel="stylesheet" href="../css/article.css" />
</head>
<body>
<div class="m-content">
<h1>Handy Bash feature: Process Substitution</h1>
<div class="section-inner layoutSingleColumn"><p name="18c6" id="18c6" class="graf--p graf--first">It was a few years ago I was working with my friend Jordan Samuels, when we wanted to compare two versions of a file at a particular URL. I knew what to do…</p><pre name="c0df" id="c0df" class="graf--pre">$ curl <a href="http://somesite/file1" data-href="http://somesite/file1" class="markup--anchor markup--pre-anchor" rel="nofollow">http://somesite/file1</a> &gt; file1<br />$ curl <a href="http://somesite/file2" data-href="http://somesite/file2" class="markup--anchor markup--pre-anchor" rel="nofollow">http://somesite/file2</a> &gt; file2<br />$ diff file1 file2</pre><p name="610d" id="610d" class="graf--p">Simple right? Download file1, download file2, and diff them. 3 steps.</p><p name="8bf7" id="8bf7" class="graf--p">But before I could type it, Jordan grabbed the keyboard and typed some crazy voodoo I’d never seen before…</p><pre name="48b0" id="48b0" class="graf--pre">$ diff &lt;(curl <a href="http://somesite/file1%29" data-href="http://somesite/file1)" class="markup--anchor markup--pre-anchor" rel="nofollow">http://somesite/file1)</a> &lt;(curl <a href="http://somesite/file2%29" data-href="http://somesite/file2)" class="markup--anchor markup--pre-anchor" rel="nofollow">http://somesite/file2)</a></pre><p name="f7f8" id="f7f8" class="graf--p">Ooooh, what was that weird syntax? And why did it appear to run twice as fast as what I was expecting?</p><h3 name="2b60" id="2b60" class="graf--h3">Process substitution!</h3><p name="e56b" id="e56b" class="graf--p">Process substitution gives you similar capabilities to piping. Except piping only allows you to pipe the output from a single command into another. In the diff scenario, we need to pipe the output from multiple commands into another. And that’s what process substitution allows us to do.</p><p name="07dd" id="07dd" class="graf--p">The syntax for using process substitution is this:</p><pre name="0f21" id="0f21" class="graf--pre">$ some-command <strong class="markup--strong markup--pre-strong">&lt;(</strong>another-command<strong class="markup--strong markup--pre-strong">)</strong></pre><p name="8d79" id="8d79" class="graf--p">Where <strong class="markup--strong markup--p-strong">some-command </strong>accepts a filename (or multiple filenames) as arguments, and <strong class="markup--strong markup--p-strong">another-command</strong> writes output to stdout.</p><p name="4684" id="4684" class="graf--p">Wait a minute… how does that work? There are no filenames anywhere? Well, behind the scenes, when Bash sees the process substitution &lt;(…), it’ll create a temporary file descriptor which it uses as the filename and pipe output from the other process into it.</p><h3 name="e9ae" id="e9ae" class="graf--h3">When to use process substitution</h3><p name="89b9" id="89b9" class="graf--p">If a regular old pipe will do, just do that. But there are a few scenarios when pipes won’t cut it…</p><ul class="postList"><li name="6742" id="6742" class="graf--li">If you need to feed multiple outputs into a single program (like the diff example above)</li><li name="3689" id="3689" class="graf--li">If you need to feed output from a program into a program that expects input files, but cannot read from stdin</li><li name="6c99" id="6c99" class="graf--li">If you find yourself using temporary files</li></ul><h3 name="58be" id="58be" class="graf--h3">Parallelization!</h3><p name="7f08" id="7f08" class="graf--p">Apart from simplicity, another advantage of using process substitution is Bash will <strong class="markup--strong markup--p-strong">automatically parallelize</strong> your tasks. Returning to our first example…</p><pre name="1fe7" id="1fe7" class="graf--pre">$ diff &lt;(curl <a href="http://somesite/file1%29" data-href="http://somesite/file1)" class="markup--anchor markup--pre-anchor" rel="nofollow">http://somesite/file1)</a> &lt;(curl <a href="http://somesite/file2%29" data-href="http://somesite/file2)" class="markup--anchor markup--pre-anchor" rel="nofollow">http://somesite/file2)</a></pre><p name="ece4" id="ece4" class="graf--p">… Bash will run both those curl commands in parallel. Sweet huh?</p><p name="6963" id="6963" class="graf--p">Ok, that’s it. Have a nice day.</p><h3 name="9297" id="9297" class="graf--h3">Diving deeper</h3><p name="8314" id="8314" class="graf--p">If you want to get into the nitty gritty details about how this stuff works, here’s some more reading.</p><p name="1e23" id="1e23" class="graf--p graf--last">Want more tips, rants and possibly kittens? <a href="https://twitter.com/joewalnes" data-href="https://twitter.com/joewalnes" class="markup--anchor markup--p-anchor" rel="nofollow">Follow me on the Twitters</a>.</p></div></div>
<script>var _gaq = _gaq || []; _gaq.push(['_setAccount', 'UA-34802167-1']); _gaq.push(['_setDomainName', 'liuzhe.co']); _gaq.push(['_trackPageview']); (function() { var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true; ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'; var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s); })();</script></body>
</html>