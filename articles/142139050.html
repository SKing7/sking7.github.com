<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>那些优雅的数据结构(1) : BloomFilter——大规模数据处理利器 - 苍梧</title>
<link rel="stylesheet" href="../css/article.css" />
</head>
<body>
<div id="cnblogs_post_body"><p><span><strong>BloomFilter——大规模数据处理利器</strong></span></p><p><span>　　Bloom Filter是由Bloom在1970年提出的一种多哈希函数映射的快速查找算法。通常应用在一些需要快速判断某个元素是否属于集合，但是并不严格要求100%正确的场合。</span></p><p><span><strong>一</strong><strong>. </strong><strong>实例</strong><strong>&nbsp;</strong></span></p><p><span>　　为了说明Bloom Filter存在的重要意义，举一个实例：</span></p><p><span>　　假设要你写一个网络蜘蛛（web crawler）。由于网络间的链接错综复杂，蜘蛛在网络间爬行很可能会形成“环”。为了避免形成“环”，就需要知道蜘蛛已经访问过那些URL。给一个URL，怎样知道蜘蛛是否已经访问过呢？稍微想想，就会有如下几种方案：</span></p><p><span>　　1. 将访问过的URL保存到数据库。</span></p><p><span>　　2. 用HashSet将访问过的URL保存起来。那只需接近O(1)的代价就可以查到一个URL是否被访问过了。</span></p><p><span>　　3. URL经过MD5或SHA-1等单向哈希后再保存到HashSet或数据库。</span></p><p><span>　　4. Bit-Map方法。建立一个BitSet，将每个URL经过一个哈希函数映射到某一位。</span></p><p><span>　　方法1~3都是将访问过的URL完整保存，方法4则只标记URL的一个映射位。</span></p><p><span>　　以上方法在数据量较小的情况下都能完美解决问题，但是当数据量变得非常庞大时问题就来了。</span></p><p><span>　　方法1的缺点：数据量变得非常庞大后关系型数据库查询的效率会变得很低。而且每来一个URL就启动一次数据库查询是不是太小题大做了？</span></p><p><span>　　方法2的缺点：太消耗内存。随着URL的增多，占用的内存会越来越多。就算只有1亿个URL，每个URL只算50个字符，就需要5GB内存。</span></p><p><span>　　方法3：由于字符串经过MD5处理后的信息摘要长度只有128Bit，SHA-1处理后也只有160Bit，因此方法3比方法2节省了好几倍的内存。</span></p><p><span>　　方法4消耗内存是相对较少的，但缺点是单一哈希函数发生冲突的概率太高。还记得数据结构课上学过的Hash表冲突的各种解决方法么？若要降低冲突发生的概率到1%，就要将BitSet的长度设置为URL个数的100倍。</span></p><p><span>　　实质上上面的算法都忽略了一个重要的隐含条件：允许小概率的出错，不一定要100%准确！也就是说少量url实际上没有没网络蜘蛛访问，而将它们错判为已访问的代价是很小的——大不了少抓几个网页呗。&nbsp;</span></p><p><span><span><strong>二</strong><strong>. Bloom Filter</strong><strong>的算法</strong></span><strong>&nbsp;</strong></span></p><p><span>　　废话说到这里，下面引入本篇的主角——Bloom Filter。其实上面方法4的思想已经很接近Bloom Filter了。方法四的致命缺点是冲突概率高，为了降低冲突的概念，Bloom Filter使用了多个哈希函数，而不是一个。</span></p><p><span>&nbsp;&nbsp; 　Bloom Filter算法如下：</span></p><p><span>&nbsp;&nbsp;　&nbsp;创建一个m位BitSet，先将所有位初始化为0，然后选择k个不同的哈希函数。第i个哈希函数对字符串str哈希的结果记为h（i，str），且h（i，str）的范围是0到m-1 。</span></p><p><span><strong>(1) </strong><strong>加入字符串过程</strong><strong>&nbsp;</strong></span></p><p><span>　　下面是每个字符串处理的过程，首先是将字符串str“记录”到BitSet中的过程：</span></p><p><span>　　对于字符串str，分别计算h（1，str），h（2，str）…… h（k，str）。然后将BitSet的第h（1，str）、h（2，str）…… h（k，str）位设为1。</span></p><p>&nbsp;<img src="http://pic002.cnblogs.com/images/2011/63234/2011010219003441.jpg" alt="" /></p><p><span>　　图1.Bloom Filter加入字符串过程</span></p><p><span>　　很简单吧？这样就将字符串str映射到BitSet中的k个二进制位了。</span></p><p><span><strong>(2) </strong><strong>检查字符串是否存在的过程</strong><strong>&nbsp;</strong></span></p><p><span>　　下面是检查字符串str是否被BitSet记录过的过程：</span></p><p><span>　　对于字符串str，分别计算h（1，str），h（2，str）…… h（k，str）。然后检查BitSet的第h（1，str）、h（2，str）…… h（k，str）位是否为1，若其中任何一位不为1则可以判定str一定没有被记录过。若全部位都是1，则“认为”字符串str存在。</span></p><p><span>　　若一个字符串对应的Bit不全为1，则可以肯定该字符串一定没有被Bloom Filter记录过。（这是显然的，因为字符串被记录过，其对应的二进制位肯定全部被设为1了）</span></p><p><span>　　但是若一个字符串对应的Bit全为1，实际上是不能100%的肯定该字符串被Bloom Filter记录过的。（因为有可能该字符串的所有位都刚好是被其他字符串所对应）这种将该字符串划分错的情况，称为false positive 。</span></p><p><span><strong>(3) </strong><strong>删除字符串过程</strong><strong>&nbsp;</strong></span></p><p><span>&nbsp;&nbsp; 字符串加入了就被不能删除了，因为删除会影响到其他字符串。实在需要删除字符串的可以使用Counting bloomfilter(CBF)，这是一种基本Bloom Filter的变体，CBF将基本Bloom Filter每一个Bit改为一个计数器，这样就可以实现删除字符串的功能了。</span></p><p><span>　　Bloom Filter跟单哈希函数Bit-Map不同之处在于：Bloom Filter使用了k个哈希函数，每个字符串跟k个bit对应。从而降低了冲突的概率。</span></p><p><span><span><strong>三</strong><strong>. Bloom Filter</strong><strong>参数选择</strong></span><strong>&nbsp;</strong></span></p><p><span><strong>&nbsp;&nbsp; (1)</strong><strong>哈希函数选择</strong> </span></p><p><span>&nbsp;&nbsp; 　　哈希函数的选择对性能的影响应该是很大的，一个好的哈希函数要能近似等概率的将字符串映射到各个Bit。选择k个不同的哈希函数比较麻烦，一种简单的方法是选择一个哈希函数，然后送入k个不同的参数。</span></p><p><span>&nbsp;&nbsp; <strong>(2)Bit</strong><strong>数组大小选择</strong><strong>&nbsp;</strong></span></p><p><span>&nbsp;&nbsp; 　　哈希函数个数k、位数组大小m、加入的字符串数量n的关系可以参考<a href="http://pages.cs.wisc.edu/~cao/papers/summary-cache/node8.html" target="_blank">参考文献1</a>。该文献证明了对于给定的m、n，当 k = ln(2)* m/n 时出错的概率是最小的。</span></p><p><span>&nbsp;&nbsp; 　　同时该文献还给出特定的k，m，n的出错概率。例如：根据参考文献1，哈希函数个数k取10，位数组大小m设为字符串个数n的20倍时，false positive发生的概率是0.0000889 ，这个概率基本能满足网络爬虫的需求了。 &nbsp;</span></p><p><span><strong>四</strong><strong>. Bloom Filter</strong><strong>实现代码</strong><strong>&nbsp;</strong></span></p><p><span>&nbsp;&nbsp;　&nbsp;下面给出一个简单的Bloom Filter的Java实现代码：</span></p><div><div><!--</p><p>Code highlighting produced by Actipro CodeHighlighter (freeware)<br />http://www.CodeHighlighter.com/</p><p>--><span><span>import</span><span> java.util.BitSet;</span><span>public</span><span>class</span><span> BloomFilter <br />{<br /></span><span>/*</span><span> BitSet初始分配2^24个bit </span><span>*/</span><span> <br /></span><span>private</span><span>static</span><span>final</span><span>int</span><span> DEFAULT_SIZE </span><span>=</span><span>1</span><span>&lt;&lt;</span><span>25</span><span>; <br /></span><span>/*</span><span> 不同哈希函数的种子，一般应取质数 </span><span>*/</span><span><br /></span><span>private</span><span>static</span><span>final</span><span>int</span><span>[] seeds </span><span>=</span><span>new</span><span>int</span><span>[] { </span><span>5</span><span>, </span><span>7</span><span>, </span><span>11</span><span>, </span><span>13</span><span>, </span><span>31</span><span>, </span><span>37</span><span>, </span><span>61</span><span> };<br /></span><span>private</span><span> BitSet bits </span><span>=</span><span>new</span><span> BitSet(DEFAULT_SIZE);<br /></span><span>/*</span><span> 哈希函数对象 </span><span>*/</span><span> <br /></span><span>private</span><span> SimpleHash[] func </span><span>=</span><span>new</span><span> SimpleHash[seeds.length];</span><span>public</span><span> BloomFilter() <br />{<br /></span><span>for</span><span> (</span><span>int</span><span> i </span><span>=</span><span>0</span><span>; i </span><span>&lt;</span><span> seeds.length; i</span><span>++</span><span>)<br />{<br />func[i] </span><span>=</span><span>new</span><span> SimpleHash(DEFAULT_SIZE, seeds[i]);<br />}<br />}</span><span>//</span><span> 将字符串标记到bits中</span><span><br /></span><span>public</span><span>void</span><span> add(String value) <br />{<br /></span><span>for</span><span> (SimpleHash f : func) <br />{<br />bits.set(f.hash(value), </span><span>true</span><span>);<br />}<br />}</span><span>//</span><span>判断字符串是否已经被bits标记</span><span><br /></span><span>public</span><span>boolean</span><span> contains(String value) <br />{<br /></span><span>if</span><span> (value </span><span>==</span><span>null</span><span>) <br />{<br /></span><span>return</span><span>false</span><span>;<br />}<br /></span><span>boolean</span><span> ret </span><span>=</span><span>true</span><span>;<br /></span><span>for</span><span> (SimpleHash f : func) <br />{<br />ret </span><span>=</span><span> ret </span><span>&amp;&amp;</span><span> bits.get(f.hash(value));<br />}<br /></span><span>return</span><span> ret;<br />}</span><span>/*</span><span> 哈希函数类 </span><span>*/</span><span><br /></span><span>public</span><span>static</span><span>class</span><span> SimpleHash <br />{<br /></span><span>private</span><span>int</span><span> cap;<br /></span><span>private</span><span>int</span><span> seed;</span><span>public</span><span> SimpleHash(</span><span>int</span><span> cap, </span><span>int</span><span> seed) <br />{<br /></span><span>this</span><span>.cap </span><span>=</span><span> cap;<br /></span><span>this</span><span>.seed </span><span>=</span><span> seed;<br />}</span><span>//</span><span>hash函数，采用简单的加权和hash</span><span><br /></span><span>public</span><span>int</span><span> hash(String value) <br />{<br /></span><span>int</span><span> result </span><span>=</span><span>0</span><span>;<br /></span><span>int</span><span> len </span><span>=</span><span> value.length();<br /></span><span>for</span><span> (</span><span>int</span><span> i </span><span>=</span><span>0</span><span>; i </span><span>&lt;</span><span> len; i</span><span>++</span><span>) <br />{<br />result </span><span>=</span><span> seed </span><span>*</span><span> result </span><span>+</span><span> value.charAt(i);<br />}<br /></span><span>return</span><span> (cap </span><span>-</span><span>1</span><span>) </span><span>&amp;</span><span> result;<br />}<br />}<br />}<br /></span></span></div></div><p><span><strong>参考文献：</strong></span></p><p><span>[1]Pei Cao. Bloom Filters - the math.</span></p><p><span>http://pages.cs.wisc.edu/~cao/papers/summary-cache/node8.html</span></p><p><span>[2]Wikipedia. Bloom filter. </span></p><p><span><a href="http://en.wikipedia.org/wiki/Bloom_filter">http://en.wikipedia.org/wiki/Bloom_filter</a></span></p></div></body>
</html>