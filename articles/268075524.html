<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Deploying New Image Formats on the Web</title>
<link rel="stylesheet" href="../css/article.css" />
</head>
<body>
<div class="m-content">
<h1>Deploying New Image Formats on the Web</h1>
<div id="post" itemscope="" itemtype="http://schema.org/Article"><p>By <a href="/" rel="author" itemprop="author">Ilya Grigorik</a> on <b itemprop="datePublished" datetime="2012-12-18">December 18, 2012</b></p><p><img src="http://1-ps.googleusercontent.com/h/www.igvita.com/posts/12/ximage-formats.png.pagespeed.ic.hFfDz6YZCE.jpg" width="210" height="176" />An average page is now over 1200kB in size and <a href="http://httparchive.org/interesting.php#bytesperpage">60% of that</a> is in images. With all the focus on performance and speed across the web performance industry, you would think that innovating on better image formats would be a top agenda item. Not so. Instead, we are living in a self-imposed world of <a href="http://en.wikipedia.org/wiki/Comparison_of_web_browsers#Image_format_support">scarcity of formats</a>, effectively limiting ourselves to gif’s, png’s and jpeg’s.</p><p>In practice, deploying new image formats has been painful - just think back to the saga of png. But one would also hope that png was not the last. In fact, <strong>if we really want to make an impact on web performance, then image formats is the place to do it. There is absolutely no reason why we shouldn't have dozens of specialized formats, each tailored for a specific case and type of image.</strong> But before we get there, we need to iron out some kinks...</p><h2>Deploying new "Magic Image Format"</h2><p>As a practical example, let's imagine we have just invented a new <em>magic image format (mif)</em>. How do we deploy it? As a <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=20214">recent bug on W3C points out</a>, our markup provides no facility to specify different formats for a single image. Let's assume we add such a mechanism. The syntax does not matter, I'll just make it up for the sake of an example:</p><div><pre><code><span>&lt;img</span> <span>srcset=</span><span>"awesome.jpeg 1x, awesome.mif 2x"</span> <span>alt=</span><span>"Use awesome MIF for retina screens!"</span><span>&gt;</span>
</code></pre></div><p>So far, so good. The browser reads the page and decides to load the <code>.mif</code> file while rendering the page. The user loves our awesome image and decides to share it on their favorite social network: right click, copy URL, or simply drags the image into a bookmarklet or extension. At this point, we have a problem. Our user's friends may use a different browser, which may not support <code>.mif</code> files. Instead of an awesome image, they see a broken asset.</p><p>Why did this occur? When presented with all the available image options, the browser was able to negotiate the format for the user, but then the user made the singular choice for all of his friends, and in the process broke it for them. <strong>Client-driven negotiation breaks down the moment the resource leaves the page where all of the representations are available.</strong></p><p>Now, in theory, the browsers could address this by ensuring that every time you grab the asset URL, either via drag and drop, right click, or even JavaScript interaction, then a "safe" URL is returned. However, in the long run, I don't think this is the right solution.</p><h2>Humans don't scale</h2><p><a href="http://www.flickr.com/photos/ig/8084362969/in/photostream"><img src="http://1-ps.googleusercontent.com/h/www.igvita.com/posts/12/xlondon-photo.png.pagespeed.ic.pN8XZ-Qkcw.jpg" width="213" height="255" /></a>Quick, what is the format for the image on the left? Trick question. The file is saved as a <code>.png</code> on my <a href="http://origin.igvita.com/posts/12/london-photo.png">origin</a> server, but depending on your browser, it's either coming up as a <code>.jpeg</code>, or a <code>.webp</code> as you're viewing this page. <a href="https://developers.google.com/speed/pagespeed/service">PageSpeed Service</a> proxy tested the various formats, and decided to re-encode the image to achieve better compression (<a href="http://www.igvita.com/posts/12/pss-img.png">see settings</a>).</p><p>In fact, we already know, based on <a href="http://blog.yoav.ws/2012/07/Images-Can-we-have-less">empirical results</a>, that we as humans are terrible at optimizing images: we forget to resize them, we pick the wrong formats, and its tedious work. You would think that with three image formats to choose from, such problems would not exist. Not so. <strong>I've long stopped worrying about hand-optimizing images. Computers are much better at this task than we are, and they also don't mind the boring work.</strong></p><h2>The format doesn't actually matter</h2><p>For the sake of an argument, let's say we do hand-optimize each image asset. Next, enumerate each variant:</p><div><pre><code>  <span>&lt;img</span> <span>srcset=</span><span>"path/awesome.jpeg, path/awesome.png, path/awesome.webp,</span>
<span>                      path/awesome.svg, path/awesome.mif, path/awesome.mif2"</span>
          <span>alt=</span><span>"How many times do I need to repeat myself?"</span><span>&gt;</span>
</code></pre></div><p>That is silly, boring, and a waste of bytes in the markup. We'll need automation tools just to simplify the task of generating the repeated boilerplate - not unlike the existing CSS prefix woes. So, with that, the extension of the image file doesn't actually matter - we can do without it.</p><p>Let's imagine that we instead invent an abstract <code>.img</code> format, which acts as a stand-in for the optimal format. <strong>What is optimal? It is a function of the image contents and the user agent preference and capabilities at the time of the request.</strong> Who performs the optimization? The server, of course. Given a single source image, it is able to re-encode, recompress, resize, strip unnecessary metadata, ..., and deliver the optimal format.</p><p><strong>In a world with dozens of image formats, the human solution does not scale - read, markup does not scale.</strong> Whereas computers are fantastic at doing exactly the kind of optimization work required to solve the problem.</p><h2>Content-type negotiation</h2><p>Good news, HTTP 1.1 already anticipated all of the mechanics to make this work with <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec12.html">server-driven negotiation</a>:</p><ul>
<li>User agent indicates which file types it supports or is willing to accept through <code>Accept</code> request header</li>
<li>Server selects the format and indicates the returned type through <code>Content-Type</code> response header</li>
</ul><p>Note that the extension on the image file in the URL does not matter. <strong>The same URL can return a different representation based on the negotiated client-server preferences, and the browser then uses the Content-Type to properly interpret the response.</strong> No need for extra markup, no need to hand-tune each image. Further, users don't care which format is negotiated, as long as the image works, and as long as it is delivered quickly.</p><h2>Outlines of the solution</h2><p>If content negotiation is already here, then why are we even having this discussion? On paper we have all we need, in practice, there are a few implementation issues to resolve. First, let's look at the <code>Accept</code> headers sent by modern browsers when making a request for an image resource:</p><table border="1">
<tr>
<td>Chrome</td>

</tr>
<tr>
<td>Safari</td>

</tr>
<tr>
<td>Firefox</td>

</tr>
<tr>
<td>Internet Explorer</td>

</tr>
<tr>
<td>Opera</td>

</tr>
</table><p>Chrome and Safari headers are effectively useless - we accept everything! Firefox and IE aren't doing much better. Opera is the only one explicitly enumerating the supported filetypes, which is the behavior we want, albeit it also adds some unnecessary types at the front. <strong>If we want server-driven negotiation to work, then the first task is to get the browsers to send a useful Accept header - a header which actually enumerates the supported types.</strong></p><p>However, fixing the <code>Accept</code> header is only half the problem. The fact that the same URL may have multiple representations means that all the intermediate caches must have a way to differentiate the various responses. Thankfully, HTTP 1.1 has a <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.44">mechanism for that</a> as well, the <code>Vary</code> header.</p><div><pre><code>  <span>(</span>client<span>)</span>  &gt;  Accept: image/jpeg, image/png, image/mif
  <span>(</span>server<span>)</span> &gt;  Content-Type: image/mif
              &gt;  Vary: Accept
              &gt;  <span>(</span>object<span>)</span>
</code></pre></div><p>The server indicates to upstream clients that the resource should be varied based on the value of client's <code>Accept</code> header by returning <code>Vary: Accept</code>. In the example above, given the choice of three formats, the server chose mif as the optimal one. Any upstream cache can safely cache and serve the mif object to any user agent which provides the the same <code>Accept</code> header. If another user agent sends a different header value, for example without <code>image/mif</code>, then a different format will be served and cached. To the user, this negotiation is transparent.</p><h2>But, but, but...</h2><p><img src="http://1-ps.googleusercontent.com/h/www.igvita.com/posts/12/xpicket.png.pagespeed.ic.P-rRpa40Fm.jpg" width="150" height="173" /><span><strong>But this puts more header bytes on the wire!</strong></span> Yes, it does. If we explicitly enumerate all image types, then the header is 50-100 bytes in the upstream. Half of the requests (~40) on an average page are image requests, which means ~2~4kB in total. In the downlink, these images cost us ~600kB. Assuming we can get 10-30% better compression - a realistic number for WebP, as we'll see below - this translates to <strong>60-180kB in savings, and a 30-45x return on investment</strong>. And <del>I hope</del> I know we can do even better in the future.</p><p>Further, for HTTP 2.0, we will have header compression, which will amortize the cost of sending the image header down to a single transfer of 50-100 bytes, instead of the ~2~4kB in current overhead. As for HTTP 1.1, we can be smart and provide a site controlled opt-in mechanism, such that only sites which support the new negotiation will get the updated header from the browser - the mechanics of this deserves its own separate discussion.</p><p><span><strong>But this would fragment the cache!</strong></span> Small changes in the Accept header could potentially create duplicate entries in the cache. This is <a href="https://www.varnish-cache.org/docs/3.0/tutorial/vary.html">nothing new</a>, and the spec documents ways to normalize the headers: downcase, order does not matter, etc. Also, "<a href="http://tools.ietf.org/html/draft-fielding-http-key-01">Key</a>" proposal is specifically designed to resolve this issue in a generic, cache-friendly way.</p><p><span><strong>But cache support for Vary is missing!</strong></span> Turns out, most CDN's will simply not cache anything with <code>Vary: Accept</code>. That's a sad state of affairs and should be considered a bug. The good news is, <strong>this is not rocket science, rather it is a question of business incentives</strong>. Better image optimization translates to fewer bytes on the wire and better performance - this is aligned with what every CDN is trying to sell you. If the client support is there, then support for <code>Vary: Accept</code> is a competitive edge for every cache and CDN provider.</p><p><span><strong>But old clients will break with Vary: Accept!</strong></span> Support for Vary has been spotty in older clients: <a href="http://blogs.msdn.com/b/ieinternals/archive/2009/06/17/vary-header-prevents-caching-in-ie.aspx">IE6 won't cache</a> any asset with Vary, IE7 will cache but makes a <a href="http://blogs.msdn.com/b/ieinternals/archive/2009/06/17/vary-header-prevents-caching-in-ie.aspx">conditional request</a>, and so on. One practical approach is to make this a forward looking optimization where only newer clients would trigger the new behavior.</p><p><span><strong>But now I need new server software to optimize the images!</strong></span> Yes, you will. This is once again a question of incentives for hosting providers and CDN's. In fact, many CDN's already perform image optimization at the edge. Similarly, open-source projects like <a href="https://developers.google.com/speed/docs/mod_pagespeed/filter-image-optimize">mod_pagespeed</a> and <a href="https://github.com/pagespeed/ngx_pagespeed">ngx_pagespeed</a> are drop-in modules, which will do all the work required to make this work.</p><p><span><strong>But this means more load on the server!</strong></span> Dynamic image optimization doesn't come for free, but <strong>your time is more valuable</strong>. The server can optimize the asset, cache it, and be done with it. There is no global shortage of CPU cycles, and once there is an incentive, these image optimization workflows will be tuned into oblivion.</p><h2>Hands on example with WebP</h2><blockquote>WebP is a new image format that provides lossless and lossy compression for images on the web. WebP lossless images are 26% smaller in size compared to PNGs. WebP lossy images are 25-34% smaller in size compared to JPEG images at equivalent SSIM index. WebP supports lossless transparency (also known as alpha channel) with just 22% additional bytes. Transparency is also supported with lossy compression and typically provides 3x smaller file sizes compared to PNG when lossy compression is acceptable for the red/green/blue color channels.</blockquote><p><strong>25-35% savings over PNG and JPEG, and up to 60%+ for PNG’s with an alpha (transparency) channel.</strong> That's hundreds of kilobytes of savings on most every page. Something <a href="https://developers.google.com/speed/webp/">worth fighting for</a>.</p><p><img src="http://1-ps.googleusercontent.com/h/www.igvita.com/posts/12/xwebp-logo.png.pagespeed.ic.rZRmLbMRo8.jpg" width="100" height="99" />Both Chrome and Opera support WebP, as do some optimization proxies such as mod_pagespeed, PageSpeed Service, Torbit, and few others. However, because of the lacking context in existing <code>Accept</code> headers, each is forced to mark <code>.webp</code> resources with a <code>Cache-Control: private</code> header. This effectively forces every request to be routed to the optimizing proxy, which then performs user agent detection and serves the appropriate content type.</p><p>As many have pointed out, this method does not scale: every request is routed to the origin server, and marking the resource as private bypasses all the intermediate caches. This alone is enough of a reason for why we haven’t seen WebP, and other experimental formats, get any significant adoption on the modern web.</p><h2>The "action plan"</h2><p>Step one, we need to fix and normalize the <code>Accept</code> headers. Opera's header is the closest to what we want, albeit we can restrict the content-types for image assets when requesting an image resource. Perhaps something like:</p><div><pre><code>  Accept: image/webp, image/png, image/jpeg, image/gif, image/svg+xml, image/bitmap
</code></pre></div><p>With that in place, there is an incentive for the CDNs, proxies, and servers to perform the negotiation to deliver the optimal image format. Finally, once the server can choose the format, the upstream caches have an incentive to make <code>Vary</code> work. <strong>In the end, we shave off hundreds of kilobytes of image data, we automate the menial task of selecting the optimal image formats, and we have a future-proof negotiation mechanism which can scale to dozens of image formats.</strong> Everyone wins... <em>until we offset the win by embedding more cat pictures on our pages</em>...</p></div></div>
<script>var _gaq = _gaq || []; _gaq.push(['_setAccount', 'UA-34802167-1']); _gaq.push(['_setDomainName', 'liuzhe.co']); _gaq.push(['_trackPageview']); (function() { var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true; ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'; var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s); })();</script></body>
</html>