<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Moving beyond window.onload() | High Performance Web Sites</title>
<link rel="stylesheet" href="../css/article.css" />
</head>
<body>
<div class="m-content">
<h1>Moving beyond window.onload() | High Performance Web Sites</h1>
<div id="post-3604"><p>May 13, 2013 9:13 am | <a href="http://www.stevesouders.com/blog/2013/05/13/moving-beyond-window-onload/#comments" title="Comment on Moving beyond window.onload()">11 Comments</a></p><!-- .entry-meta --><p>[Originally posted in the <a href="http://calendar.perfplanet.com/2012/moving-beyond-window-onload/">2012 Performance Calendar</a>. Reposting here for folks who missed it.]</p><p>There’s an elephant in the room that we’ve been ignoring for years:</p><p><em>window.onload is not the best metric for measuring website speed</em></p><p>We haven’t actually been “ignoring” this issue. We’ve acknowledged it, but we haven’t coordinated our efforts to come up with a better replacement. Let’s do that now.</p><h2>window.onload is so Web 1.0</h2><p>What we’re after is a metric that captures the user’s <em>perception</em>&nbsp;of when the page is ready. Unfortunately, <code>perception.ready()</code>&nbsp;isn’t on any browser’s roadmap. So we need to find a metric that is a good proxy.</p><p>Ten years ago,&nbsp;<code>window.onload</code>&nbsp;was a good proxy for the user’s perception of when the page was ready. Back then, pages were mostly HTML and images. JavaScript, CSS, DHTML, and Ajax were less common, as were the delays and blocked rendering they introduce. It wasn’t perfect, but&nbsp;<code>window.onload</code>&nbsp;was close enough. Plus it had other desirable attributes:</p><ul>
<li><strong>standard across browsers</strong> -&nbsp;<code>window.onload</code>&nbsp;means the same thing across all browsers. (The only exception I’m aware of is that <a title="JavaScript Performance" href="http://www.stevesouders.com/blog/2012/01/13/javascript-performance/">IE 6-9 don’t wait for async scripts before firing&nbsp;<code>window.onload</code></a>, while most other browsers do.)</li>
<li><strong>measurable by 3rd parties</strong> – <code>window.onload</code>&nbsp;is a page milestone that can be measured by someone other than the website owner,&nbsp;e.g., metrics services like <a href="http://www.keynote.com/">Keynote Systems</a>&nbsp;and tools like&nbsp;<a href="http://yahoo.github.com/boomerang/doc/">Boomerang</a>. It doesn’t require website owners to add custom code to their pages.</li>
<li><strong>measurable for real users</strong> – Measuring&nbsp;<code>window.onload</code>&nbsp;is a lightweight operation, so it can be performed on real user traffic without harming the user experience.</li>
</ul><h2>Web 2.0 is more dynamic</h2><p>Fast forward to today and we see that <code>window.onload</code>&nbsp;doesn’t reflect the user perception as well as it once did.</p><p>There are some cases where a website renders quickly but <code>window.onload</code>&nbsp;fires much later. In these situations the user perception of the page is fast, but <code>window.onload</code>&nbsp;says the page is slow.&nbsp;A good example of this is <a title="Black &amp; Decker Gyro Screwdriver - Amazon.com" href="http://www.amazon.com/gp/product/B008R5259Y/">Amazon product pages</a>. Amazon has done a great job of getting content that’s above-the-fold to render quickly, but all the below-the-fold reviews and recommendations produce a high&nbsp;<code>window.onload</code>&nbsp;value. Looking at these <a href="http://www.webpagetest.org/video/compare.php?tests=121212_KF_V7Y-r%3A3-c%3A0&amp;thumbSize=200&amp;ival=1000&amp;end=visual">Amazon WebPagetest results</a> we see that above-the-fold is almost completely rendered at 2.0 seconds, but&nbsp;<code>window.onload</code>&nbsp;doesn’t happen until 5.2 seconds. (The relative sizes of the scrollbar thumbs shows that a lot of content was added below-the-fold.)</p><p>But the opposite is also true. Heavily dynamic websites load much of the visible page after&nbsp;<code>window.onload</code>. For these websites, <code>window.onload</code>&nbsp;reports a value that is faster than the user’s perception. A good example of this kind of dynamic web app is <a href="https://gmail.com/">Gmail</a>. Looking at the <a href="http://www.webpagetest.org/video/compare.php?tests=121212_KK_VED-r%3A2-c%3A0&amp;thumbSize=200&amp;ival=1000&amp;end=visual">WebPagetest results for Gmail</a> we see that&nbsp;<code>window.onload</code>&nbsp;is 3.3 seconds, but at that point only the progress bar is visible. The above-the-fold content snaps into place at&nbsp;4.8 seconds.&nbsp;It’s clear that in this example <code>window.onload</code>&nbsp;is not a good approximation for the user’s perception of when the page is ready.</p><h2>it’s about rendering, not downloads</h2><p>The examples above aren’t meant to show that Amazon is fast and Gmail is slow. Nor is it intended to say whether all the content should be loaded before&nbsp;<code>window.onload</code>&nbsp;vs. after. The point is that today’s websites are too dynamic to have their perceived speed reflected accurately by&nbsp;<code>window.onload</code>.</p><p>The reason is because&nbsp;<code>window.onload</code>&nbsp;is based on when the page’s resources are downloaded. In the old days of only text and images, the readiness of the page’s content was closely tied to its resource downloads. But with the growing reliance on JavaScript, CSS, and Ajax the perceived speed of today’s websites is better reflected by when the page’s content is rendered. The use of <a title="JavaScript growth" href="http://httparchive.org/trends.php#bytesJS&amp;reqJS">JavaScript</a> and <a title="CSS growth" href="http://httparchive.org/trends.php#bytesCSS&amp;reqCSS">CSS</a>&nbsp;is growing. As the adoption of these dynamic techniques increases, so does the gap between <code>window.onload</code>&nbsp;and the user’s perception of website speed. In other words, this problem is just going to get worse.</p><p>The conclusion is clear: the replacement for&nbsp;<code>window.onload</code>&nbsp;must focus on rendering.</p><h2>what “it” feels like</h2><p>This new performance metric should <strong>take rendering into consideration</strong>. It should be more than “first paint”. Instead, it should capture when the above-the-fold content is (mostly) rendered.</p><p>I’m aware of two performance metrics that exist today that are focused on rendering. Both are available in <a href="http://www.webpagetest.org/">WebPagetest</a>. <a href="http://assets.en.oreilly.com/1/event/62/Above%20the%20Fold%20Time_%20Measuring%20Web%20Page%20Performance%20Visually%20Presentation.pdf">Above-the-fold render time (PDF)</a>&nbsp;was developed at Google. It finds the point at which the page’s content reaches its final rendering, with intelligence to adapt for animated GIFs, streaming video, rotating ads, etc. The other technique, called <a href="https://sites.google.com/a/webpagetest.org/docs/using-webpagetest/metrics/speed-index">Speed Index</a> and developed by <a href="https://plus.google.com/104759401447358500786/posts">Pat Meenan</a>, gives the “average time at which visible parts of the page are displayed”. Both of these techniques use a series of screenshots to do their analysis and have the computational complexity that comes with image analysis.</p><p>In other words, it’s not feasible to perform these rendering metrics on real user traffic in their current form. That’s important because, in addition to incorporating rendering, this new metric must maintain the attributes mentioned previously that make&nbsp;<code>window.onload</code>&nbsp;so appealing: <strong>standard across browsers</strong>,<strong> measurable by 3rd parties</strong>, and<strong> measurable for real users</strong>.</p><p>Another major drawback to&nbsp;<code>window.onload</code>&nbsp;is that it doesn’t work for single page web apps (like Gmail). These web apps only have one <code>window.onload</code>, but typically have several other Ajax-based “page loads” during the user session where some or most of the page content is rewritten. It’s important that this new metric <strong>works for Ajax apps</strong>.</p><h2>ball rolling</h2><p>I completely understand if you’re frustrated by my lack of implementation specifics. Measuring rendering is complex. The point at which the page is (mostly) rendered is so obvious when flipping through the screenshots in WebPagetest. Writing code that measures that in a consistent, non-impacting way is really hard. My officemate pointed me to this thread from the W3C Web Performance Working Group talking about <a title="W3C Web Performance Q&amp;A" href="http://web.archiveorange.com/archive/v/YQtl0oLQ1Go7F1RASmV5">measuring first paint</a>&nbsp;that highlights some of the challenges.</p><p>To make matters worse, the new metric that I’m discussing is likely much more complex than measuring first paint. I believe we need to measure when the above-the-fold content is (mostly) rendered. What exactly is “above-the-fold”? What is “mostly”?</p><p>Another challenge is moving the community away from&nbsp;<code>window.onload</code>. The primary performance metric in popular tools such as <a href="http://www.webpagetest.org/">WebPagetest</a>, <a href="http://support.google.com/analytics/bin/answer.py?hl=en&amp;answer=1205784">Google Analytics Site Speed</a>, <a href="https://secure.torbit.com/insight/">Torbit Insight</a>, <a href="http://www.soasta.com/products/mpulse/">SOASTA (LogNormal) mPulse</a>, and my own <a href="http://httparchive.org/">HTTP Archive</a>&nbsp;is&nbsp;<code>window.onload</code>. I’ve heard that some IT folks even have their bonuses based on the&nbsp;<code>window.onload</code>&nbsp;metrics reported by services like <a href="http://keynote.com/">Keynote Systems</a> and <a href="http://www.compuware.com/application-performance-management/gomez-apm-products.html">Gomez</a>.</p><p>It’s going to take time to define, implement, and transition to a better performance metric. But we have to get the ball rolling. Relying on <code>window.onload</code>&nbsp;as the primary performance metric doesn’t necessarily produce a faster user experience. And yet making our websites faster for users is what we’re <em>really</em> after. We need a metric that more accurately tracks our progress toward this ultimate goal.</p></div></div>
<script>var _gaq = _gaq || []; _gaq.push(['_setAccount', 'UA-34802167-1']); _gaq.push(['_setDomainName', 'liuzhe.co']); _gaq.push(['_trackPageview']); (function() { var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true; ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'; var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s); })();</script></body>
</html>