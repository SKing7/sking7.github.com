<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>12 Devs of Xmas</title>
<link rel="stylesheet" href="../css/article.css" />
</head>
<body>
<div class="m-content">
<h1>12 Devs of Xmas</h1>
<div><p>Functional programming (FP) isn’t as hard or new as it sounds. It’s simply using the tools you’re already familiar with in different ways, and being conscious about aspects of your code you perhaps haven’t thought much about before. People are excited about FP because it leads to simpler code for most of the every-day tasks we face as programmers.</p><p>So what is FP? It’s a conscious focus on functions as our tool to abstract (organise tasks) and structure different our programs. You could say it’s old news – indeed the FP language Lisp has been around for 50+ years – but like many things in life, it’s the way you use the tools that explains how hard you’ll find solving a given problem.</p><h3>Don’t panic</h3><p>With FP there’s a lot to learn, and it can be hard to see the essential core behind the huge array of jargon. This article won’t be touching on exotic tools like monads and functors. Instead I’ll cover the core idea of using functions for abstraction and structure, and avoid confusing the issue with tools and techniques that don’t make practical sense in the context of Javascript.</p><h2>Abstraction</h2><p>Let’s take abstraction first. Abstraction allows us to deal with one problem at a time in our code, and is just as much a part of FP as Object-Oriented Programming (OOP).</p><p>Let’s consider splitting users in a real-time chat app into online and offline users. If we write this without higher-order functions we’ll end up with something like this:</p><pre><code>var online = [];
var offline = [];

for(var i = 0, userCount = users.length; i &lt; userCount; i++) {
  var user = users[i];
  if(user.online) {
    online.push(user);
  } else {
    offline.push(user);
  }
}
</code></pre><p>Here you can see our code solves two problems: the task of splitting a list by testing each item in each, and implementing a test to see if a user is online. One is common to every partition – the partitioning itself. The other – the test – is specific to each partition.</p><p>Let’s see what happens when we apply higher-order functions. The common part – splitting a list into a ‘yes’ and ‘no’ part – can be written as a function that accepts the specific part – the code that tests an item. Here’s what it’ll look like:</p><pre><code>var usersByOfflineStatus = partition(users,function(user) {
  return user.online;
})
</code></pre><p>By passing a function to another function we can avoid duplicating the completely generic bit of a procedure – the partitioning – every time we need to partition, and simply write the bit we care about right now: the partitioning function.</p><p>It’s very easy to write <code>partition</code>. We take our original code, identify the parts which’ll change for each specific partition problem, and replace them with a function we pass into the <code>partition</code>:</p><pre><code>function partition(list,test) {
    var groups = {yes: [], no: []}; 
    for(var i = 0, len = list.length; i &lt; len; i++) {
      var item = list[i];
      // the test of this `if` statement is the only thing
      // specific to each partitioning problem
      if(test(item,i)) {
        groups.yes.push(item);
      } else {
        groups.no.push(item);
      }
    }
    return groups;
}
</code></pre><p>This is the algorithm (recipe) for converting any mixture of a common problem with a specific one. Identify what varies for each specific problem, and move those parts into arguments to a function that wraps up the common code. Now we’ve abstracted that common problem away the rest of our code is more coherent – focussing on solving problems at a higher level, closer to the specific task at hand.</p><p>If you think about how in OOP we specialise a generic superclass via overriding methods in subclasses, you should immediately see the similarity. In the FP version we are passing in the functions we’d override.</p><h3>More higher-order functions</h3><p>Higher-order functions are most applicable in day-to-day operations on lists and key-value objects (in JS we use objects <code>{}</code> for this, soon we’ll use <a href="http://tc39wiki.calculist.org/es6/map-set/"><code>Map</code>s</a>). If you take a peek at <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array#Iteration_methods"><code>Array.prototype</code></a>, you’ll see a gang of interesting higher-order functions to use in your programming. Let’s take a look at one.</p><p>It’s extremely common in programming to have a list of one type of thing, and to want to end up with a list of another. For instance: we have a list of users, and we’d like to extract how long they’ve been offline for.</p><p>Without higher order functions, we’d write this:</p><pre><code>var offlineForMilliseconds = [];
for(var i = 0, userCount = users.length; i &lt; userCount; i++) {
   var offlineMilliseconds = Date.now() - users[i].lastSeenAt
    offlineForMilliseconds[i] = offlineMilliseconds;
}
</code></pre><p>With higher order functions we use a function called <code>map</code>, and with it our solution becomes:</p><pre><code>var offlineForMilliseconds = users.map(function(user) {
  return Date.now() - user.lastSeenAt
})
</code></pre><p>Hopefully you can see how much less complexity we’ve needed! It’s also more intention revealing – with the above, it’s unclear immediately whether <code>offlineForMilliseconds</code> will be longer or shorter than <code>users</code>: we know there’s a loop but we’ll have to read the whole thing to work out what type of operation it’s performing. In contrast, as soon as we read <code>map</code> we know we’re creating a list which has a new value for every item in the original.</p><p>If we use the new <a href="http://tc39wiki.calculist.org/es6/arrow-functions/">ES6 syntax</a> (or <a href="http://coffeescript.org/">Coffeescript</a>), it’s even more obvious how much less work we’re having to do whether reading or writing the code:</p><pre><code>var offlineForMilliseconds = users.map((user) =&gt; Date.now() - user.lastSeenAt)
</code></pre><p>Now when we need to make a new list from an existing one we immediately grab a <code>map</code>. As a result we’ve raised the abstraction of our program – our <code>map</code> code abstracts the generic mapping mechanism, and we supply the non-generic part of the procedure as a higher-order function.</p><h3>Further reading</h3><p>Higher-order functions don’t just apply to collections, they’re a universal way of abstracting away common tasks. Check out <a href="http://underscorejs.org/">underscore.js</a> to see how they’re used to for things like <a href="http://underscorejs.org/docs/underscore.html#section-66">throttling</a> how fast a function is called (great for keeping UIs snappy), or <a href="https://github.com/caolan/async">async.js</a> where they help streamline complex asynchronous workflows.</p><h2>Avoiding unnecessary variables</h2><p>In OOP or procedural code we very often have shared variables, properties and data structures that are modified in the course of the program. To represent partial solved tasks we add items to arrays, change the value of local variables, or modify objects’ properties.</p><p>As in <code>partition</code> and <code>map</code> above, in FP code such modifications are hidden within a function’s local scope. As different parts of our program interact they do not share changeable variables or data-structures by default.</p><!-- Proofed to... --><p>Why? Consider the example of dates in Javascript. If you think about a date in real life they’re very similar to numbers. If we ‘add’ a day to a date, we don’t ‘change’ the date, we simply start referring to a new date: just as 1 + 1 isn’t modifying one of the 1s into a 2. So it’s very strange that in Javascript we represent dates as an object that can change! Because it can change, we can create surprising bugs.</p><p>Let’s say we have a date, and we pass it to a reminder function to schedule a reminder:</p><pre><code>var dateString = prompt("Please give me the date yyyy/mm/dd");
var date = new Date(Date.parse(dateString));
setupReminder(date,4);
saveEvent(event,date);

function setupReminder(date,hoursBefore) {
  date.setHours(date.getHours() - hoursBefore);
  saveReminder(date);
}
</code></pre><p>When would the event be scheduled? It’d be scheduled at 4 hours before we expect, because the <code>Date</code> object was modified within <code>setupReminder</code>! Javascript’s <code>Date</code> object is changeable unnecessarily – it’d have been far better to make the <code>Date</code> object behave like other <a href="http://c2.com/cgi/wiki?ValueObject">values</a> such as numbers, where addition returned a new date rather than modified the current one.</p><p>Objects were originally intended to model things with an identity that can change – but end up being used to model values that have no meaningful identity (you’d never ask ‘which Christmas Day 2013?’) and can cause bugs and unwanted complexity.</p><p>Sharing changeable data can cause problems because we can never be sure if code elsewhere in our program will change it later. Think of the number of times you’ve wanted to clone or copy an object to avoid this issue. Avoiding changeable data or shared variables allows us to avoid a whole type of potential bugs in our programs.</p><p>FP obviously can’t completely eliminate changeable data if it’s an essential part of a given problem. It simply suggests we separate the parts of our programs that manage state, and attempt to keep it only to essential pieces of state. So our <code>Date</code>s would become unchanging <a href="http://c2.com/cgi/wiki?ValueObject">‘values’</a> rather than changeable objects, as would a large number of the concepts often modeled with objects in OOP. Equally, unless there’s a performance limitation, we use <a href="https://github.com/swannodette/mori">unchangeable data-structures</a>.</p><h2>A place for objects</h2><p>‘Object’, like many words in programming, has many meanings. Though it might seem like FP JavaScript wholly avoids objects we still use them, in three senses.</p><p>First we use objects as key-value data-structures: aka dictionaries, hashes or associative arrays. This has nothing to do with message passing: associating keys and values is an essential task, and all FP languages will have key-value data-structures.</p><p>Second we use objects to create modules. Rather than having all our functions in a flat global namespace we separate them as properties of key-value structures to organise related functions. Again, nothing to do with the idea of message passing, we’re just creating a module system in a language with no native one.</p><p>Third we use objects for the parts of a program that require interchangeable APIs around stateful processes or resources. Promises are a great example. <a href="http://wiki.commonjs.org/wiki/Promises/A">Promises</a> are a standard for representing the result of a process, and ideally you can write code that accepts and uses promises without knowing which of <a href="https://github.com/cujojs/when">the</a> <a href="https://github.com/petkaantonov/bluebird/">many</a> <a href="https://github.com/kriskowal/q">implementations</a> it uses.</p><p>In other languages that are designed from the ground up to be more fully functional, concepts like promises can be expressed without objects. Practicality reasons mean it’s unwise to follow their lead when writing FP JavaScript – it’ll lead to slow, confusing and likely ugly code.</p><h2>Structuring functional programs</h2><p>How can we structure our program without objects? It depends on which type of program you’re writing.</p><p>For GUIs, objects map extremely well onto the problem – this was one of the primary areas of inspiration for OOP. If we look at the definition of OOP from <a href="http://lists.squeakfoundation.org/pipermail/squeak-dev/1998-October/017019.html">Alan Kay</a>, the <a href="http://en.wikipedia.org/wiki/Object-oriented_programming#History">inventor of the phrase</a> “object-oriented”, we find that objects should be like biological cells: communicating by messages alone, the interpretation of which are left up to the receiving cell.</p><h3>GUIs</h3><p>So in GUI programming I personally often use objects to wrap the code of each widget. However the code inside those objects is functional. Whenever I’m interpreting data from APIs, formatting values for views or creating utilities to throttle input, I write functional code. This is a common pattern that – both <a href="https://leanpub.com/fp-oo">Michael Feathers</a> and <a href="https://www.destroyallsoftware.com/screencasts/catalog/functional-core-imperative-shell">Gary Bernhardt</a> have independently identified ‘objects with a functional core’ as a great way of using the two paradigms together.</p><h3>Implicit objects</h3><p>The phrase ‘objects with a functional core’ might not mean what you think it does. It doesn’t require using ‘objects’ in a “classes, instances and constructors” sense at all. An ‘object’ is a role in Alan Kay’s definition – it’s something that accepts messages from the outside world. We don’t actually need our objects to be separate types of entities within JS or other languages: they could be separate processes! This is a common pattern for Node.js projects: very functional code inside the process that responds to events (messages) coming from outside. So two processes that communicate via a message queue are clearly fulfilling Alan Kay’s definition of objects. So too, on the front-end, are two systems of functions connected only by some kind of event emitter.</p><h2>Next steps</h2><p>If this overview has whetted your appetite here are some great next steps:</p><h2>Use function programming every day</h2><p>FP can be simple and fun, offering great abstraction power with less complexity from object systems or changeable shared data. It’s different, but at core it’s just a new way of using extremely familiar tools. I hope it helps you build cool things in 2014!</p></div></div>
<script>var _gaq = _gaq || []; _gaq.push(['_setAccount', 'UA-34802167-1']); _gaq.push(['_setDomainName', 'liuzhe.co']); _gaq.push(['_trackPageview']); (function() { var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true; ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'; var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s); })();</script></body>
</html>