<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Async Ads with HTML Imports</title>
<link rel="stylesheet" href="../css/article.css" />
</head>
<body>
<div class="m-content">
<h1>Async Ads with HTML Imports</h1>
<div id="post-3803"><p>November 16, 2013 5:05 am | <a href="http://www.stevesouders.com/blog/2013/11/16/async-ads-with-html-imports/#comments" title="Comment on Async Ads with HTML Imports">15 Comments</a></p><!-- .entry-meta --><p>Scripts loaded in the typical way (<code>&lt;script src="a.js"&gt;&lt;/script&gt;</code>) block rendering which is bad for performance. The solution to this problem is to <a href="http://www.stevesouders.com/blog/2009/04/27/loading-scripts-without-blocking/">load scripts asynchronously</a>. This is the technique used by the best 3rd party snippets, for example,&nbsp;<a href="https://developers.google.com/analytics/devguides/collection/gajs/">Google Analytics</a>, <a href="https://dev.twitter.com/docs/tweet-button">Tweet button</a>, <a href="https://developers.facebook.com/docs/reference/javascript/">Facebook SDK</a>, and <a href="https://developers.google.com/+/web/follow/">Google+ Follow button</a>.</p><p>Ads are probably the most prevalent 3rd party content on the Web. Unfortunately, most ads can’t be loaded asynchronously because they use&nbsp;<code>document.write</code>. (Doing <code>document.write</code>&nbsp;in an async script&nbsp;causes the entire page to be erased. We’ll see this in the examples below.) Some teams (<a href="http://digital-fulcrum.com/ghostwriter/docs/files/ghostwriter-js.html">GhostWriter</a>, <a href="https://developers.google.com/speed/pagespeed/module/filter-js-defer">PageSpeed</a>) have tried to solve the async&nbsp;<code>document.write</code>&nbsp;problem but it requires a lot of code and edge cases exist.</p><p>In my recent investigations into the performance of&nbsp;<a href="http://www.w3.org/TR/html-imports/">HTML Imports</a>&nbsp;I discovered a way to make ads load asynchronously – even ads that use&nbsp;<code>document.write</code>. Let’s take a look at how HTML imports&nbsp;block, how to make HTML imports&nbsp;asynchronous, the dangers of doing this with document.write, and the workaround to make this all work.</p><h3>HTML imports block rendering</h3><p>HTML imports&nbsp;block rendering if used in the default way. This is unfortunate, especially given that this is a recent addition to HTML when the importance of not blocking rendering is well known. The <a href="http://www.w3.org/TR/html-imports/">HTML Imports spec</a> is still a working draft, so it’s possible this could be switched so that they load asynchronously by default.</p><p>Nevertheless, HTML imports&nbsp;are typically created like this:</p><pre>&lt;link rel="import" href="import.php"&gt;</pre><p>Content from the imported HTML document is inserted like this:</p><pre>&lt;div id=import-container&gt;&lt;/div&gt;
&lt;script&gt;
var link = document.querySelector('link[rel=import]');
var content = link.import.querySelector('#imported-content');
document.getElementById('import-container').appendChild(content.cloneNode(true));
&lt;/script&gt;</pre><p>The LINK tag itself doesn’t block rendering – the browser knows the import can be downloaded asynchronously. But rendering <em>is</em> blocked when the browser encounters the first SCRIPT tag following the LINK.&nbsp;This behavior is demonstrated in the <a href="http://stevesouders.com/tests/link-import/sync.php">sync.php</a> test page. To make the blocking observable, the import takes five seconds to download and then the pink “IMPORTED CONTENT” is displayed. The SCRIPT block is in the middle of the page so the first paragraph IS rendered, but the last paragraph IS NOT rendered until after five seconds. This demonstrates that HTML imports&nbsp;block rendering.</p><p><strong>Running the examples:</strong> Currently HTML imports&nbsp;only work in&nbsp;<a href="https://www.google.com/intl/en/chrome/browser/canary.html">Chrome Canary</a> and you have to turn on the following flags in chrome://flags/: Experimental Web Platform features, Experimental JavaScript, and HTML Imports.</p><h3>Making HTML imports&nbsp;async</h3><p>It’s not too hard to make HTML imports&nbsp;asynchronous thus avoiding the default blocking behavior. Instead of using the LINK tag in markup, we create it using JavaScript:</p><pre>var link = document.createElement('link');
link.rel = 'import';
link.onload = function() {
    var link = document.querySelector('link[rel=import]');
    var content = link.import.querySelector('#imported-content');
    document.getElementById('import-container').appendChild(content.cloneNode(true));
};
link.href = url;
document.getElementsByTagName('head')[0].appendChild(link);</pre><p>The <a href="http://stevesouders.com/tests/link-import/async.php">async.php</a> test page shows how using this asynchronous pattern doesn’t block rendering – the last paragraph is rendered immediately, then after five seconds we see the pink “IMPORTED CONTENT” from the HTML import. This shows that HTML imports can be used without blocking the page from rendering.</p><h3>HTML imports&nbsp;with <code>document.write</code> – watch out!</h3><p>This is kind of weird and might be hard to grok: HTML imports&nbsp;have their own HTML document. BUT (here’s the complex part) any JavaScript within the HTML import&nbsp;is executed in the context of the main page. At least that’s the way it works now in Chrome. The <a title="HTML Imports specification" href="http://www.w3.org/TR/html-imports/">spec</a> doesn’t address this issue.</p><p>This is important because some 3rd party content (especially ads)&nbsp;use&nbsp;<code>document.write</code>. Some people might think that a&nbsp;<code>document.write</code>&nbsp;inside an HTML import would write to the HTML import’s document. But that’s not the case. Instead,&nbsp;<code>document</code>&nbsp;refers to the main page’s <code>document</code>. This can produce surprising (as in “bad”) results.</p><p>As shown in the <a href="http://stevesouders.com/tests/link-import/sync-docwrite.php">sync docwrite.php</a>&nbsp;and <a href="http://stevesouders.com/tests/link-import/async-docwrite.php">async docwrite.php</a>&nbsp;test pages, when the HTML import&nbsp;contains a script that&nbsp;uses&nbsp;<code>document.write</code>&nbsp;it erases the content of the main page. If you’re uncertain whether the imported content&nbsp;uses&nbsp;<code>document.write</code>&nbsp;then it’s risky to use HTML imports. Or is it?</p><h3>Safely using HTML imports&nbsp;with <code>document.write</code></h3><p>Since much 3rd party content (especially ads) use&nbsp;<code>document.write</code>,&nbsp;there’s a motivation to make them work with HTML imports. However, as shown by the previous examples, this can have disastrous results because when the HTML import does&nbsp;<code>document.write</code>&nbsp;it’s actually referencing the main page’s&nbsp;<code>document</code>&nbsp;and erases the main page.</p><p>There’s a simple “hack” to get around this. We can’t redefine&nbsp;<code>document</code>, but we CAN redefine&nbsp;<code>document.write</code>&nbsp;within the HTML import:</p><pre>// inside the HTML import
document.write = function(msg) {
    document.currentScript.ownerDocument.write(msg);
};</pre><p>With this change, all&nbsp;<code>document.write</code>&nbsp;output from scripts inside the HTML import goes to the HTML import’s document.&nbsp;This eliminates the problem of the HTML import clearing the main page. This fix is shown by&nbsp;the&nbsp;<a href="http://stevesouders.com/tests/link-import/sync-docwrite-override.php">sync docwrite-override.php</a>&nbsp;and&nbsp;<a href="http://stevesouders.com/tests/link-import/async-docwrite-override.php">async docwrite-override.php</a>&nbsp;test pages.</p><h3>Async (<code>document.write</code>) ads with HTML imports</h3><p>Let’s see this technique in action. The <a href="http://stevesouders.com/tests/link-import/async-ads.php">async-ads.php</a> test page includes Google’s <a href="http://pagead2.googlesyndication.com/pagead/show_ads.js">show_ads.js</a>&nbsp;to load real ads. The overridden version of&nbsp;<code>document.write</code>&nbsp;also echoes the output to the page so you can verify what’s happening. The&nbsp;<code>document.write</code>&nbsp;works and the ad is shown even though it’s loaded asynchronously.</p><p>This is a major accomplishment but there are some big caveats:</p><ul>
<li>Although we’ve overridden&nbsp;<code>document.write</code>, there might be other JavaScript in the HTML import that assumes it’s running in the main page’s context (e.g., <code>location.href</code>, <code>document.title</code>).</li>
<li>Some people believe it would be good to disable <code>document.write</code>&nbsp;inside HTML imports, in which case ads wouldn’t work.</li>
<li>We need a fallback as support for HTML imports grows. This is possible by detecting support for HTML imports and reverting to the current (blocking) technique for ads.</li>
</ul><p>Perhaps the biggest caveat is whether it’s realistic to expect website owners to do this. I don’t think a majority of websites would adopt this technique, but I like having an option to make ads async for websites that are willing to do the work. Right now, motivated website owners don’t have good alternatives for loading ads without blocking their own content on their page. I know some sites that have loaded ads at the bottom of the page in a hidden div and then clone them to the top when done, but this usually results in a drop in ad revenue because the ads load later. Using HTML imports allows the ad to be loaded at the top so we can have asynchronous behavior without a loss in ad revenue.</p><p>The goal of this post is to suggest that we find a way to solve one of today’s biggest obstacles to fast web pages: ads. The spec for HTML imports is a working draft and there’s only one implementation, so both are likely to change. My hope is we can make HTML imports asynchronous by default so they don’t block rendering, and use them as technique for achieving asynchronous ads.</p></div></div>
<script>var _gaq = _gaq || []; _gaq.push(['_setAccount', 'UA-34802167-1']); _gaq.push(['_setDomainName', 'liuzhe.co']); _gaq.push(['_trackPageview']); (function() { var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true; ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'; var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s); })();</script></body>
</html>