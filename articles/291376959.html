<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>High Performance Networking in Google Chrome</title>
<link rel="stylesheet" href="../css/article.css" />
</head>
<body>
<div class="m-content">
<h1>High Performance Networking in Google Chrome</h1>
<div id="post" itemscope="" itemtype="http://schema.org/Article"><p>By <a href="/" rel="author" itemprop="author">Ilya Grigorik</a> on <b itemprop="datePublished" datetime="2013-01-31">January 31, 2013</b></p><div><p style="display: inline;">
The following is a </p><strong>draft chapter</strong><p style="display: inline;"> for the upcoming "The Performance of Open Source Applications" (POSA), a sequel to </p><a href="http://www.aosabook.org/en/index.html">The Architecture of Open Source Applications</a><p style="display: inline;">. POSA is a collection of essays about performance optimization, designing for performance, managing performance as part of a development process, and more. </p><strong>The book will be published in Spring 2013 under a Creative Commons license with royalties going to Amnesty International.</strong></div><hr /><hr /><h2 id="history">History and guiding principles of Google Chrome <a href="#history">#</a> <a href="#toc">↑</a></h2><p>Google Chrome was first released in the second half of 2008, as a beta version for the Windows platform. The Google-authored code powering Chrome was also made available under a permissive BSD license - aka, the Chromium project. To many observers, this turn of events came as a surprise: <strong>the return of the browser wars?</strong> Could Google really do much better?</p><blockquote>"It was so good that it essentially forced me to change my mind..." - Eric Schmidt, on his <a href="http://blogs.wsj.com/digits/2009/07/09/sun-valley-schmidt-didnt-want-to-build-chrome-initially-he-says/">initial reluctance</a> to the idea of developing Google Chrome.</blockquote><p><img src="https://1-ps.googleusercontent.com/s/www.igvita.com/posts/13/posa/xcomic-chrome.png.pagespeed.ic.RjLoBkMt3k.png" width="206" height="150" />Turns out, they could. Today Chrome is one of the most widely used browsers on the web (<a href="http://gs.statcounter.com/?PHPSESSID=oc1i9oue7por39rmhqq2eouoh0">35%+</a> of the market share according to StatCounter) and is now available on Windows, Linux, OS X, Chrome OS, as well as Android and iOS platforms. Clearly, the features and the functionality resonated with the users, and many innovations of Chrome have also found their way into other popular browsers.</p><p>The original <a href="http://www.google.com/googlebooks/chrome/">38-page comic book</a> explanation of the ideas and innovations of Google Chrome offers a great overview of the thinking and design process behind the popular browser.
However, this was only the beginning. The core principles that motivated the original development of the browser continue to be the guiding principles for ongoing improvements in Chrome:</p><ul>
<li><strong>Speed:</strong> the objective is to make the <strong>fastest</strong> browser</li>
<li><strong>Security:</strong> provide the <strong>most secure</strong> environment to the user</li>
<li><strong>Stability:</strong> provide a <strong>resilient and stable</strong> web application platform</li>
<li><strong>Simplicity:</strong> sophisticated technology, wrapped in a <strong>simple user experience</strong></li>
</ul><p>As the team observed, many of the sites we use today aren't just web pages, they are applications. In turn, the ever more ambitious applications require speed, security, and stability. Each of these deserves its own dedicated chapter, but since our subject is performance, our focus will be primarily on speed.</p><h2 id="perf-facets">The many facets of performance <a href="#perf-facets">#</a> <a href="#toc">↑</a></h2><p>A modern browser is a platform, just like your operating system, and Google Chrome is designed as such. Prior to Google Chrome, all major browsers were built as a monolithic, single process applications. All open pages shared the same address space and contended for the same resources. A bug in any page, or the browser, ran the risk of compromising the entire experience.</p><p><img src="https://1-ps.googleusercontent.com/s/www.igvita.com/posts/13/posa/xcomic-multi-process.png.pagespeed.ic.aRRxIxeQge.png" width="302" height="248" />By contrast, <strong>Chrome works on a multi-process model</strong>, which provides process and memory isolation, and a tight <a href="http://dev.chromium.org/developers/design-documents/sandbox">security sandbox</a> for each tab. In an increasingly multi-core world, the ability to isolate the processes as well as shield each open tab from other misbehaving pages has by itself proven to give Chrome a significant performance edge over the competition. In fact, it is important to note that most other browsers have followed suit, or are in the process of migrating to similar architecture.</p><p>With an allocated process in place, the execution of a web program primarily involves three tasks: fetching resources, page layout and rendering, and JavaScript execution. The rendering and script steps follow a single-threaded, interleaved model of execution - it is not possible to perform concurrent modifications of the resulting Document Object Model (DOM). This is in part due to the fact that JavaScript itself is a single threaded language. Hence, optimizing how the rendering and script execution runtimes work together is of critical importance, both to the web developers building the applications as well as the developers working on the browser.</p><p>For rendering, Chrome uses <a href="http://www.chromium.org/blink">Blink</a>, which is a fast, open-source, and standards compliant layout engine. For JavaScript, Chrome ships with its own, heavily optimized <a href="http://en.wikipedia.org/wiki/V8_(JavaScript_engine)">"V8" JavaScript runtime</a>, which was also released as a standalone open-source project and has found its way into many other popular projects - e.g., runtime for node.js. <strong>However, optimizing V8 JavaScript execution, or the Blink parsing and rendering pipelines won't do much good if the browser is blocked on the network, waiting for the resources to arrive!</strong></p><p>The ability of the browser to optimize the order, priority, and latency of each network resource is one of the most critical contributors to the overall user experience. You may not be aware of it, but Chrome's network stack is, quite literally, getting smarter every day, trying to hide or decrease the latency cost of each resource: it learns likely DNS lookups, it remembers the topology of the web, it preconnects to likely destination targets, and more. From the outside, it presents itself as a simple resource fetching mechanism, but from the inside it is an elaborate and a fascinating case study for how to optimize web performance and deliver the best experience to the user.</p><p><em>Let's dive in...</em></p><h2 id="modern-application">What is a modern web application? <a href="#modern-application">#</a> <a href="#toc">↑</a></h2><p>Before we get to the tactical details of how to optimize our interaction with the network, it helps to understand the trends and the landscape of the problem we are up against. In other words, <strong>what does a modern web page, or application look like?</strong></p><p>The <a href="http://httparchive.org/">HTTP Archive</a> project tracks how the web is built, and it can help us answer this question. Instead of crawling the web for the content, it periodically crawls the most popular sites to record and aggregate analytics on the number of used resources, content types, headers, and other metadata for each individual destination. The stats, as of January 2013, may surprise you. An average page, amongst the top 300,000 destinations on the web is:</p><p><img src="https://1-ps.googleusercontent.com/s/www.igvita.com/posts/13/posa/xhttparchive-jan2013.png.pagespeed.ic.dBi1KPmYR5.png" /></p><ul>
<li><strong>1280 KB</strong> in size</li>
<li>composed of <strong>88 resources</strong></li>
<li>connects to <strong>15+ distinct hosts</strong></li>
</ul><p>Let that sink in. Over 1MB in size on average, composed of 88 resources such as images, JavaScript, and CSS, and delivered from 15 different own and third-party hosts! Further, each of these numbers have been <a href="http://httparchive.org/trends.php">steadily increasing</a> over the past few years, and there are no signs of stopping. We are increasingly building larger and more ambitious web applications.</p><p>Applying basic math to the HTTP Archive numbers reveals that an average resource is about 12KB in size (1045 KB / 84 resources), which means that <strong>most network transfers in the browser are short and bursty</strong>. This presents its own set of complications because the underlying transport (TCP) is optimized for large, streaming downloads. Let's peel back the onion and inspect one of these network requests...</p><h2 id="resource-request">The life of a resource request on the wire <a href="#resource-request">#</a> <a href="#toc">↑</a></h2><p>The W3C <a href="http://www.w3.org/TR/navigation-timing/">Navigation Timing specification</a> provides a browser API and visibility into the timing and performance data behind the life of every request in the browser. Let's inspect the components, as each is a critical piece of delivering the optimal user experience:</p><p><img src="https://1-ps.googleusercontent.com/s/www.igvita.com/posts/13/posa/xnavtiming.png.pagespeed.ic.2jkC1HUdLK.png" /></p><p>Given the URL of a resource on the web, the browser starts by checking its local and application caches. If you have previously fetched the resource and the <a href="https://developers.google.com/speed/docs/best-practices/caching">appropriate cache headers</a> were provided (<em>Expires</em>, <em>Cache-Control</em>, etc.), then it is possible that we may be allowed to use the local copy to fulfill the request - <strong>the fastest request is a request not made</strong>. Alternatively, if we have to revalidate the resource, if it expired, or if we simply haven't seen it before, then a costly network request must be dispatched.</p><p>Given a hostname and resource path, Chrome first checks for existing open connections it is allowed to reuse - sockets are pooled by <code>{scheme, host, port}</code>. Alternatively, if you have configured a proxy, or specified a <a href="http://en.wikipedia.org/wiki/Proxy_auto-config">proxy auto-config</a> (PAC) script, then Chrome checks for connections through the appropriate proxy. PAC scripts allow for different proxies based on URL, or other specified rules, each of which can have its own socket pool. Finally, if neither of the above conditions is matched, then the <strong>request must begin by resolving the hostname to its IP address - aka, a DNS lookup</strong>.</p><p>If we are lucky, the hostname may already be cached in which case the response is usually just one quick system call away. If not, then a DNS query must be dispatched before any other work can happen. The time taken to do the DNS lookup will vary based on your internet provider, the popularity of the site and the likelihood of the hostname to be in intermediate caches, as well as the response time of the authoritative servers for that domain. In other words, there are a lot of variables at play, but it's not unusual for a DNS lookup to take up to <em>several hundred milliseconds</em> - ouch.</p><p><img src="https://1-ps.googleusercontent.com/s/www.igvita.com/posts/13/posa/xtcp-handshake.png.pagespeed.ic.41IsyjCjFX.png" width="144" height="151" />With the resolved IP address in hand, Chrome can now open a new TCP connection to the destination, which means that we must perform the "<a href="http://en.wikipedia.org/wiki/Transmission_Control_Protocol#Connection_establishment">three-way handshake</a>": <code>SYN &gt; SYN-ACK &gt; ACK</code>. This exchange adds a <strong>full roundtrip of latency delay to each and every new TCP connection - no shortcuts</strong>. Depending on the distance between the client and the server, as well as the chosen routing path, this can yield from tens to hundreds, or even thousands, of milliseconds of delay. All of this work and latency is before even a single byte of application data has hit the wire!</p><p>Once the TCP handshake is complete, and if we're connecting to a secure destination (HTTPS), then the SSL handshake must take place. This can add <strong>up to two additional roundtrips of latency delay</strong> between client and server. If the SSL session is cached, then we can "escape" with just one additional roundtrip.</p><p>Finally, Chrome is able to dispatch the HTTP request (<code>requestStart</code> in the Nav Timing figure above). Once received, the server can process the request and then stream the response data back to the client. This incurs a minimum of a network roundtrip, plus the processing time on the server. Following that, we're done. Well, that is unless the actual response is an HTTP redirect! In which case, we may have to repeat the entire cycle once over. Have a few gratuitous redirects on your pages? You may want to revisit that decision!</p><p>Have you been counting all the delays? To illustrate the problem, let's assume the worst case scenario for a typical broadband connection: local cache miss, followed by a relatively fast DNS lookup (50 ms), TCP handshake, SSL negotiation, and a relatively fast (100 ms) server response time, with a round-trip time of 80 ms (an average round-trip across continental USA):</p><ul>
<li>50ms for DNS</li>
<li>80ms for TCP handshake (one RTT)</li>
<li>160ms for SSL handshake (two RTT's)</li>
<li>40ms for request to server</li>
<li>100ms for server processing</li>
<li>40ms for response from the server</li>
</ul><p>That's 470 milliseconds for a single request, which translates to <strong>over 80% of network latency overhead as compared to the actual server processing time to fulfill the request</strong> - we have some work to do here! In fact, even 470 milliseconds may be an optimistic estimate:</p><ul>
<li>If the server response does not fit into the initial TCP <a href="http://en.wikipedia.org/wiki/Transmission_Control_Protocol#Congestion_control">congestion window</a> (4-15 KB), then one or more additional roundtrips of latency is introduced</li>
<li>SSL delays could get even worse if we need to fetch a missing certificate or perform an <a href="http://en.wikipedia.org/wiki/Online_Certificate_Status_Protocol">online certificate status check</a> (OCSP), both of which will require an entirely new TCP connection, which can add hundreds and even thousands of milliseconds of additional latency</li>
</ul><h2 id="fast-enough">What is "fast enough"? <a href="#fast-enough">#</a> <a href="#toc">↑</a></h2><p>The network overhead of DNS, handshakes, and the roundtrip times is what dominates the total time in our earlier case - the server response time accounts for only 20% of the total latency! But, <strong>in the grand scheme of things, do these delays even matter?</strong> If you are reading this, then you probably already know the answer: yes, very much so.</p><p>Past <a href="http://www.useit.com/papers/responsetime.html">user experience research</a> paints a consistent picture in what we, as users, expect in terms of responsiveness of any applications, both offline and online:</p><table border="1" width="100%">
<tr>


</tr>
<tr>
<td>0 - 100ms</td>
<td>Instant</td>
</tr>
<tr>
<td>100 - 300ms</td>
<td>Small perceptible delay</td>
</tr>
<tr>
<td>300 - 1000ms</td>
<td>Machine is working</td>
</tr>
<tr>
<td>1s+</td>
<td>Mental context switch</td>
</tr>
<tr>
<td>10s+</td>
<td>I'll come back later...</td>
</tr>
</table><p>The table above also explains the unofficial rule of thumb in the web performance community: render your pages, or at the very least, provide visual feedback in under 250 ms to keep the user engaged. This is not speed simply for speed's sake. Studies at Google, Amazon, Microsoft, as well as thousands of other sites show that additional latency has a direct impact on the bottom line of your site: <strong>faster sites yield more pageviews, higher engagement from the users, and see higher conversion rates.</strong></p><p>So, there you have it, our optimal latency budget is 250 ms, and yet as we saw in the example above, the combination of a DNS lookup, the TCP and SSL handshakes, and propagation times for the request add up to 370 ms. We're 50% over budget, and we still haven't factored in the server processing time!</p><p>To most users and even web-developers, the DNS, TCP, and SSL delays are entirely transparent and are negotiated at network layers to which few of us descend or think about. And yet, each of these steps is critical to the overall user experience, since each extra network request can add tens or hundreds of milliseconds of latency. <strong>This is the reason why Chrome's network stack is much, much more than a simple socket handler.</strong></p><p><em>Now that we've identified the problem, let's dive into the implementation details...</em></p><h2 id="network-stack">Chrome's network stack from 10,000 feet <a href="#network-stack">#</a> <a href="#toc">↑</a></h2><h3 id="multi-process">Multi-process architecture <a href="#multi-process">#</a> <a href="#toc">↑</a></h3><p>Chrome's multi-process architecture carries important implications for how each network request is handled within the browser. Under the hood, Chrome actually supports <a href="http://www.chromium.org/developers/design-documents/process-models">four different execution models</a> that determine how the process allocation is performed.</p><p>By default, desktop Chrome browsers use the process-per-site model, that isolates different sites from each other, but groups all instances of the same site into the same process. However, to keep things simple, let's assume one of the simplest cases: one distinct process for each open tab. From the network performance perspective, the differences here are not substantial, but the process-per-tab model is much easier to understand.</p><p><img src="https://1-ps.googleusercontent.com/s/www.igvita.com/posts/13/posa/xkernel-renderer.png.pagespeed.ic.-HcShFJuec.png" /></p><p>The architecture dedicates one <em>render process</em> to each tab, which itself contains an instance of the Blink open-source layout engine for interpreting and layout out the HTML (aka, "HTML Renderer" in the diagram), an instance of the V8 JavaScript engine, and the glue code to bridge these and a few other components. If you are curious, the Chromium wiki contains a <a href="http://www.chromium.org/developers/design-documents/multi-process-architecture">great introduction to the plumbing</a>.</p><p>Each of these "render" processes is executed within a sandboxed environment that has limited access to the user's computer - including the network. To gain access to these resources, each render process communicates with the browser (kernel) process, which is able to impose security and access policies on each renderer.</p><h3 id="ipc">Inter-process communication (IPC) and Multi-process resource loading <a href="#ipc">#</a> <a href="#toc">↑</a></h3><p>All communication between the renderer and the kernel process in Chrome is done via IPC. On Linux and OSX, a <code>socketpair()</code> is used, which provides a named pipe transport for asynchronous communication. Each message from the renderer is serialized and passed to a dedicated I/O thread, which dispatches it to the kernel process. On the receiving end, the kernel process provides a filter interface, which allows Chrome to intercept resource IPC requests (see <a href="http://code.google.com/p/chromium/source/search?q=resourcemessagefilter&amp;origq=resourcemessagefilter&amp;btnG=Search+Trunk">ResourceMessageFilter</a>) which should be handled by the network stack.</p><p><img src="https://1-ps.googleusercontent.com/s/www.igvita.com/posts/13/posa/xchrome-ipc.png.pagespeed.ic.Imrw2xGv75.png" /></p><p>One of the advantages of this architecture is that <strong>all resource requests are handled entirely on the I/O threads and neither any UI generated activity, or network events interfere with each other</strong>. The resource filter runs in the I/O thread in the browser process, intercepts the resource request messages, and forwards them to a <a href="http://code.google.com/searchframe#OAMlx_jo-ck/src/content/public/browser/resource_dispatcher_host.h&amp;exact_package=chromium&amp;q=ResourceDispatcherHost">ResourceDispatcherHost</a> singleton in the browser process.</p><p>The singleton interface allows the browser to control each renderer's access to the network, but it also enables efficient, and consistent resource sharing:</p><ul>
<li><strong>Socket pool and connection limits:</strong> the browser is able to enforce limits on the number of open sockets per profile (256), proxy (32), and <code>{scheme, host, port}</code> (6) groups. Note that this allows up to six HTTP and six HTTPS connections to the same <code>{host, port}</code>!</li>
<li><strong>Socket reuse:</strong> persistent TCP connections are retained in the socket pool for some time after servicing the request to enable connection reuse, which avoids the extra DNS, TCP, and SSL (if required) setup overhead imposed on each new connection.</li>
<li><strong>Socket late-binding:</strong> requests are associated with an underlying TCP connection only once the socket is ready to dispatch the application request, allowing better request prioritization (e.g., arrival of a higher priority request while the socket was connecting), better throughput (e.g., re-use of a "warm" TCP connection in cases where an existing socket becomes available while a new connection is being opened), as well as a general-purpose mechanism for TCP pre-connect, and a number of other optimizations.</li>
<li><strong>Consistent session state:</strong> authentication, cookies, and cached data is shared between all render processes.</li>
<li><strong>Global resource and network optimizations:</strong> the browser is able to make decisions across all render processes and outstanding requests. For example, giving network priority to the requests initiated by the foreground tab.</li>
<li><strong>Predictive optimizations:</strong> by observing all network traffic, Chrome is able to build and refine predictive models to improve performance.</li>
<li><em>... and the list goes on.</em></li>
</ul><p>As far as the render process is concerned, it is simply sending a resource request message over IPC, which is tagged with a unique request ID to the browser process, and the browser kernel process handles the rest.</p><h3 id="cross-platform">Cross-platform resource fetching <a href="#cross-platform">#</a> <a href="#toc">↑</a></h3><p><img src="https://1-ps.googleusercontent.com/s/www.igvita.com/posts/13/posa/xchrome-platforms.png.pagespeed.ic.DOWxyhe2Xq.jpg" width="200" height="161" />One of the chief concerns in the implementation of Chrome's network stack is portability across many different platforms: Linux, Windows, OS X, Chrome OS, Android, and iOS. To address this challenge, <strong>the network stack is implemented as a mostly single-threaded (there are separate cache and proxy threads), cross-platform library</strong>, which allows Chrome to reuse the same infrastructure and provide the same performance optimizations, as well as a greater opportunity for optimization across all platforms.</p><p>All of the network code is, of course, open source and can be found in <a href="https://code.google.com/p/chromium/codesearch#chromium/src/net/&amp;ct=rc&amp;cd=1&amp;q=src.net&amp;sq=package:chromium">the "src/net" subdirectory</a>. We won't examine each component in detail, but the layout of the code itself tells you a lot about its capabilities and structure. A few examples:</p><table border="1" width="100%">
<tr>
<td>net/android</td>
<td>Bindings to the Android runtime</td>
</tr>
<tr>
<td>net/base</td>
<td>Common net utilities, such as host resolution, cookies, network change detection, and SSL certificate management</td>
</tr>
<tr>
<td>net/cookies</td>
<td>Implementation of storage, management, and retrieval of HTTP cookies</td>
</tr>
<tr>
<td>net/disk_cache</td>
<td>Disk and memory cache implementation for web resources</td>
</tr>
<tr>
<td>net/dns</td>
<td>Implementation of an asynchronous DNS resolver</td>
</tr>
<tr>
<td>net/http</td>
<td>HTTP protocol implementation</td>
</tr>
<tr>
<td>net/proxy</td>
<td>Proxy (SOCKS and HTTP) configuration, resolution, script fetching, ...</td>
</tr>
<tr>
<td>net/socket</td>
<td>Cross-platform implementations of TCP sockets, SSL streams, and socket pools</td>
</tr>
<tr>
<td>net/spdy</td>
<td>SPDY protocol implementation</td>
</tr>
<tr>
<td>net/url_request</td>
<td>URLRequest, URLRequestContext, and URLRequestJob implementations</td>
</tr>
<tr>
<td>net/websockets</td>
<td>WebSockets protocol implementation</td>
</tr>
</table><p>Each of the above makes for a great read for the curious - the code is well documented, and you'll find plenty of unit tests for every component.</p><h3 id="mobile">Architecture and performance on mobile platforms <a href="#mobile">#</a> <a href="#toc">↑</a></h3><p><img src="https://1-ps.googleusercontent.com/s/www.igvita.com/posts/13/posa/xchrome-android.png.pagespeed.ic.N5-9Gn3Gje.png" width="165" height="217" />Mobile browser usage is growing at an exponential rate and even by modest projections, it will eclipse desktop browsing in the not so distant future. Needless to say, delivering an optimized mobile experience has been a top priority for the Chrome team. In early 2012, <a href="http://www.google.com/intl/en/chrome/browser/mobile/android.html">Chrome for Android</a> was announced, and a few months later, <a href="http://www.google.com/intl/en/chrome/browser/mobile/ios.html">Chrome for iOS</a> followed.</p><p><strong>The first thing to note about the mobile version of Chrome, is that it's not simply a direct adaptation of the desktop browser</strong> - that would not deliver the best user experience. By its very nature, the mobile environment is both much more resource constrained, and has many fundamentally different operating parameters:</p><ul>
<li>Desktop users navigate with the mouse, may have overlapping windows, have a large screen, are mostly not power constrained, usually have a much more stable network connection, and have access to much larger pools of storage and memory.</li>
<li>Mobile users use touch and gesture navigation, have a much smaller screen, are battery and power constrained, are often on metered connections, and have limited local storage and memory.</li>
</ul><p>Further, there is no such thing as a <em>"typical mobile device"</em>. Instead there is a wide range of devices with varying hardware capabilities, and to deliver the best performance, Chrome must to adapt to the operating constraints of each and every device. Thankfully, the various execution models allow Chrome to do exactly that!</p><p><img src="https://1-ps.googleusercontent.com/s/www.igvita.com/posts/13/posa/xandroid-chrome.png.pagespeed.ic.Pw0razoLQY.png" width="150" height="119" /><strong>On Android devices, Chrome leverages the same multi-process architecture as the desktop version</strong> - there is a browser process, and one or more renderer processes. The one difference is that due to memory constraints of the mobile device, Chrome may not be able to run a dedicated renderer for each open tab. Instead, Chrome determines the optimal number of renderer processes based on available memory, and other constraints of the device, and shares the renderer process between the multiple tabs.</p><p>In cases where only minimal resources are available, or if Chrome is unable to run multiple processes, it can also switch to use a single-process, multi-threaded processing model. In fact, <strong>on iOS devices, due to sandboxing restrictions of the underlying platform, it does exactly that - it runs a single, but multi-threaded process.</strong></p><p>What about network performance? First off, <strong>Chrome uses the same network stack on Android and iOS, as it does on all other versions</strong>. This enables all of the same network optimizations across all platforms, which gives Chrome a significant performance advantage. However, what is different, and is often adjusted based on the capabilities of the device and the network in use, are variables such as priority of speculative optimization techniques, socket timeouts and management logic, cache sizes, and more.</p><p>For example, to preserve battery, mobile Chrome may opt-in to use lazy closing of idle sockets - sockets are closed only when opening new ones to minimize radio use. Similarly, since prerendering (which we will discuss below), may require significant network and processing resources, it is often only enabled when the user is on Wi-Fi.</p><p>Optimizing the mobile browsing experience is one of the highest priority items for the Chrome development team, and we can expect to see <em>a lot of new improvements</em> in the months and years to come. In fact, it is a topic that deserves its own separate chapter - perhaps in the next installment of the POSA series!</p><h3 id="predictor">Speculative optimization with Chrome's Predictor <a href="#predictor">#</a> <a href="#toc">↑</a></h3><p><img src="https://1-ps.googleusercontent.com/s/www.igvita.com/posts/13/posa/xchrome-wings.png.pagespeed.ic.CminED5UUn.png" width="141" height="83" /><strong>Chrome gets faster as you use it.</strong> This feat is accomplished with the help of a singleton <code>Predictor</code> object, which is instantiated within the browser kernel process, and whose sole responsibility is to observe network patterns and to learn and anticipate likely user actions in the future. A few example signals processed by the <code>Predictor</code> include:</p><ul>
<li>Users hovering their mouse over a link is a good indicator of a likely, upcoming navigation event, which Chrome can help accelerate by dispatching a speculative DNS lookup of the target hostname, as well as potentially starting the TCP handshake. By the time the user clicks, which takes ~200 ms on average, there is a good chance that we have already completed the DNS and TCP steps, allowing us to eliminate hundreds of milliseconds of extra latency for the navigation event.</li>
<li>Typing in the Omnibox (URL) bar triggers high-likelihood suggestions, which may similarly kick off a DNS lookup, TCP pre-connect, and can even pre-render the page in a hidden tab!</li>
<li>Each one of us has a list of favorite sites that we visit every day. Chrome can learn the subresources on these sites and speculatively pre-resolve and perhaps even pre-fetch them to accelerate the browsing experience.
And the list goes on...</li>
</ul><p>Chrome learns the topology of the web, as well as your own browsing patterns, as you use it. If it does the job well, it can eliminate hundreds of milliseconds of latency from each navigation and get the user closer to the holy grail of the "instant page load". To achieve this goal, Chrome leverages four core optimization techniques:</p><table border="1" width="100%">
<tr>
<td width="25%">DNS pre-resolve</td>
<td>resolve hostnames ahead of time, to avoid DNS latency</td>
</tr>
<tr>
<td>TCP pre-connect</td>
<td>connect to destination server ahead of time, to avoid TCP handshake latency</td>
</tr>
<tr>
<td>Resource prefetching</td>
<td>fetch critical resources on the page ahead of time, to accelerate rendering of the page</td>
</tr>
<tr>
<td>Page prerendering</td>
<td>fetch the entire page with all of its resources ahead of time, to enable instant navigation when triggered by the user</td>
</tr>
</table><p>Each decision to invoke one or several of these techniques is optimized against a large number of constraints. After all, each is a speculative optimization, which means that if done poorly, it might trigger unnecessary work and network traffic, or even worse, have a negative effect on the loading time for an actual navigation triggered by the user.</p><p>How does Chrome address this problem? <strong>The predictor consumes as many signals as it can, which include user generated actions, historical browsing data, as well as signals from the renderer and the network stack itself.</strong></p><p>Not unlike the <code>ResourceDispatcherHost</code>, which is responsible for coordinating all of the network activity within Chrome, the <code>Predictor</code> object creates a number of filters on user and network generated activity within Chrome:</p><ul>
<li>IPC channel filter to monitor for signals from the render processes</li>
<li><code>ConnectInterceptor</code> object is added to each request, such that it can observe the traffic patterns and record success metrics for each request</li>
</ul><p>As a hands on example, the render process can trigger a message to the browser process with any of the following hints, which are conveniently defined in <code>ResolutionMotivation</code> (<a href="http://code.google.com/searchframe#OAMlx_jo-ck/src/chrome/browser/net/url_info.h&amp;l=35">url_info.h</a>):</p><div><pre><code><span>enum</span> <span>ResolutionMotivation</span> <span>{</span>
  <span>MOUSE_OVER_MOTIVATED</span><span>,</span>     <span>// Mouse-over initiated by the user.</span>
  <span>OMNIBOX_MOTIVATED</span><span>,</span>        <span>// Omni-box suggested resolving this.</span>
  <span>STARTUP_LIST_MOTIVATED</span><span>,</span>   <span>// This resource is on the top 10 startup list.</span>
  <span>EARLY_LOAD_MOTIVATED</span><span>,</span>     <span>// In some cases we use the prefetcher to warm up</span>
                            <span>// the connection in advance of issuing the real</span>
                            <span>// request.</span>

  <span>// The following involve predictive prefetching, triggered by a navigation.</span>
  <span>// The referring_url_ is also set when these are used.</span>
  <span>STATIC_REFERAL_MOTIVATED</span><span>,</span>  <span>// External database suggested this resolution.</span>
  <span>LEARNED_REFERAL_MOTIVATED</span><span>,</span> <span>// Prior navigation taught us this resolution.</span>
  <span>SELF_REFERAL_MOTIVATED</span><span>,</span>    <span>// Guess about need for a second connection.</span>

  <span>// &lt;snip&gt; ...</span>
<span>};</span>
</code></pre></div><p>Given such a signal, the goal of the predictor is to evaluate the likelihood of its success, and then to trigger the activity if resources are available. Every hint may have a likelihood of success, a priority, and an expiration timestamp, the combination of which can be used to maintain an internal priority queue of speculative optimizations. Finally, for every dispatched request from within this queue, the predictor is also able to track its success rate, which allows it to further optimize its future decisions.</p><h3 id="nutshell">Chrome network architecture in a nutshell <a href="#nutshell">#</a> <a href="#toc">↑</a></h3><ul>
<li>Chrome uses a <strong>multi-process architecture</strong>, which isolates render processes from the browser process</li>
<li>Chrome maintains a <strong>single instance of the resource dispatcher</strong>, which is shared across all render processes, and runs within the browser kernel process</li>
<li>The network stack is a <strong>cross-platform</strong>, (mostly) single-threaded library</li>
<li>The network stack uses <strong>non-blocking</strong> operations to manage all network operations</li>
<li>Shared network stack allows efficient resource prioritization, reuse, and provides the browser with ability to perform global optimization across all running processes</li>
<li>Each render process communicates with the resource dispatcher via IPC</li>
<li>Resource dispatcher intercepts resource requests via a custom IPC filter</li>
<li>Predictor intercepts resources request and response traffic to learn and optimize future network requests</li>
<li><strong>Predictor may speculatively schedule DNS, TCP, and even resource requests</strong> based on learned traffic patterns, saving hundreds of milliseconds when the navigation is triggered by the user</li>
</ul><h2 id="lifetime">Lifetime of your browser session... <a href="#lifetime">#</a> <a href="#toc">↑</a></h2><p>With the 10,000 foot architecture view of the Chrome network stack in mind, let's now take a closer look at the kinds of user-facing optimizations enabled within the browser. Specifically, let's imagine we have just created a new Chrome profile and are ready to start our day.</p><h3 id="cold-boot">Optimizing the cold-boot experience <a href="#cold-boot">#</a> <a href="#toc">↑</a></h3><p><img src="https://1-ps.googleusercontent.com/s/www.igvita.com/posts/13/posa/xchrome-user.png.pagespeed.ic.2UwVZX2Kcw.png" width="115" height="115" />The first time you load your browser, it of course knows little about your favorite sites or navigation patterns. But, as it turns out, <strong>many of us follow the same routine after a cold-boot of the browser</strong>, where we may navigate to our email inbox, favorite news site, a social site, an internal portal, and so on. The specific sites will, of course, vary, but the similarity of all these sessions allows the Chrome predictor to accelerate your cold-boot experience!</p><p><strong>Chrome remembers the top ten likely hostnames accessed by the user following the browser start</strong> - note that this is not the top ten global destinations, but specifically the destinations following a fresh browser start. As the browser loads, Chrome can trigger a DNS pre-fetch for the likely destinations! If you are curious, you can inspect your own startup hostname list by opening a new tab and navigating to <code>chrome://dns</code>. At the top of the page, you will find the list of the top ten likely startup candidates for your profile.</p><p><img src="https://1-ps.googleusercontent.com/s/www.igvita.com/posts/13/posa/xstartup-dns.png.pagespeed.ic.MtWtaQBCP7.png" /></p><p>Above screenshot is an example from my own Chrome profile. How do I usually begin my browsing? Frequently by navigating to Google Docs if I'm working on an article such at this one. Not surprisingly, we see a lot of Google hostnames in the list!</p><h3 id="omnibox">Optimizing interactions with the Omnibox <a href="#omnibox">#</a> <a href="#toc">↑</a></h3><p><img src="https://1-ps.googleusercontent.com/s/www.igvita.com/posts/13/posa/xchrome-omnibox.png.pagespeed.ic.IhTjrD_nMj.png" width="200" height="117" />One of the innovations of Chrome was the introduction of the Omnibox, which unlike its predecessors handles much more than just destination URLs. Besides remembering the URLs of pages that the user visited in the past, it also offers full text search over your history <em>(tip: instead of the URL, try typing the name of the page you've recently visited)</em>, as well as a tight integration with the search engine of your choice.</p><p>As the user types, the Omnibox automatically proposes an action, which is either a URL based on your navigation history, or a search query. Under the hood, each proposed action is scored with respect to the query, as well as its past performance. In fact, Chrome allows us to inspect this data by visiting <code>chrome://predictors</code>.</p><p><img src="https://1-ps.googleusercontent.com/s/www.igvita.com/posts/13/posa/xomnibox.png.pagespeed.ic.XTAAgoXOj1.png" /></p><p><strong>Chrome maintains a history of the user entered prefixes, the actions it has proposed, as well as the hit rate for each one.</strong> For my own profile, you can see that whenever I enter "g" in the Omnibox, there is a 76% chance that I'm heading to Gmail. Once I add an "m" (for "gm"), then the confidence rises to 99.8% - in fact, out of the 412 recorded visits, I didn't end up going to Gmail, after entering "gm" only once!</p><p>But, you're thinking, what does this have to do with the network stack? Well, the yellow and green colors for the likely candidates are also important signals for the <code>ResourceDispatcher</code>! If we have a likely candidate (yellow), Chrome may trigger a DNS pre-fetch for the target host. If we have a high confidence candidate (green), then Chrome may also trigger a TCP pre-connect once the hostname has been resolved. And finally, if both complete while the user is still deliberating, then Chrome may even pre-render the entire page in a hidden tab.</p><p>Alternatively, if there is no good match for the entered prefix based on past navigation history, then Chrome may issue a DNS pre-fetch and TCP pre-connect to your search provider, in anticipation of a likely search request.</p><p><strong>An average user takes hundreds of milliseconds to fill in their query and to evaluate the proposed autocomplete suggestions.</strong> In the background, Chrome is able to pre-fetch, pre-connect, and in certain cases even pre-render the page, such that by the time the user is ready to hit the "enter" key, much of the network latency has already been eliminated!</p><h3 id="cache">Optimizing cache performance <a href="#cache">#</a> <a href="#toc">↑</a></h3><p>The best, and the fastest request, is a request not made. Whenever we talk about performance, we would be amiss if we didn't talk about the cache -- you are providing <em>Expires</em>, <em>ETag</em>, <em>Last-Modified</em>, and <em>Cache-Control</em> <a href="https://developers.google.com/speed/docs/best-practices/caching">response headers</a> for all the resources on your pages, right? If not, stop, go fix it, we'll wait.</p><p><img src="https://1-ps.googleusercontent.com/s/www.igvita.com/posts/13/posa/xchrome-incognito.png.pagespeed.ic.6iyTvuqqQ4.jpg" width="200" height="135" />Chrome has two different implementations of the internal cache: one backed by local disk, and second which stores everything in memory. <strong>The in-memory implementation is used for the <a href="http://support.google.com/chrome/bin/answer.py?hl=en&amp;answer=95464">Incognito browsing mode</a> and is wiped clean whenever you close the window</strong>. Both implement the same internal interface (<code>disk_cache::Backend</code>, and <code>disk_cache::Entry</code>), which greatly simplifies the architecture - and if you are so inclined, allows you to easily experiment with your own, experimental cache implementations.</p><p>Internally, the disk cache implements its own set of data structures, all of which are stored within a single cache folder for your profile. Inside this folder, there are index files, which are memmapped when the browser starts, and data files which store the actual data, alongside the HTTP headers and other bookkeeping information. As an interesting sidenote, resources up to 16KB in size are stored in shared data block-files, and larger files get their own dedicated files on disk. Finally, for eviction, the disk cache maintains an LRU which uses ranking metrics such as frequency of access and age of resource into account.</p><p><img src="/posts/13/posa/internals-cache.png" /></p><p>If you are ever curious about the state of the Chrome cache, open a new tab and navigate to <code>chrome://net-internals/#httpCache</code>. Alternatively, if you want to see the actual HTTP metadata and the cached response, you can also visit <code>chrome://cache</code>, which will enumerate all of the resources currently available in the cache. From that page, search for a resource you're looking for and click on the URL to see the exact, cached headers and response bytes.</p><h3 id="dns-prefetching">Optimizing DNS with prefetching <a href="#dns-prefetching">#</a> <a href="#toc">↑</a></h3><p>We have already mentioned DNS pre-resolution on several occasions, so before we dive into the implementation, let's review the cases in which it may be triggered, and why:</p><ul>
<li>The Blink document parser, which runs in the render process, may provide a list of hostnames for all the links on the current page, which Chrome may, or may not choose to pre-resolve ahead of time.</li>
<li>Renderer process may trigger a mouse hover or "button down" event as an early signal of user's intent to perform a navigation.</li>
<li>The Omnibox may trigger a resolve request based on a high likelihood suggestion.</li>
<li>Chrome predictor may request hostname resolution based on past navigation and resource request data - more on this below.</li>
<li>The owner of the page may explicitly indicate to Chrome which hostnames it should pre-resolve.</li>
</ul><p><strong>In all cases, DNS pre-resolution is treated as a hint</strong>. Chrome does not guarantee that the pre-resolution will occur, rather it uses each signal in combination with its own predictor to assess the hint and decide on a course of action. In the "worst case", if we weren't able to pre-resolve the hostname in time, the user would have to wait for an explicit DNS resolution, followed by TCP connection time, and finally the actual resource fetch. However, when this occurs, the predictor can take note and adjust its future decisions accordingly - it gets faster, and smarter, as you use it.</p><p>One of the optimizations we have not covered previously is the <strong>ability of Chrome to learn the topology of each site and then use this information to accelerate future visits</strong>. Specifically, recall that an average page consists of 88 resources, which are delivered from 30+ distinct hosts. Well, each time you perform a navigation, Chrome may record the hostnames for the popular resources on the page, and during a future visit, it may choose to trigger a DNS pre-resolve and even a TCP pre-connect for some, or all of them!</p><p><img src="https://1-ps.googleusercontent.com/s/www.igvita.com/posts/13/posa/xsubresource-stats.png.pagespeed.ic.Fhq94BZe4g.png" /></p><p>To inspect the subresource hostnames stored by Chrome, navigate to <code>chrome://dns</code> and search for any popular destination hostname for your profile. In the example above, you can see the six subresource hostnames that Chrome remembered for Google+, as well as stats for the number of cases when a DNS pre-resolution was triggered, or a TCP pre-connect was performed, as well as an expected number of requests that will be served by each. This internal accounting is what enables the Chrome predictor to perform its optimizations.</p><p>In addition to all of the internal signals, the owner of the site is also able to embed additional markup on their pages to request the browser to pre-resolve a hostname:</p><div><pre><code>  <span>&lt;link</span> <span>rel=</span><span>"dns-prefetch"</span> <span>href=</span><span>"//host_name_to_prefetch.com"</span><span>&gt;</span>
</code></pre></div><p>Why not simply rely on the automated machinery in the browser? <strong>In some cases, you may want to pre-resolve a hostname which is not mentioned anywhere on the page</strong>. The canonical example is, of course, redirects: a link may point to a host, like an analytics tracking service, which then redirects the user to the actual destination. By itself, Chrome cannot infer this pattern, but you can help it by providing a manual hint and get the browser to resolve the hostname of the actual destination ahead of time.</p><p>So, how is this all implemented under the hood? The answer to this question, just like all other optimizations we have covered, depends on the version of Chrome, since the team is <em>always</em> experimenting with new and better ways to improve performance. However, broadly speaking, the DNS infrastructure within Chrome has two major implementations: historically, Chrome has relied on the platform-independent <code>getaddrinfo()</code> system call, and delegated the actual responsibility for the lookups to the operating system, however this approach is in the process of being replaced with <strong>Chrome's own implementation of an asynchronous DNS resolver</strong>.</p><p>The original implementation, which relied on the operating system, has its benefits: less and simpler code, and the ability to leverage the operating system's DNS cache. However, <code>getaddrinfo()</code> is also a blocking system call, which meant that Chrome had to create and maintain a dedicated worker thread-pool to allow it to perform multiple lookups in parallel. <strong>This unjoined pool was capped at six worker threads</strong>, which is an empirical number based on lowest common denominator of hardware - turns out, higher numbers of parallel requests can overload some users' routers!</p><p>For pre-resolution with the worker-pool, Chrome simply dispatches the <code>getaddrinfo()</code> call, which blocks the worker thread until the response is ready, at which point it just discards the returned result and begins processing the next prefetch request. <em>Discards it?</em> The result is cached by the OS DNS cache, which returns an immediate response to future, actual <code>getaddrinfo()</code> lookups. Simple, effective, works well enough in practice.</p><p><strong>Well, effective, but not good enough!</strong> The <code>getaddrinfo()</code> call hides a lot of useful information from Chrome, such as the time-to-live (TTL) timestamps for each record, as well as the state of the DNS cache itself. To improve performance, Chrome team decided to implement their own, cross-platform, asynchronous DNS resolver.</p><p><img src="https://1-ps.googleusercontent.com/s/www.igvita.com/posts/13/posa/xasync-dns.png.pagespeed.ic.uyj05Stae1.png" /></p><p>By moving DNS resolution into Chrome the new async resolver enables a number of new optimizations:</p><ul>
<li>better control of retransmission timers, and ability to execute multiple queries in parallel</li>
<li>visibility into record TTLs, which allows Chrome to refresh popular records ahead of time</li>
<li>better behavior for dual stack implementations (IPv4 and IPv6)</li>
<li>failovers to different servers, based on RTT or other signals</li>
</ul><p>All of the above, and more, are ideas for continuous experimentation and improvement within Chrome. Which brings us to the obvious question: <em>how do we know and measure the impact of these ideas?</em> Simple, <strong>Chrome tracks detailed network performance stats and histograms for each individual profile</strong>. To inspect the collected DNS metrics, open a new tab, and head to <code>chrome://histograms/DNS</code>.</p><p><img src="https://1-ps.googleusercontent.com/s/www.igvita.com/posts/13/posa/xdns-prefetch.png.pagespeed.ic.P5vBcMlRod.png" /></p><p>The above histogram shows the distribution of latencies for DNS prefetch requests: roughly 50% (rightmost column) of the prefetch queries were finished within 20ms (leftmost column). Note that this is data based on a recent browsing session (9869 samples), and is private to the user. If the user has opted in to report their usage stats in Chrome, then the summary of this data is anonymized and periodically beaconed back to the engineering team, which is then able to see the impact of their experiments and adjust accordingly. <em>Rinse, lather, repeat.</em></p><h3 id="tcp-pre-connect">Optimizing TCP connection management with pre-connect <a href="#tcp-pre-connect">#</a> <a href="#toc">↑</a></h3><p>We have pre-resolved the hostname and we have a high likelihood navigation event that's about to happen, as estimated by the Omnibox, or the Chrome predictor. <strong>Why not go one step further, and also speculatively pre-connect to the destination host and complete the TCP handshake before the user dispatches the request?</strong> By doing so, we can eliminate another full round-trip of latency delay, which can easily save hundreds of milliseconds for the user. Well, that's exactly what TCP-preconnect is and how it works!</p><p>To see the hosts for which a TCP preconnect has been triggered, open a new tab and visit <code>chrome://dns</code>.</p><p><img src="https://1-ps.googleusercontent.com/s/www.igvita.com/posts/13/posa/xpreconnect.png.pagespeed.ic.OzISsBOLWV.png" /></p><p>First, Chrome checks its socket pools to see if there is an available socket for the hostname, which it may be able to reuse - keep-alive sockets are kept in the pool for some period of time, to avoid the TCP handshake and slow-start penalties. If no socket is available, then it can initiate the TCP handshake, and place it in the pool. Then, when the user initiates the navigation, the HTTP request can be dispatched immediately.</p><p>Curious to see the state of all the open sockets in Chrome? Simple, head to: <code>chrome://net-internals#sockets</code></p><p><img src="/posts/13/posa/netinternals-sockets.png" /></p><p>Note that you can also drill into each socket and inspect the timeline: connect and proxy times, arrival times for each packet, and more. Last but not least, you can also export this data for further analysis or a bug report. Having <strong>good instrumentation is key to any performance optimization, and <code>chrome://net-internals</code> is the nexus of all things networking in Chrome</strong> - if you haven't explored it yet, you should!</p><h3 id="prefetching">Optimizing resource loading with prefetch hints <a href="#prefetching">#</a> <a href="#toc">↑</a></h3><p>Sometimes, the author of a page is able to provide additional navigation, or page context, based on the structure or the layout of their site, and help the browser optimize the experience for the user. Chrome supports two such hints, which can be embedded in the markup of the page:</p><div><pre><code>  <span>&lt;link</span> <span>rel=</span><span>"subresource"</span> <span>href=</span><span>"/javascript/myapp.js"</span><span>&gt;</span>
  <span>&lt;link</span> <span>rel=</span><span>"prefetch"</span>    <span>href=</span><span>"/images/big.jpeg"</span><span>&gt;</span>
</code></pre></div><p><strong>Subresource and prefetch look very similar, but have very different semantics</strong>. When a link resource specifies its relationship as "prefetch", it is an indication to the browser that this resource might be needed in a future navigation. In other words, effectively it is a cross-page hint. By contrast, when a resource specifies the relationship as a "subresource", it is an early indication to the browser that the resource will be used on a current page, and that it may want to dispatch the request before it encounters it later in the document.</p><p>As you would expect, the different semantics of the hints lead to very different behavior by the resource loader. Resources marked with prefetch are considered low priority and might be downloaded by the browser only once the current page has finished loading. Whereas subresource resources are fetched with high priority as soon as they are encountered and will compete with the rest of the resources on the current page.</p><p>Both hints, when used well and in the right context, can help significantly with optimizing the user experience on your site. Finally, it is also important to note that prefetch is <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/links.html#link-type-prefetch">part of the HTML5 spec</a>, and as of today supported by Firefox and Chrome, whereas subresource is currently <a href="http://www.chromium.org/spdy/link-headers-and-server-hint/link-rel-subresource">only available in Chrome</a>.</p><h3 id="prefreshing">Optimizing resource loading with browser prefreshing <a href="#prefreshing">#</a> <a href="#toc">↑</a></h3><p>Unfortunately, not all site owners are able or willing to provide the browser with subresource hints in their markup. Further, even if they do, we must wait for the HTML document to arrive from the server before we are able to parse the hints and begin fetching the necessary subresources - depending on the server response time, as well as the latency between the client and the server, this could take hundreds and even thousands of milliseconds.</p><p>However, as we saw earlier, Chrome is already learning the hostnames of the popular resources to perform DNS pre-fetching. So, why couldn't it do the same, but go one step further and perform the DNS lookup, use TCP preconnect, and then also speculatively prefetch the resource? Well, that's exactly what "prefreshing" could do:</p><ul>
<li>User initiates a request to a target URL</li>
<li>Chrome queries its Predictor for learned subresources associated with target URL and initiates the sequence of DNS prefetch, TCP preconnect, and resource prefreshing</li>
<li>If the learned subresource is in the cache, then its loaded from disk and into memory</li>
<li>If the learned subresource is missing, or has expired, then a network request is made</li>
</ul><p><img src="https://1-ps.googleusercontent.com/s/www.igvita.com/posts/13/posa/xchrome-experiment.png.pagespeed.ic.8Z0nXW5Gwd.png" width="252" height="151" />Resource prefreshing is a great example of the workflow of every experimental optimization in Chrome - in theory, it should enable better performance, but there are many tradeoffs as well. There is only one way to reliably determine if it will make the cut and make it into Chrome: implement it and run it as A/B experiment in some of the pre-release channels with real users, on real networks, with real browsing patterns.</p><p>As of early 2013, the Chrome team is in the early stages of discussing the implementation. If it makes the cut based on gathered results, we may see prefreshing in Chrome sometime later in the year. <strong>The process of improving Chrome network performance never stops, the team is always experimenting with new approaches, ideas, and techniques.</strong></p><h3 id="prerendering">Optimizing navigation with prerendering <a href="#prerendering">#</a> <a href="#toc">↑</a></h3><p>Each and every optimization we have covered up to now helps reduce the latency between the user's direct request for a navigation and the resulting page rendering in their tab. However, <strong>what would it take to have a truly instant experience?</strong> Based on the UX data we saw earlier, this interaction would have to happen in less than 100 milliseconds, which doesn't leave much room for network latency at all. What could we do to deliver a rendered page in sub 100 milliseconds?</p><p>Of course, you already know the answer, since this is a common pattern employed by many users: if you open multiple tabs then switching between tabs is instant and is definitely much faster than waiting for the navigation between the same resources in a single foreground tab. Well, what if the browser provided an API to do this?</p><div><pre><code>  <span>&lt;link</span> <span>rel=</span><span>"prerender"</span> <span>href=</span><span>"http://example.org/index.html"</span><span>&gt;</span>
</code></pre></div><p>You guessed it, that's <a href="https://developers.google.com/chrome/whitepapers/prerender">prerendering in Chrome</a>! Instead of just downloading a single resource, as the "prefetch" hint would have done, the "prerender" attribute indicates to Chrome that it should, well, prerender the page in a hidden tab, along with all of its subresources. <strong>The hidden tab itself is invisible to the user, but when the user triggers the navigation, the tab is swapped in from the background for an "instant experience".</strong></p><p>Curious to try it out? You can visit <a href="http://prerender-test.appspot.com">prerender-test.appspot.com</a> for a hands on demo, and see the history and status of the prerendered pages for your profile by visiting: <code>chrome://net-internals/#prerender</code></p><p><img src="/posts/13/posa/netinternals-prerender.png" /></p><p>As you would expect, rendering an entire page in a hidden tab can consume a lot of resources, both CPU and network, and hence should only be used in cases where we have high confidence that the hidden tab will be used! For example, when you are using the Omnibox, a prerender may be triggered for the a high confidence suggestion. Similarly, Google Search sometimes adds the prerender hint to its markup if it estimates that the first search result is a highly confidence destination (aka, Google Instant Pages):</p><p><strong>Note that you can also add prerender hints to your own site!</strong> However, before you do, note that prerendering has a number of restrictions and limitations, which you should keep in mind:</p><ul>
<li>At most one prerender tab is allowed across all processes</li>
<li>HTTPS and pages with HTTP authentication are not allowed</li>
<li>Prerendering is abandoned if the requested resource, or any of its subresources need to make a non-idempotent request (only GET requests allowed)</li>
<li>All resources are fetched with lowest network priority</li>
<li>The page is rendered with lowest CPU priority</li>
<li>The page is abandoned if memory requirements exceed 100MB</li>
<li>Plugin initialization is deferred, and pre-rendering is abandoned if an HTML5 media element is present</li>
</ul><p>In other words, prerendering is not guaranteed to happen and only applies to pages where it is safe. Additionally, since JavaScript and other logic may be executed within the hidden page, it is best practice to leverage the <a href="https://developers.google.com/chrome/whitepapers/pagevisibility">Page Visibility API</a> to detect if the page is visible - which is something you <a href="http://www.html5rocks.com/en/tutorials/pagevisibility/intro/">should be doing anyway</a>!</p><h2 id="faster">Chrome gets faster as you use it <a href="#faster">#</a> <a href="#toc">↑</a></h2><p><img src="https://1-ps.googleusercontent.com/s/www.igvita.com/posts/13/posa/xchrome-speed.png.pagespeed.ic.MlwkPfGQ4n.png" width="217" height="267" />Needless to say, Chrome's network stack is much more than a simple socket manager. Our whirlwind tour covered the many levels of potential optimizations that are performed transparently in the background, as you navigate the web. The more Chrome learns about the topology of the web and your browsing patterns, the better it can do its job. <strong>Almost like magic, Chrome gets faster as you use it. Except, it's not magic, because now you know how it works!</strong></p><p>Finally, it is important to note that the Chrome team continues to iterate and experiment with new ideas to improve performance - this process never stops. By the time you read this, chances are there will be new experiments and optimizations being developed, tested, or deployed. Perhaps once we reach our target destination of instant page loads (&lt;100 ms), for each and every page, then we can take a break. Until then, there is always more work to do!</p><div><img src="https://1-ps.googleusercontent.com/s/www.igvita.com/images/35x35xigrigorik-small.png.pagespeed.ic._Nz4w6PPkg.jpg" alt="Ilya Grigorik" height="35px" width="35px" /><strong>Ilya Grigorik</strong><p style="display: inline;"> is a web performance engineer and developer advocate at Google, where his focus is on making the web fast and driving adoption of performance best practices — </p><a href="/">learn more</a><p style="display: inline;">, follow on </p><a href="https://twitter.com/igrigorik">Twitter</a><p style="display: inline;"> (29K), </p><a href="https://plus.google.com/+IlyaGrigorik">Google+</a><p style="display: inline;"> (18K).
</p></div></div></div>
<script>var _gaq = _gaq || []; _gaq.push(['_setAccount', 'UA-34802167-1']); _gaq.push(['_setDomainName', 'liuzhe.co']); _gaq.push(['_trackPageview']); (function() { var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true; ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'; var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s); })();</script></body>
</html>