
        <!doctype html>
        <html>
        <head>
            <meta charset="utf-8"/>
            <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
            <title>Railway oriented programming</title>
            <link rel="stylesheet" href="../css/article.css" />;
        </head>
        <body>
            <div class="m-content">
            <h1>Railway oriented programming</h1>
            <div class="span8"><span>


	</span><div><span>
		</span><h5>
		Part of the "A recipe for a functional app" series (<a href="http://fsharpforfunandprofit.com/posts/recipe-part2/#series-toc" title="The &quot;A recipe for a functional app&quot; series ">more</a>)
		</h5><span>
	</span></div><span>





	</span><span>

	
	</span><p><em>UPDATE: <a href="http://fsharpforfunandprofit.com/rop/">Slides and video from a more comprehensive presentation available here</a> (and if you understand the Either monad, <a href="http://fsharpforfunandprofit.com/rop/#monads">read this first</a>!)</em></p><span>

</span><p>In the previous post, we saw how a use case could be broken into steps, and all the errors shunted off onto a separate error track, like this:</p><span>

</span><p><img src="http://fsharpforfunandprofit.com/assets/img/Recipe_Function_ErrorTrack.png" alt="A function with two outputs"></p><span>

</span><p>In this post, we'll look at various ways of connecting these step functions into a single unit.  The detailed internal design of the functions will be described in a later post.</p><span>

</span><h2>Designing a function that represents a step</h2><span>

</span><p>Let's have a closer look at these steps. For example, consider the validation function. How would it work?  Some data goes in, but what comes out?</p><span>

</span><p>Well, there are two possible cases: either the data is valid (the happy path), or something is wrong, in which case we go onto the failure path and bypass the rest of the steps, like this:</p><span>

</span><p><img src="http://fsharpforfunandprofit.com/assets/img/Recipe_Validation_Paths.png" alt="The validation function with a two outputs"></p><span>

</span><p>But as before, this would not be a valid function. A function can only have one output, so we must use the <code>Result</code> type we defined last time:</p><span>

</span><div class="highlight"><pre><code class="fsharp"><span class="k">type</span> <span class="nc">Result</span><span class="o">&lt;</span><span class="k">'</span><span class="nc">TSuccess</span><span class="o">,</span><span class="k">'</span><span class="nc">TFailure</span><span class="o">&gt;</span> <span class="o">=</span> 
    <span class="o">|</span> <span class="nc">Success</span> <span class="k">of</span> <span class="k">'</span><span class="nc">TSuccess</span>
    <span class="o">|</span> <span class="nc">Failure</span> <span class="k">of</span> <span class="k">'</span><span class="nc">TFailure</span>
</code></pre><span>
</span></div><span>


</span><p>And the diagram now looks like this:</p><span>

</span><p><img src="http://fsharpforfunandprofit.com/assets/img/Recipe_Validation_Union2.png" alt="The validation function with a success/failure output"></p><span>

</span><p>To show you how this works in practice, here is an example of what an actual validation function might look like:</p><span>

</span><div class="highlight"><pre><code class="fsharp"><span class="k">type</span> <span class="nc">Request</span> <span class="o">=</span> <span class="o">{</span><span class="n">name</span><span class="o">:</span><span class="kt">string</span><span class="o">;</span> <span class="n">email</span><span class="o">:</span><span class="kt">string</span><span class="o">}</span>

<span class="k">let</span> <span class="n">validateInput</span> <span class="n">input</span> <span class="o">=</span>
   <span class="k">if</span> <span class="n">input</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">""</span> <span class="k">then</span> <span class="nc">Failure</span> <span class="s2">"Name must not be blank"</span>
   <span class="k">else</span> <span class="k">if</span> <span class="n">input</span><span class="o">.</span><span class="n">email</span> <span class="o">=</span> <span class="s2">""</span> <span class="k">then</span> <span class="nc">Failure</span> <span class="s2">"Email must not be blank"</span>
   <span class="k">else</span> <span class="nc">Success</span> <span class="n">input</span>  <span class="c1">// happy path</span>
</code></pre><span>
</span></div><span>


</span><p>If you look at the type of the function, the compiler has deduced that it takes a <code>Request</code> and spits out a <code>Result</code> as output, with a <code>Request</code> for the success case and a <code>string</code> for the failure case:</p><span>

</span><div class="highlight"><pre><code class="fsharp"><span class="n">validateInput</span> <span class="o">:</span> <span class="nc">Request</span> <span class="o">-&gt;</span> <span class="nc">Result</span><span class="o">&lt;</span><span class="nc">Request</span><span class="o">,</span><span class="kt">string</span><span class="o">&gt;</span>
</code></pre><span>
</span></div><span>


</span><p>We can analyze the other steps in the flow in the same way. We will find that each one will have the same "shape" -- some sort of input and then this Success/Failure output.</p><span>

</span><p><em>A pre-emptive apology: Having just said that a function can't have two outputs, I may occasionally refer to them hereafter as "two output" functions! Of course, what I mean is that the shape of the function output has two cases.</em></p><span>

</span><h2>Railway oriented programming</h2><span>

</span><p>So we have a lot of these "one input -&gt; Success/Failure output" functions -- how do we connect them together?</p><span>

</span><p>What we want to do is connect the <code>Success</code> output of one to the input of the next, but somehow bypass the second function in case of a <code>Failure</code> output.  This diagram gives the general idea:</p><span>

</span><p><img src="http://fsharpforfunandprofit.com/assets/img/Recipe_Validation_Update.png" alt="Connecting validation function with update function"></p><span>

</span><p>There is a great analogy for doing this -- something you are probably already familiar with. Railways!</p><span>

</span><p>Railways have switches ("points" in the UK) for directing trains onto a different track. We can think of these "Success/Failure" functions as railway switches, like this:</p><span>

</span><p><img src="http://fsharpforfunandprofit.com/assets/img/Recipe_RailwaySwitch.png" alt="A railway switch"></p><span>

</span><p>And here we have two in a row.</p><span>

</span><p><img src="http://fsharpforfunandprofit.com/assets/img/Recipe_RailwaySwitch1.png" alt="2 railway switches disconnected"></p><span>

</span><p>How do we combine them so that both failure tracks are connected?  It's obvious -- like this!</p><span>

</span><p><img src="http://fsharpforfunandprofit.com/assets/img/Recipe_RailwaySwitch2.png" alt="2 railway switches connected"></p><span>

</span><p>And if we have a whole series of switches, we will end up with a two track system, looking something like this:</p><span>

</span><p><img src="http://fsharpforfunandprofit.com/assets/img/Recipe_RailwaySwitch3.png" alt="3 railway switches connected"></p><span>

</span><p>The top track is the happy path, and the bottom track is the failure path.</p><span>

</span><p>Now stepping back and looking at the big picture, we can see that we will have a series of black box functions that appear to be straddling a two-track railway, each function processing data and passing it down the track to the next function:</p><span>

</span><p><img src="http://fsharpforfunandprofit.com/assets/img/Recipe_Railway_Opaque.png" alt="Opaque functions"></p><span>

</span><p>But if we look inside the functions, we can see that there is actually a switch inside each one, for shunting bad data onto the failure track:</p><span>

</span><p><img src="http://fsharpforfunandprofit.com/assets/img/Recipe_Railway_Transparent.png" alt="Transparent functions"></p><span>

</span><p>Note that once we get on the failure path, we never (normally) get back onto the happy path. We just bypass the rest of the functions until we reach the end.</p><span>

</span><h2>Basic composition</h2><span>

</span><p>Before we discuss how to "glue" the step functions together, let's review how composition works.</p><span>

</span><p>Imagine that a standard function is a black box (a tunnel, say) sitting on a one-track railway. It has one input and one output.</p><span>

</span><p>If we want to connect a series of these one-track functions, we can use the left-to-right composition operator, with the symbol <code>&gt;&gt;</code>.</p><span>

</span><p><img src="http://fsharpforfunandprofit.com/assets/img/Recipe_Railway_Compose1.png" alt="Composition of one-track functions"></p><span>

</span><p>The same composition operation also works with two-track functions as well:</p><span>

</span><p><img src="http://fsharpforfunandprofit.com/assets/img/Recipe_Railway_Compose2.png" alt="Composition of two-track functions"></p><span>

</span><p>The only constraint on composition is that the output type of the left-hand function has to match the input type of the right-hand function.</p><span>

</span><p>In our railway analogy, this means that you can connect one-track output to one-track input, or two-track output to two-track input, but you <em>can't</em> directly connect two-track output to one-track input.</p><span>

</span><p><img src="http://fsharpforfunandprofit.com/assets/img/Recipe_Railway_Compose3.png" alt="Composition of two-track functions"></p><span>

</span><h2>Converting switches to two-track inputs</h2><span>

</span><p>So now we have run into a problem.</p><span>

</span><p>The function for each step is going to be a switch, with <em>one</em> input track.  But the overall flow requires a <em>two-track</em> system, with each function straddling <em>both</em> tracks, meaning that each function must have a two-track input (the <code>Result</code> output by the previous function), not just a simple one-track input (<code>Request</code>).</p><span>

</span><p>How can we insert the switches into the two track system?</p><span>

</span><p>The answer is simple. We can create an "adapter" function that has a "hole" or "slot" for a switch function and converts it into a proper two-track function. Here's an illustration:</p><span>

</span><p><img src="http://fsharpforfunandprofit.com/assets/img/Recipe_Railway_BindAdapter.png" alt="Bind adapter"></p><span>

</span><p>And here's what the actual code looks like. I'm going to name the adapter function <code>bind</code>, which is the standard name for it.</p><span>

</span><div class="highlight"><pre><code class="fsharp"><span class="k">let</span> <span class="n">bind</span> <span class="n">switchFunction</span> <span class="o">=</span> 
    <span class="k">fun</span> <span class="n">twoTrackInput</span> <span class="o">-&gt;</span> 
        <span class="k">match</span> <span class="n">twoTrackInput</span> <span class="k">with</span>
        <span class="o">|</span> <span class="nc">Success</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="n">switchFunction</span> <span class="n">s</span>
        <span class="o">|</span> <span class="nc">Failure</span> <span class="n">f</span> <span class="o">-&gt;</span> <span class="nc">Failure</span> <span class="n">f</span>
</code></pre><span>
</span></div><span>


</span><p>The bind function takes a switch function as a parameter and returns a new function. The new function takes a two-track input (which is of type <code>Result</code>) and then checks each case. If the input is a <code>Success</code> it calls the <code>switchFunction</code> with the value. But if the input is a <code>Failure</code>, then the switch function is bypassed.</p><span>

</span><p>Compile it and then look at the function signature:</p><span>

</span><div class="highlight"><pre><code class="fsharp"><span class="k">val</span> <span class="n">bind</span> <span class="o">:</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="nc">Result</span><span class="o">&lt;</span><span class="k">'</span><span class="n">b</span><span class="o">,</span><span class="k">'</span><span class="n">c</span><span class="o">&gt;)</span> <span class="o">-&gt;</span> <span class="nc">Result</span><span class="o">&lt;</span><span class="k">'</span><span class="n">a</span><span class="o">,</span><span class="k">'</span><span class="n">c</span><span class="o">&gt;</span> <span class="o">-&gt;</span> <span class="nc">Result</span><span class="o">&lt;</span><span class="k">'</span><span class="n">b</span><span class="o">,</span><span class="k">'</span><span class="n">c</span><span class="o">&gt;</span>
</code></pre><span>
</span></div><span>


</span><p>One way of interpreting this signature is that the <code>bind</code> function has one parameter, a switch function (<code>'a -&gt; Result&lt;..&gt;</code>) and it returns a fully two-track function (<code>Result&lt;..&gt; -&gt; Result&lt;..&gt;</code>) as output.</p><span>

</span><p>To be even more specific:</p><span>

</span><ul>
<li>The parameter (<code>switchFunction</code>) of bind takes some type <code>'a</code> and emits a <code>Result</code> of type <code>'b</code> (for the success track) and <code>'c</code> (for the failure track)</li>
<li>The returned function itself has a parameter (<code>twoTrackInput</code>) which is a <code>Result</code> of type <code>'a</code> (for success) and <code>'c</code> (for failure). The type <code>'a</code> has to be the same as what the <code>switchFunction</code> is expecting on its one track.</li>
<li>The output of the returned function is another <code>Result</code>, this time of type <code>'b</code> (for success) and <code>'c</code> (for failure) -- the same type as the switch function output.</li>
</ul><span>


</span><p>If you think about it, this type signature is exactly what we would expect.</p><span>

</span><p>Note that this function is completely generic -- it will work with <em>any</em> switch function and <em>any</em> types. All it cares about is the "shape" of the <code>switchFunction</code>, not the actual types involved.</p><span>

</span><h3>Other ways of writing the bind function</h3><span>

</span><p>Just as an aside, there are some other ways of writing functions like this.</p><span>

</span><p>One way is to use an explicit second parameter for the <code>twoTrackInput</code> rather than defining an internal function, like this:</p><span>

</span><div class="highlight"><pre><code class="fsharp"><span class="k">let</span> <span class="n">bind</span> <span class="n">switchFunction</span> <span class="n">twoTrackInput</span> <span class="o">=</span> 
    <span class="k">match</span> <span class="n">twoTrackInput</span> <span class="k">with</span>
    <span class="o">|</span> <span class="nc">Success</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="n">switchFunction</span> <span class="n">s</span>
    <span class="o">|</span> <span class="nc">Failure</span> <span class="n">f</span> <span class="o">-&gt;</span> <span class="nc">Failure</span> <span class="n">f</span>
</code></pre><span>
</span></div><span>


</span><p>This is exactly the same as the first definition. And if you are wondering how a two parameter function can be exactly the same as a one parameter function, you need to read the post on <a href="http://fsharpforfunandprofit.com/posts/currying/">currying</a>!</p><span>

</span><p>Yet another way of writing it is to replace the <code>match..with</code> syntax with the more concise <code>function</code> keyword, like this:</p><span>

</span><div class="highlight"><pre><code class="fsharp"><span class="k">let</span> <span class="n">bind</span> <span class="n">switchFunction</span> <span class="o">=</span> 
    <span class="k">function</span>
    <span class="o">|</span> <span class="nc">Success</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="n">switchFunction</span> <span class="n">s</span>
    <span class="o">|</span> <span class="nc">Failure</span> <span class="n">f</span> <span class="o">-&gt;</span> <span class="nc">Failure</span> <span class="n">f</span>
</code></pre><span>
</span></div><span>


</span><p>You might see all three styles in other code, but I personally prefer to use the second style (<code>let bind switchFunction twoTrackInput =</code>), because I think that having explicit parameters makes the code more readable for non-experts.</p><span>

</span><h2>Example: Combining some validation functions</h2><span>

</span><p>Let's write a little bit of code now, to test the concepts.</p><span>

</span><p>Let's start with what we already have defined. <code>Request</code>, <code>Result</code> and <code>bind</code>:</p><span>

</span><div class="highlight"><pre><code class="fsharp"><span class="k">type</span> <span class="nc">Result</span><span class="o">&lt;</span><span class="k">'</span><span class="nc">TSuccess</span><span class="o">,</span><span class="k">'</span><span class="nc">TFailure</span><span class="o">&gt;</span> <span class="o">=</span> 
    <span class="o">|</span> <span class="nc">Success</span> <span class="k">of</span> <span class="k">'</span><span class="nc">TSuccess</span>
    <span class="o">|</span> <span class="nc">Failure</span> <span class="k">of</span> <span class="k">'</span><span class="nc">TFailure</span>

<span class="k">type</span> <span class="nc">Request</span> <span class="o">=</span> <span class="o">{</span><span class="n">name</span><span class="o">:</span><span class="kt">string</span><span class="o">;</span> <span class="n">email</span><span class="o">:</span><span class="kt">string</span><span class="o">}</span>

<span class="k">let</span> <span class="n">bind</span> <span class="n">switchFunction</span> <span class="n">twoTrackInput</span> <span class="o">=</span> 
    <span class="k">match</span> <span class="n">twoTrackInput</span> <span class="k">with</span>
    <span class="o">|</span> <span class="nc">Success</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="n">switchFunction</span> <span class="n">s</span>
    <span class="o">|</span> <span class="nc">Failure</span> <span class="n">f</span> <span class="o">-&gt;</span> <span class="nc">Failure</span> <span class="n">f</span>
</code></pre><span>
</span></div><span>


</span><p>Next we'll create three validation functions, each of which is a "switch" function, with the goal of combining them into one bigger function:</p><span>

</span><div class="highlight"><pre><code class="fsharp"><span class="k">let</span> <span class="n">validate1</span> <span class="n">input</span> <span class="o">=</span>
   <span class="k">if</span> <span class="n">input</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">""</span> <span class="k">then</span> <span class="nc">Failure</span> <span class="s2">"Name must not be blank"</span>
   <span class="k">else</span> <span class="nc">Success</span> <span class="n">input</span>

<span class="k">let</span> <span class="n">validate2</span> <span class="n">input</span> <span class="o">=</span>
   <span class="k">if</span> <span class="n">input</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="nc">Length</span> <span class="o">&gt;</span> <span class="mi">50</span> <span class="k">then</span> <span class="nc">Failure</span> <span class="s2">"Name must not be longer than 50 chars"</span>
   <span class="k">else</span> <span class="nc">Success</span> <span class="n">input</span>

<span class="k">let</span> <span class="n">validate3</span> <span class="n">input</span> <span class="o">=</span>
   <span class="k">if</span> <span class="n">input</span><span class="o">.</span><span class="n">email</span> <span class="o">=</span> <span class="s2">""</span> <span class="k">then</span> <span class="nc">Failure</span> <span class="s2">"Email must not be blank"</span>
   <span class="k">else</span> <span class="nc">Success</span> <span class="n">input</span>
</code></pre><span>
</span></div><span>


</span><p>Now to combine them, we apply <code>bind</code> to each validation function to create a new alternative function that is two-tracked.</p><span>

</span><p>Then we can connect the two-tracked functions using standard function composition, like this:</p><span>

</span><div class="highlight"><pre><code class="fsharp"><span class="c1">/// glue the three validation functions together</span>
<span class="k">let</span> <span class="n">combinedValidation</span> <span class="o">=</span> 
    <span class="c1">// convert from switch to two-track input</span>
    <span class="k">let</span> <span class="n">validate2'</span> <span class="o">=</span> <span class="n">bind</span> <span class="n">validate2</span>
    <span class="k">let</span> <span class="n">validate3'</span> <span class="o">=</span> <span class="n">bind</span> <span class="n">validate3</span>
    <span class="c1">// connect the two-tracks together</span>
    <span class="n">validate1</span> <span class="o">&gt;&gt;</span> <span class="n">validate2'</span> <span class="o">&gt;&gt;</span> <span class="n">validate3'</span> 
</code></pre><span>
</span></div><span>


</span><p>The functions <code>validate2'</code> and <code>validate3'</code> are new functions that take two-track input. If you look at their signatures you will see that they take a <code>Result</code> and return a <code>Result</code>.
But note that <code>validate1</code> does not need to be converted to two track input. Its input is left as one-track, and its output is two-track already, as needed for composition to work.</p><span>

</span><p>Here's a diagram showing the <code>Validate1</code> switch (unbound) and the <code>Validate2</code> and <code>Validate3</code> switches, together with the <code>Validate2'</code> and <code>Validate3'</code> adapters.</p><span>

</span><p><img src="http://fsharpforfunandprofit.com/assets/img/Recipe_Railway_Validator2and3.png" alt="Validate2 and Validate3 connected"></p><span>

</span><p>We could have also "inlined" the <code>bind</code>, like this:</p><span>

</span><div class="highlight"><pre><code class="fsharp"><span class="k">let</span> <span class="n">combinedValidation</span> <span class="o">=</span> 
    <span class="c1">// connect the two-tracks together</span>
    <span class="n">validate1</span> 
    <span class="o">&gt;&gt;</span> <span class="n">bind</span> <span class="n">validate2</span> 
    <span class="o">&gt;&gt;</span> <span class="n">bind</span> <span class="n">validate3</span>
</code></pre><span>
</span></div><span>


</span><p>Let's test it with two bad inputs and a good input:</p><span>

</span><div class="highlight"><pre><code class="fsharp"><span class="c1">// test 1</span>
<span class="k">let</span> <span class="n">input1</span> <span class="o">=</span> <span class="o">{</span><span class="n">name</span><span class="o">=</span><span class="s2">""</span><span class="o">;</span> <span class="n">email</span><span class="o">=</span><span class="s2">""</span><span class="o">}</span>
<span class="n">combinedValidation</span> <span class="n">input1</span> 
<span class="o">|&gt;</span> <span class="n">printfn</span> <span class="s2">"Result1=%A"</span>

<span class="c1">// ==&gt; Result1=Failure "Name must not be blank"</span>

<span class="c1">// test 2</span>
<span class="k">let</span> <span class="n">input2</span> <span class="o">=</span> <span class="o">{</span><span class="n">name</span><span class="o">=</span><span class="s2">"Alice"</span><span class="o">;</span> <span class="n">email</span><span class="o">=</span><span class="s2">""</span><span class="o">}</span>
<span class="n">combinedValidation</span> <span class="n">input2</span>
<span class="o">|&gt;</span> <span class="n">printfn</span> <span class="s2">"Result2=%A"</span>

<span class="c1">// ==&gt; Result2=Failure "Email must not be blank"</span>

<span class="c1">// test 3</span>
<span class="k">let</span> <span class="n">input3</span> <span class="o">=</span> <span class="o">{</span><span class="n">name</span><span class="o">=</span><span class="s2">"Alice"</span><span class="o">;</span> <span class="n">email</span><span class="o">=</span><span class="s2">"good"</span><span class="o">}</span>
<span class="n">combinedValidation</span> <span class="n">input3</span>
<span class="o">|&gt;</span> <span class="n">printfn</span> <span class="s2">"Result3=%A"</span>

<span class="c1">// ==&gt; Result3=Success {name = "Alice"; email = "good";}</span>
</code></pre><span>
</span></div><span>


</span><p>I would encourage you to try it for yourself and play around with the validation functions and test input.</p><span>

</span><p><em>You might be wondering if there is a way to run all three validations in parallel, rather than serially, so that you can get back all the validation errors at once.
Yes, there is a way, which I'll explain later in this post.</em></p><span>

</span><h3>Bind as a piping operation</h3><span>

</span><p>While we are discussing the <code>bind</code> function, there is a common symbol for it, <code>&gt;&gt;=</code>, which is used to pipe values into switch functions.</p><span>

</span><p>Here's the definition, which switches around the two parameters to make them easier to chain together:</p><span>

</span><div class="highlight"><pre><code class="fsharp"><span class="c1">/// create an infix operator</span>
<span class="k">let</span> <span class="o">(&gt;&gt;=)</span> <span class="n">twoTrackInput</span> <span class="n">switchFunction</span> <span class="o">=</span> 
    <span class="n">bind</span> <span class="n">switchFunction</span> <span class="n">twoTrackInput</span> 
</code></pre><span>
</span></div><span>


</span><p><em>One way to remember the symbol is to think of it as the composition symbol, <code>&gt;&gt;</code>, followed by a two-track railway symbol, <code>=</code>.</em></p><span>

</span><p>When used like this, the <code>&gt;&gt;=</code> operator is sort of like a pipe (<code>|&gt;</code>) but for switch functions.</p><span>

</span><p>In a normal pipe, the left hand side is a one-track value, and the right hand value is a normal function.
But in a "bind pipe" operation, the left hand side is a <em>two-track</em> value, and the right hand value is a <em>switch function</em>.</p><span>

</span><p>Here it is in use to create another implementation of the <code>combinedValidation</code> function.</p><span>

</span><div class="highlight"><pre><code class="fsharp"><span class="k">let</span> <span class="n">combinedValidation</span> <span class="n">x</span> <span class="o">=</span> 
    <span class="n">x</span> 
    <span class="o">|&gt;</span> <span class="n">validate1</span>   <span class="c1">// normal pipe because validate1 has a one-track input</span>
                   <span class="c1">// but validate1 results in a two track output...</span>
    <span class="o">&gt;&gt;=</span> <span class="n">validate2</span>  <span class="c1">// ... so use "bind pipe". Again the result is a two track output</span>
    <span class="o">&gt;&gt;=</span> <span class="n">validate3</span>   <span class="c1">// ... so use "bind pipe" again. </span>
</code></pre><span>
</span></div><span>


</span><p>The difference between this implementation and the previous one is that this definition is <em>data-oriented</em> rather than <em>function-oriented</em>. It has an explicit parameter for the initial data value, namely <code>x</code>. <code>x</code> is passed to the first function, and then the output of that is passed to the second function, and so on.</p><span>

</span><p>In the previous implementation (repeated below), there was no data parameter at all! The focus was on the functions themselves, not the data that flows through them.</p><span>

</span><div class="highlight"><pre><code class="fsharp"><span class="k">let</span> <span class="n">combinedValidation</span> <span class="o">=</span> 
    <span class="n">validate1</span> 
    <span class="o">&gt;&gt;</span> <span class="n">bind</span> <span class="n">validate2</span> 
    <span class="o">&gt;&gt;</span> <span class="n">bind</span> <span class="n">validate3</span>
</code></pre><span>
</span></div><span>


</span><h2>An alternative to bind</h2><span>

</span><p>Another way to combine switches is not by adapting them to a two track input, but simply by joining them directly together to make a new, bigger switch.</p><span>

</span><p>In other words, this:</p><span>

</span><p><img src="http://fsharpforfunandprofit.com/assets/img/Recipe_RailwaySwitch1.png" alt="2 railway switches disconnected"></p><span>

</span><p>becomes this:</p><span>

</span><p><img src="http://fsharpforfunandprofit.com/assets/img/Recipe_RailwaySwitch2.png" alt="2 railway switches connected"></p><span>

</span><p>But if you think about it, this combined track is actually just another switch!  You can see this if you cover up the middle bit. There's one input and two outputs:</p><span>

</span><p><img src="http://fsharpforfunandprofit.com/assets/img/Recipe_RailwaySwitch2a.png" alt="2 railway switches connected"></p><span>

</span><p>So what we have really done is a form of composition for switches, like this:</p><span>

</span><p><img src="http://fsharpforfunandprofit.com/assets/img/Recipe_Railway_MComp.png" alt="switches composition"></p><span>

</span><p>Because each composition results in just another switch, we can always add another switch again, resulting in an even bigger thing that is still a switch, and so on.</p><span>

</span><p>Here's the code for switch composition.  The standard symbol used is <code>&gt;=&gt;</code>, a bit like the normal composition symbol, but with a railway track between the angles.</p><span>

</span><div class="highlight"><pre><code class="fsharp"><span class="k">let</span> <span class="o">(&gt;=&gt;)</span> <span class="n">switch1</span> <span class="n">switch2</span> <span class="n">x</span> <span class="o">=</span> 
    <span class="k">match</span> <span class="n">switch1</span> <span class="n">x</span> <span class="k">with</span>
    <span class="o">|</span> <span class="nc">Success</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="n">switch2</span> <span class="n">s</span>
    <span class="o">|</span> <span class="nc">Failure</span> <span class="n">f</span> <span class="o">-&gt;</span> <span class="nc">Failure</span> <span class="n">f</span> 
</code></pre><span>
</span></div><span>


</span><p>Again, the actual implementation is very straightforward. Pass the single track input <code>x</code> through the first switch. On success, pass the result into the second switch, otherwise bypass the second switch completely.</p><span>

</span><p>Now we can rewrite the <code>combinedValidation</code> function to use switch composition rather than bind:</p><span>

</span><div class="highlight"><pre><code class="fsharp"><span class="k">let</span> <span class="n">combinedValidation</span> <span class="o">=</span> 
    <span class="n">validate1</span> 
    <span class="o">&gt;=&gt;</span> <span class="n">validate2</span> 
    <span class="o">&gt;=&gt;</span> <span class="n">validate3</span> 
</code></pre><span>
</span></div><span>


</span><p>This one is the simplest yet, I think.  It's very easy to extend of course, if we have a fourth validation function, we can just append it to the end.</p><span>

</span><h3>Bind vs. switch composition</h3><span>

</span><p>We have two different concepts that at first glance seem quite similar. What's the difference?</p><span>

</span><p>To recap:</p><span>

</span><ul>
<li><strong>Bind</strong> has <em>one</em> switch function parameter.  It is an adapter that converts the switch function into a fully two-track function (with two-track input and two-track output).</li>
<li><strong>Switch composition</strong> has <em>two</em> switch function parameters. It combines them in series to make another switch function.</li>
</ul><span>


</span><p>So why would you use bind rather than switch composition? It depends on the context. If you have an existing two-track system, and you need to insert a switch,
then you have to use bind as an adapter to convert the switch into something that takes two-track input.</p><span>

</span><p><img src="http://fsharpforfunandprofit.com/assets/img/Recipe_Railway_WhyBind.png" alt="switches composition"></p><span>

</span><p>On the other hand, if your entire data flow consists of a chain of switches, then switch composition can be simpler.</p><span>

</span><p><img src="http://fsharpforfunandprofit.com/assets/img/Recipe_Railway_WhyCompose.png" alt="switches composition"></p><span>

</span><h3>Switch composition in terms of bind</h3><span>

</span><p>As it happens, switch composition can be written in terms of bind. If you connect the first switch with a bind-adapted second switch, you get the same thing as switch composition:</p><span>

</span><p>Here are two separate switches:</p><span>

</span><p><img src="http://fsharpforfunandprofit.com/assets/img/Recipe_RailwaySwitch1.png" alt="2 railway switches disconnected"></p><span>

</span><p>And then here are the switches composed together to make a new bigger switch:</p><span>

</span><p><img src="http://fsharpforfunandprofit.com/assets/img/Recipe_RailwaySwitch2.png" alt="2 railway switches disconnected"></p><span>

</span><p>And here's the same thing done by using <code>bind</code> on the second switch:</p><span>

</span><p><img src="http://fsharpforfunandprofit.com/assets/img/Recipe_Railway_BindIsCompose.png" alt="bind as switch composition"></p><span>

</span><p>Here's the switch composition operator rewritten using this way of thinking:</p><span>

</span><div class="highlight"><pre><code class="fsharp"><span class="k">let</span> <span class="o">(&gt;=&gt;)</span> <span class="n">switch1</span> <span class="n">switch2</span> <span class="o">=</span> 
    <span class="n">switch1</span> <span class="o">&gt;&gt;</span> <span class="o">(</span><span class="n">bind</span> <span class="n">switch2</span><span class="o">)</span>
</code></pre><span>
</span></div><span>


</span><p>This implementation of switch composition is much simpler than the first one, but also more abstract. Whether it is easier to comprehend for a beginner is another matter! I find that if you think of functions as things in their own right, rather than just as conduits for data, this approach becomes easier to understand.</p><span>

</span><h2>Converting simple functions to the railway-oriented programming model</h2><span>

</span><p>Once you get the hang of it, you can fit all sorts of other things into this model.</p><span>

</span><p>For example, let's say we have a function that is <em>not</em> a switch, just a regular function. And say that we want to insert it into our flow.</p><span>

</span><p>Here's a real example - say that we want to trim and lowercase the email address after the validation is complete. Here's some code to do this:</p><span>

</span><div class="highlight"><pre><code class="fsharp"><span class="k">let</span> <span class="n">canonicalizeEmail</span> <span class="n">input</span> <span class="o">=</span>
   <span class="o">{</span> <span class="n">input</span> <span class="k">with</span> <span class="n">email</span> <span class="o">=</span> <span class="n">input</span><span class="o">.</span><span class="n">email</span><span class="o">.</span><span class="nc">Trim</span><span class="bp">()</span><span class="o">.</span><span class="nc">ToLower</span><span class="bp">()</span> <span class="o">}</span>
</code></pre><span>
</span></div><span>


</span><p>This code takes a (single-track) <code>Request</code> and returns a (single-track) <code>Request</code>.</p><span>

</span><p>How can we insert this after the validation steps but before the update step?</p><span>

</span><p>Well, if we can turn this simple function into a switch function, then we can use the switch composition we just talked about above.</p><span>

</span><p>In other words, we need an adapter block. It the same concept that we used for <code>bind</code>, except that this time our adapter block will have a slot for one-track function, and the overall "shape" of the adapter block is a switch.</p><span>

</span><p><img src="http://fsharpforfunandprofit.com/assets/img/Recipe_Railway_SwitchAdapter.png" alt="lifting a simple function"></p><span>

</span><p>The code to do this is trivial. All we need to do is take the output of the one track function and turn it into a two-track result. In this case, the result will <em>always</em> be Success.</p><span>

</span><div class="highlight"><pre><code class="fsharp"><span class="c1">// convert a normal function into a switch</span>
<span class="k">let</span> <span class="n">switch</span> <span class="n">f</span> <span class="n">x</span> <span class="o">=</span> 
    <span class="n">f</span> <span class="n">x</span> <span class="o">|&gt;</span> <span class="nc">Success</span>
</code></pre><span>
</span></div><span>


</span><p>In railway terms, we have added a bit of failure track.  Taken as a whole, it <em>looks</em> like a switch function (one-track input, two-track output),
but of course, the failure track is just a dummy and the switch never actually gets used.</p><span>

</span><p><img src="http://fsharpforfunandprofit.com/assets/img/Recipe_Railway_SwitchAdapter2.png" alt="lifting a simple function"></p><span>

</span><p>Once <code>switch</code> is available, we can easily append the <code>canonicalizeEmail</code> function to the end of the chain. Since we are beginning to extend it, let's rename the function to <code>usecase</code>.</p><span>

</span><div class="highlight"><pre><code class="fsharp"><span class="k">let</span> <span class="n">usecase</span> <span class="o">=</span> 
    <span class="n">validate1</span> 
    <span class="o">&gt;=&gt;</span> <span class="n">validate2</span> 
    <span class="o">&gt;=&gt;</span> <span class="n">validate3</span> 
    <span class="o">&gt;=&gt;</span> <span class="n">switch</span> <span class="n">canonicalizeEmail</span>
</code></pre><span>
</span></div><span>


</span><p>Try testing it to see what happens:</p><span>

</span><div class="highlight"><pre><code class="fsharp"><span class="k">let</span> <span class="n">goodInput</span> <span class="o">=</span> <span class="o">{</span><span class="n">name</span><span class="o">=</span><span class="s2">"Alice"</span><span class="o">;</span> <span class="n">email</span><span class="o">=</span><span class="s2">"UPPERCASE   "</span><span class="o">}</span>
<span class="n">usecase</span> <span class="n">goodInput</span>
<span class="o">|&gt;</span> <span class="n">printfn</span> <span class="s2">"Canonicalize Good Result = %A"</span>

<span class="c1">//Canonicalize Good Result = Success {name = "Alice"; email = "uppercase";}</span>

<span class="k">let</span> <span class="n">badInput</span> <span class="o">=</span> <span class="o">{</span><span class="n">name</span><span class="o">=</span><span class="s2">""</span><span class="o">;</span> <span class="n">email</span><span class="o">=</span><span class="s2">"UPPERCASE   "</span><span class="o">}</span>
<span class="n">usecase</span> <span class="n">badInput</span>
<span class="o">|&gt;</span> <span class="n">printfn</span> <span class="s2">"Canonicalize Bad Result = %A"</span>

<span class="c1">//Canonicalize Bad Result = Failure "Name must not be blank"</span>
</code></pre><span>
</span></div><span>


</span><h2>Creating two-track functions from one-track functions</h2><span>

</span><p>In the previous example, we took a one-track function and created a switch from it. This enabled us to use switch composition with it.</p><span>

</span><p>Sometimes though, you want to use the two-track model directly, in which case you want to turn a one-track function into a two-track function directly.</p><span>

</span><p><img src="http://fsharpforfunandprofit.com/assets/img/Recipe_Railway_MapAdapter2.png" alt="mapping a simple function"></p><span>

</span><p>Again, we just need an adapter block with a slot for the simple function. We typically call this adapter <code>map</code>.</p><span>

</span><p><img src="http://fsharpforfunandprofit.com/assets/img/Recipe_Railway_MapAdapter.png" alt="mapping a simple function"></p><span>

</span><p>And again, the actual implementation is very straightforward. If the two-track input is <code>Success</code>, call the function, and turn its output into Success. On the other hand, if the two-track input is <code>Failure</code> bypass the function completely.</p><span>

</span><p>Here's the code:</p><span>

</span><div class="highlight"><pre><code class="fsharp"><span class="c1">// convert a normal function into a two-track function</span>
<span class="k">let</span> <span class="n">map</span> <span class="n">oneTrackFunction</span> <span class="n">twoTrackInput</span> <span class="o">=</span> 
    <span class="k">match</span> <span class="n">twoTrackInput</span> <span class="k">with</span>
    <span class="o">|</span> <span class="nc">Success</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="nc">Success</span> <span class="o">(</span><span class="n">oneTrackFunction</span> <span class="n">s</span><span class="o">)</span>
    <span class="o">|</span> <span class="nc">Failure</span> <span class="n">f</span> <span class="o">-&gt;</span> <span class="nc">Failure</span> <span class="n">f</span>
</code></pre><span>
</span></div><span>


</span><p>And here it is in use with <code>canonicalizeEmail</code>:</p><span>

</span><div class="highlight"><pre><code class="fsharp"><span class="k">let</span> <span class="n">usecase</span> <span class="o">=</span> 
    <span class="n">validate1</span> 
    <span class="o">&gt;=&gt;</span> <span class="n">validate2</span> 
    <span class="o">&gt;=&gt;</span> <span class="n">validate3</span> 
    <span class="o">&gt;&gt;</span> <span class="n">map</span> <span class="n">canonicalizeEmail</span>  <span class="c1">// normal composition</span>
</code></pre><span>
</span></div><span>


</span><p>Note that <em>normal</em> composition is now used because <code>map canonicalizeEmail</code> is a fully two-track function and can be connected to the output of the <code>validate3</code> switch directly.</p><span>

</span><p>In other words, for one-track functions, <code>&gt;=&gt; switch</code> is exactly the same as <code>&gt;&gt; map</code>. Your choice.</p><span>

</span><h2>Converting dead-end functions to two-track functions</h2><span>

</span><p>Another function we will often want to work with is a "dead-end" function -- a function that accepts input but has no useful output.</p><span>

</span><p>For example, consider a function that updates a database record. It is useful only for its side-effects -- it doesn't normally return anything.</p><span>

</span><p>How can we incorporate this kind of function into the flow?</p><span>

</span><p>What we need to do is:</p><span>

</span><ul>
<li>Save a copy of the input.</li>
<li>Call the function and ignore its output, if any.</li>
<li>Return the original input for passing on to the next function in the chain.</li>
</ul><span>


</span><p>From a railway point of view, this is equivalent to creating a dead-end siding, like this.</p><span>

</span><p><img src="http://fsharpforfunandprofit.com/assets/img/Recipe_Railway_Tee.png" alt="tee for a dead end function"></p><span>

</span><p>To make this work, we need another adapter function, like <code>switch</code>, except that this time it has a slot for one-track dead-end function, and converts it into a single-track pass through function, with a one-track output.</p><span>

</span><p><img src="http://fsharpforfunandprofit.com/assets/img/Recipe_Railway_TeeAdapter.png" alt="tee for a dead end function"></p><span>

</span><p>Here's the code, which I will call <code>tee</code>, after the UNIX tee command:</p><span>

</span><div class="highlight"><pre><code class="fsharp"><span class="k">let</span> <span class="n">tee</span> <span class="n">f</span> <span class="n">x</span> <span class="o">=</span> 
    <span class="n">f</span> <span class="n">x</span> <span class="o">|&gt;</span> <span class="n">ignore</span>
    <span class="n">x</span>
</code></pre><span>
</span></div><span>


</span><p>Once we have converted the dead-end function to a simple one-track pass through function, we can then use it in the data flow by converting it using <code>switch</code> or <code>map</code> as described above.</p><span>

</span><p>Here's the code in use with the "switch composition" style:</p><span>

</span><div class="highlight"><pre><code class="fsharp"><span class="c1">// a dead-end function    </span>
<span class="k">let</span> <span class="n">updateDatabase</span> <span class="n">input</span> <span class="o">=</span>
   <span class="bp">()</span>   <span class="c1">// dummy dead-end function for now</span>

<span class="k">let</span> <span class="n">usecase</span> <span class="o">=</span> 
    <span class="n">validate1</span> 
    <span class="o">&gt;=&gt;</span> <span class="n">validate2</span> 
    <span class="o">&gt;=&gt;</span> <span class="n">validate3</span> 
    <span class="o">&gt;=&gt;</span> <span class="n">switch</span> <span class="n">canonicalizeEmail</span>
    <span class="o">&gt;=&gt;</span> <span class="n">switch</span> <span class="o">(</span><span class="n">tee</span> <span class="n">updateDatabase</span><span class="o">)</span>
</code></pre><span>
</span></div><span>


</span><p>Or alternatively, rather than using <code>switch</code> and then connecting with <code>&gt;=&gt;</code>, we can use <code>map</code> and connect with <code>&gt;&gt;</code>.</p><span>

</span><p>Here's a variant implementation which is exactly the same but uses the "two-track" style with normal composition</p><span>

</span><div class="highlight"><pre><code class="fsharp"><span class="k">let</span> <span class="n">usecase</span> <span class="o">=</span> 
    <span class="n">validate1</span> 
    <span class="o">&gt;&gt;</span> <span class="n">bind</span> <span class="n">validate2</span> 
    <span class="o">&gt;&gt;</span> <span class="n">bind</span> <span class="n">validate3</span> 
    <span class="o">&gt;&gt;</span> <span class="n">map</span> <span class="n">canonicalizeEmail</span>   
    <span class="o">&gt;&gt;</span> <span class="n">map</span> <span class="o">(</span><span class="n">tee</span> <span class="n">updateDatabase</span><span class="o">)</span>
</code></pre><span>
</span></div><span>


</span><h2>Handling exceptions</h2><span>

</span><p>Our dead end database update might not return anything, but that doesn't mean that it might not throw an exception.  Rather than crashing, we want to catch that exception and turn it into a failure.</p><span>

</span><p>The code is similar to the <code>switch</code> function, except that it catches exceptions. I'll call it <code>tryCatch</code>:</p><span>

</span><div class="highlight"><pre><code class="fsharp"><span class="k">let</span> <span class="n">tryCatch</span> <span class="n">f</span> <span class="n">x</span> <span class="o">=</span>
    <span class="k">try</span>
        <span class="n">f</span> <span class="n">x</span> <span class="o">|&gt;</span> <span class="nc">Success</span>
    <span class="k">with</span>
    <span class="o">|</span> <span class="n">ex</span> <span class="o">-&gt;</span> <span class="nc">Failure</span> <span class="n">ex</span><span class="o">.</span><span class="nc">Message</span>
</code></pre><span>
</span></div><span>


</span><p>And here is a modified version of the data flow, using <code>tryCatch</code> rather than <code>switch</code> for the update database code.</p><span>

</span><div class="highlight"><pre><code class="fsharp"><span class="k">let</span> <span class="n">usecase</span> <span class="o">=</span> 
    <span class="n">validate1</span> 
    <span class="o">&gt;=&gt;</span> <span class="n">validate2</span> 
    <span class="o">&gt;=&gt;</span> <span class="n">validate3</span> 
    <span class="o">&gt;=&gt;</span> <span class="n">switch</span> <span class="n">canonicalizeEmail</span>
    <span class="o">&gt;=&gt;</span> <span class="n">tryCatch</span> <span class="o">(</span><span class="n">tee</span> <span class="n">updateDatabase</span><span class="o">)</span>
</code></pre><span>
</span></div><span>


</span><h2>Functions with two-track input</h2><span>

</span><p>All the functions we have seen so far have only one input, because they always just work with data travelling along the happy path.</p><span>

</span><p>Sometimes though, you <em>do</em> need a function that handles both tracks. For example, a logging function that logs errors as well as successes.</p><span>

</span><p>As we have done previously, we will create an adapter block, but this time it will have slots for <em>two</em> separate one-track functions.</p><span>

</span><p><img src="http://fsharpforfunandprofit.com/assets/img/Recipe_Railway_DoubleMapAdapter.png" alt="double map adapter"></p><span>

</span><p>Here's the code:</p><span>

</span><div class="highlight"><pre><code class="fsharp"><span class="k">let</span> <span class="n">doubleMap</span> <span class="n">successFunc</span> <span class="n">failureFunc</span> <span class="n">twoTrackInput</span> <span class="o">=</span>
    <span class="k">match</span> <span class="n">twoTrackInput</span> <span class="k">with</span>
    <span class="o">|</span> <span class="nc">Success</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="nc">Success</span> <span class="o">(</span><span class="n">successFunc</span> <span class="n">s</span><span class="o">)</span>
    <span class="o">|</span> <span class="nc">Failure</span> <span class="n">f</span> <span class="o">-&gt;</span> <span class="nc">Failure</span> <span class="o">(</span><span class="n">failureFunc</span> <span class="n">f</span><span class="o">)</span>
</code></pre><span>
</span></div><span>


</span><p>As an aside, we can use this function to create a simpler version of <code>map</code>, using <code>id</code> for the failure function:</p><span>

</span><div class="highlight"><pre><code class="fsharp"><span class="k">let</span> <span class="n">map</span> <span class="n">successFunc</span> <span class="o">=</span>
    <span class="n">doubleMap</span> <span class="n">successFunc</span> <span class="n">id</span>
</code></pre><span>
</span></div><span>


</span><p>Let's use <code>doubleMap</code> to insert some logging into the data flow:</p><span>

</span><div class="highlight"><pre><code class="fsharp"><span class="k">let</span> <span class="n">log</span> <span class="n">twoTrackInput</span> <span class="o">=</span> 
    <span class="k">let</span> <span class="n">success</span> <span class="n">x</span> <span class="o">=</span> <span class="n">printfn</span> <span class="s2">"DEBUG. Success so far: %A"</span> <span class="n">x</span><span class="o">;</span> <span class="n">x</span>
    <span class="k">let</span> <span class="n">failure</span> <span class="n">x</span> <span class="o">=</span> <span class="n">printfn</span> <span class="s2">"ERROR. %A"</span> <span class="n">x</span><span class="o">;</span> <span class="n">x</span>
    <span class="n">doubleMap</span> <span class="n">success</span> <span class="n">failure</span> <span class="n">twoTrackInput</span> 

<span class="k">let</span> <span class="n">usecase</span> <span class="o">=</span> 
    <span class="n">validate1</span> 
    <span class="o">&gt;=&gt;</span> <span class="n">validate2</span> 
    <span class="o">&gt;=&gt;</span> <span class="n">validate3</span> 
    <span class="o">&gt;=&gt;</span> <span class="n">switch</span> <span class="n">canonicalizeEmail</span>
    <span class="o">&gt;=&gt;</span> <span class="n">tryCatch</span> <span class="o">(</span><span class="n">tee</span> <span class="n">updateDatabase</span><span class="o">)</span>
    <span class="o">&gt;&gt;</span> <span class="n">log</span>
</code></pre><span>
</span></div><span>


</span><p>Here's some test code, with the results:</p><span>

</span><div class="highlight"><pre><code class="fsharp"><span class="k">let</span> <span class="n">goodInput</span> <span class="o">=</span> <span class="o">{</span><span class="n">name</span><span class="o">=</span><span class="s2">"Alice"</span><span class="o">;</span> <span class="n">email</span><span class="o">=</span><span class="s2">"good"</span><span class="o">}</span>
<span class="n">usecase</span> <span class="n">goodInput</span>
<span class="o">|&gt;</span> <span class="n">printfn</span> <span class="s2">"Good Result = %A"</span>

<span class="c1">// DEBUG. Success so far: {name = "Alice"; email = "good";}</span>
<span class="c1">// Good Result = Success {name = "Alice"; email = "good";}</span>

<span class="k">let</span> <span class="n">badInput</span> <span class="o">=</span> <span class="o">{</span><span class="n">name</span><span class="o">=</span><span class="s2">""</span><span class="o">;</span> <span class="n">email</span><span class="o">=</span><span class="s2">""</span><span class="o">}</span>
<span class="n">usecase</span> <span class="n">badInput</span> 
<span class="o">|&gt;</span> <span class="n">printfn</span> <span class="s2">"Bad Result = %A"</span>

<span class="c1">// ERROR. "Name must not be blank"</span>
<span class="c1">// Bad Result = Failure "Name must not be blank"</span>
</code></pre><span>
</span></div><span>


</span><h2>Converting a single value to a two-track value</h2><span>

</span><p>For completeness, we should also create simple functions that turn a single simple value into a two-track value, either success or failure.</p><span>

</span><div class="highlight"><pre><code class="fsharp"><span class="k">let</span> <span class="n">succeed</span> <span class="n">x</span> <span class="o">=</span> 
    <span class="nc">Success</span> <span class="n">x</span>

<span class="k">let</span> <span class="n">fail</span> <span class="n">x</span> <span class="o">=</span> 
    <span class="nc">Failure</span> <span class="n">x</span>
</code></pre><span>
</span></div><span>


</span><p>Right now these are trivial, just calling the constructor of the <code>Result</code> type, but when we get down to some proper coding we'll see that by using these rather than the union case constructor directly, we can isolate ourselves from changes behind the scenes.</p><span>

</span><h2>Combining functions in parallel</h2><span>

</span><p>So far, we have combined functions in series.  But with something like validation, we might want to run multiple switches in parallel, and combine the results, like this:</p><span>

</span><p><img src="http://fsharpforfunandprofit.com/assets/img/Recipe_Railway_Parallel.png" alt="switches in parallel"></p><span>

</span><p>To make this easier, we can reuse the same trick that we did for switch composition. Rather than doing many at once, if we just focus on a single pair, and "add" them to make a new switch, we can then easily chain the "addition" together so that we can add as many as we want.  In other words, we just need to implement this:</p><span>

</span><p><img src="http://fsharpforfunandprofit.com/assets/img/Recipe_Railway_MPlus.png" alt="add two switches in parallel"></p><span>

</span><p>So, what is the logic for adding two switches in parallel?</p><span>

</span><ul>
<li>First, take the input and apply it to each switch.</li>
<li>Next look at the outputs of both switches, and if both are successful, the overall result is <code>Success</code>.</li>
<li>If either output is a failure, then the overall result is <code>Failure</code> as well.</li>
</ul><span>


</span><p>Here's the function, which I will call <code>plus</code>:</p><span>

</span><div class="highlight"><pre><code class="fsharp"><span class="k">let</span> <span class="n">plus</span> <span class="n">switch1</span> <span class="n">switch2</span> <span class="n">x</span> <span class="o">=</span> 
    <span class="k">match</span> <span class="o">(</span><span class="n">switch1</span> <span class="n">x</span><span class="o">),(</span><span class="n">switch2</span> <span class="n">x</span><span class="o">)</span> <span class="k">with</span>
    <span class="o">|</span> <span class="nc">Success</span> <span class="n">s1</span><span class="o">,</span><span class="nc">Success</span> <span class="n">s2</span> <span class="o">-&gt;</span> <span class="nc">Success</span> <span class="o">(</span><span class="n">s1</span> <span class="o">+</span> <span class="n">s2</span><span class="o">)</span>
    <span class="o">|</span> <span class="nc">Failure</span> <span class="n">f1</span><span class="o">,</span><span class="nc">Success</span> <span class="o">_</span>  <span class="o">-&gt;</span> <span class="nc">Failure</span> <span class="n">f1</span>
    <span class="o">|</span> <span class="nc">Success</span> <span class="o">_</span> <span class="o">,</span><span class="nc">Failure</span> <span class="n">f2</span> <span class="o">-&gt;</span> <span class="nc">Failure</span> <span class="n">f2</span>
    <span class="o">|</span> <span class="nc">Failure</span> <span class="n">f1</span><span class="o">,</span><span class="nc">Failure</span> <span class="n">f2</span> <span class="o">-&gt;</span> <span class="nc">Failure</span> <span class="o">(</span><span class="n">f1</span> <span class="o">+</span> <span class="n">f2</span><span class="o">)</span>
</code></pre><span>
</span></div><span>


</span><p>But we now have a new problem. What do we do with two successes, or two failures? How do we combine the inner values?</p><span>

</span><p>I used <code>s1 + s2</code> and <code>f1 + f2</code> in the example above, but that implies that there is some sort of <code>+</code> operator we can use. That may be true for strings and ints, but it is not true in general.</p><span>

</span><p>The method of combining values might change in different contexts, so rather than trying to solve it once and for all, let's punt by letting the caller pass in the functions that are needed.</p><span>

</span><p>Here's a rewritten version:</p><span>

</span><div class="highlight"><pre><code class="fsharp"><span class="k">let</span> <span class="n">plus</span> <span class="n">addSuccess</span> <span class="n">addFailure</span> <span class="n">switch1</span> <span class="n">switch2</span> <span class="n">x</span> <span class="o">=</span> 
    <span class="k">match</span> <span class="o">(</span><span class="n">switch1</span> <span class="n">x</span><span class="o">),(</span><span class="n">switch2</span> <span class="n">x</span><span class="o">)</span> <span class="k">with</span>
    <span class="o">|</span> <span class="nc">Success</span> <span class="n">s1</span><span class="o">,</span><span class="nc">Success</span> <span class="n">s2</span> <span class="o">-&gt;</span> <span class="nc">Success</span> <span class="o">(</span><span class="n">addSuccess</span> <span class="n">s1</span> <span class="n">s2</span><span class="o">)</span>
    <span class="o">|</span> <span class="nc">Failure</span> <span class="n">f1</span><span class="o">,</span><span class="nc">Success</span> <span class="o">_</span>  <span class="o">-&gt;</span> <span class="nc">Failure</span> <span class="n">f1</span>
    <span class="o">|</span> <span class="nc">Success</span> <span class="o">_</span> <span class="o">,</span><span class="nc">Failure</span> <span class="n">f2</span> <span class="o">-&gt;</span> <span class="nc">Failure</span> <span class="n">f2</span>
    <span class="o">|</span> <span class="nc">Failure</span> <span class="n">f1</span><span class="o">,</span><span class="nc">Failure</span> <span class="n">f2</span> <span class="o">-&gt;</span> <span class="nc">Failure</span> <span class="o">(</span><span class="n">addFailure</span> <span class="n">f1</span> <span class="n">f2</span><span class="o">)</span>
</code></pre><span>
</span></div><span>


</span><p>I have put these new functions first in the parameter list, to aid partial application.</p><span>

</span><h3>An implementation for parallel validation</h3><span>

</span><p>Now let's create a implementation of "plus" for the validation functions.</p><span>

</span><ul>
<li>When both functions succeed, they will return the request unchanged, so the <code>addSuccess</code> function can return either parameter.</li>
<li>When both functions fail, they will return different strings, so the <code>addFailure</code> function should concatenate them.</li>
</ul><span>


</span><p>For validation then, the "plus" operation that we want is like an "AND" function. Only if both parts are "true" is the result "true".</p><span>

</span><p>That naturally leads to wanting to use <code>&amp;&amp;</code> as the operator symbol. Unfortunately, <code>&amp;&amp;</code> is reserved, but we can use <code>&amp;&amp;&amp;</code>, like this:</p><span>

</span><div class="highlight"><pre><code class="fsharp"><span class="c1">// create a "plus" function for validation functions</span>
<span class="k">let</span> <span class="o">(&amp;&amp;&amp;)</span> <span class="n">v1</span> <span class="n">v2</span> <span class="o">=</span> 
    <span class="k">let</span> <span class="n">addSuccess</span> <span class="n">r1</span> <span class="n">r2</span> <span class="o">=</span> <span class="n">r1</span> <span class="c1">// return first</span>
    <span class="k">let</span> <span class="n">addFailure</span> <span class="n">s1</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">s1</span> <span class="o">+</span> <span class="s2">"; "</span> <span class="o">+</span> <span class="n">s2</span>  <span class="c1">// concat</span>
    <span class="n">plus</span> <span class="n">addSuccess</span> <span class="n">addFailure</span> <span class="n">v1</span> <span class="n">v2</span> 
</code></pre><span>
</span></div><span>


</span><p>And now using <code>&amp;&amp;&amp;</code>, we can create a single validation function that combines the three smaller validations:</p><span>

</span><div class="highlight"><pre><code class="fsharp"><span class="k">let</span> <span class="n">combinedValidation</span> <span class="o">=</span> 
    <span class="n">validate1</span> 
    <span class="o">&amp;&amp;&amp;</span> <span class="n">validate2</span> 
    <span class="o">&amp;&amp;&amp;</span> <span class="n">validate3</span> 
</code></pre><span>
</span></div><span>


</span><p>Now let's try it with the same tests we had earlier:</p><span>

</span><div class="highlight"><pre><code class="fsharp"><span class="c1">// test 1</span>
<span class="k">let</span> <span class="n">input1</span> <span class="o">=</span> <span class="o">{</span><span class="n">name</span><span class="o">=</span><span class="s2">""</span><span class="o">;</span> <span class="n">email</span><span class="o">=</span><span class="s2">""</span><span class="o">}</span>
<span class="n">combinedValidation</span> <span class="n">input1</span> 
<span class="o">|&gt;</span> <span class="n">printfn</span> <span class="s2">"Result1=%A"</span>
<span class="c1">// ==&gt;  Result1=Failure "Name must not be blank; Email must not be blank"</span>

<span class="c1">// test 2</span>
<span class="k">let</span> <span class="n">input2</span> <span class="o">=</span> <span class="o">{</span><span class="n">name</span><span class="o">=</span><span class="s2">"Alice"</span><span class="o">;</span> <span class="n">email</span><span class="o">=</span><span class="s2">""</span><span class="o">}</span>
<span class="n">combinedValidation</span> <span class="n">input2</span> 
<span class="o">|&gt;</span> <span class="n">printfn</span> <span class="s2">"Result2=%A"</span>
<span class="c1">// ==&gt;  Result2=Failure "Email must not be blank"</span>

<span class="c1">// test 3</span>
<span class="k">let</span> <span class="n">input3</span> <span class="o">=</span> <span class="o">{</span><span class="n">name</span><span class="o">=</span><span class="s2">"Alice"</span><span class="o">;</span> <span class="n">email</span><span class="o">=</span><span class="s2">"good"</span><span class="o">}</span>
<span class="n">combinedValidation</span> <span class="n">input3</span> 
<span class="o">|&gt;</span> <span class="n">printfn</span> <span class="s2">"Result3=%A"</span>
<span class="c1">// ==&gt;  Result3=Success {name = "Alice"; email = "good";}</span>
</code></pre><span>
</span></div><span>


</span><p>The first test now has <em>two</em> validation errors combined into a single string, just as we wanted.</p><span>

</span><p>Next, we can tidy up the main dataflow function by using the <code>usecase</code> function now instead of the three separate validation functions we had before:</p><span>

</span><div class="highlight"><pre><code class="fsharp"><span class="k">let</span> <span class="n">usecase</span> <span class="o">=</span> 
    <span class="n">combinedValidation</span>
    <span class="o">&gt;=&gt;</span> <span class="n">switch</span> <span class="n">canonicalizeEmail</span>
    <span class="o">&gt;=&gt;</span> <span class="n">tryCatch</span> <span class="o">(</span><span class="n">tee</span> <span class="n">updateDatabase</span><span class="o">)</span>
</code></pre><span>
</span></div><span>


</span><p>And if we test that now, we can see that a success flows all the way to the end and that the email is lowercased and trimmed:</p><span>

</span><div class="highlight"><pre><code class="fsharp"><span class="c1">// test 4</span>
<span class="k">let</span> <span class="n">input4</span> <span class="o">=</span> <span class="o">{</span><span class="n">name</span><span class="o">=</span><span class="s2">"Alice"</span><span class="o">;</span> <span class="n">email</span><span class="o">=</span><span class="s2">"UPPERCASE   "</span><span class="o">}</span>
<span class="n">usecase</span> <span class="n">input4</span>
<span class="o">|&gt;</span> <span class="n">printfn</span> <span class="s2">"Result4=%A"</span>
<span class="c1">// ==&gt;  Result4=Success {name = "Alice"; email = "uppercase";}</span>
</code></pre><span>
</span></div><span>


</span><p><em>You might be asking, can we create a way of OR-ing validation functions as well? That is, the overall result is valid if either part is valid? The answer is yes, of course. Try it! I suggest that you use the symbol <code>|||</code> for this.</em></p><span>

</span><h2>Dynamic injection of functions</h2><span>

</span><p>Another thing we might want to do is add or remove functions into the flow dynamically, based on configuration settings, or even the content of the data.</p><span>

</span><p>The simplest way to do this is to create a two-track function to be injected into the stream, and replace it with the <code>id</code> function if not needed.</p><span>

</span><p>Here's the idea:</p><span>

</span><div class="highlight"><pre><code class="fsharp"><span class="k">let</span> <span class="n">injectableFunction</span> <span class="o">=</span> 
    <span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">debug</span> <span class="k">then</span> <span class="n">debugLogger</span> <span class="k">else</span> <span class="n">id</span>
</code></pre><span>
</span></div><span>


</span><p>Let's try it with some real code:</p><span>

</span><div class="highlight"><pre><code class="fsharp"><span class="k">type</span> <span class="nc">Config</span> <span class="o">=</span> <span class="o">{</span><span class="n">debug</span><span class="o">:</span><span class="kt">bool</span><span class="o">}</span>

<span class="k">let</span> <span class="n">debugLogger</span> <span class="n">twoTrackInput</span> <span class="o">=</span> 
    <span class="k">let</span> <span class="n">success</span> <span class="n">x</span> <span class="o">=</span> <span class="n">printfn</span> <span class="s2">"DEBUG. Success so far: %A"</span> <span class="n">x</span><span class="o">;</span> <span class="n">x</span>
    <span class="k">let</span> <span class="n">failure</span> <span class="o">=</span> <span class="n">id</span> <span class="c1">// don't log here</span>
    <span class="n">doubleMap</span> <span class="n">success</span> <span class="n">failure</span> <span class="n">twoTrackInput</span> 

<span class="k">let</span> <span class="n">injectableLogger</span> <span class="n">config</span> <span class="o">=</span> 
    <span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">debug</span> <span class="k">then</span> <span class="n">debugLogger</span> <span class="k">else</span> <span class="n">id</span>

<span class="k">let</span> <span class="n">usecase</span> <span class="n">config</span> <span class="o">=</span> 
    <span class="n">combinedValidation</span> 
    <span class="o">&gt;&gt;</span> <span class="n">map</span> <span class="n">canonicalizeEmail</span>
    <span class="o">&gt;&gt;</span> <span class="n">injectableLogger</span> <span class="n">config</span>
</code></pre><span>
</span></div><span>


</span><p>And here is it in use:</p><span>

</span><div class="highlight"><pre><code class="fsharp"><span class="k">let</span> <span class="n">input</span> <span class="o">=</span> <span class="o">{</span><span class="n">name</span><span class="o">=</span><span class="s2">"Alice"</span><span class="o">;</span> <span class="n">email</span><span class="o">=</span><span class="s2">"good"</span><span class="o">}</span>

<span class="k">let</span> <span class="n">releaseConfig</span> <span class="o">=</span> <span class="o">{</span><span class="n">debug</span><span class="o">=</span><span class="bp">false</span><span class="o">}</span>
<span class="n">input</span> 
<span class="o">|&gt;</span> <span class="n">usecase</span> <span class="n">releaseConfig</span> 
<span class="o">|&gt;</span> <span class="n">ignore</span>

<span class="c1">// no output</span>

<span class="k">let</span> <span class="n">debugConfig</span> <span class="o">=</span> <span class="o">{</span><span class="n">debug</span><span class="o">=</span><span class="bp">true</span><span class="o">}</span>
<span class="n">input</span> 
<span class="o">|&gt;</span> <span class="n">usecase</span> <span class="n">debugConfig</span> 
<span class="o">|&gt;</span> <span class="n">ignore</span>

<span class="c1">// debug output</span>
<span class="c1">// DEBUG. Success so far: {name = "Alice"; email = "good";}</span>
</code></pre><span>
</span></div><span>


</span><h2>The railway track functions: A toolkit</h2><span>

</span><p>Let's step back and review what we have done so far.</p><span>

</span><p>Using railway track as a metaphor, we have created a number of useful building blocks that will work with <em>any</em> data-flow style application.</p><span>

</span><p>We can classify our functions roughly like this:</p><span>

</span><ul>
<li><strong>"constructors"</strong> are used to create new track.</li>
<li><strong>"adapters"</strong> convert one kind of track into another.</li>
<li><strong>"combiners"</strong> link sections of track together to make a bigger piece of track.</li>
</ul><span>


</span><p>These functions form what can be loosely called a <em>combinator library</em>, that is, a group of functions that are designed to work with a type (here represented by railway track),
with the design goal that bigger pieces can be built by adapting and combining smaller pieces.</p><span>

</span><p>Functions like <code>bind</code>, <code>map</code>, <code>plus</code>, etc., crop up in all sorts of functional programming scenarios, and so you can think of them as functional patterns -- similar to, but not the same as, the OO patterns such as "visitor", "singleton", "facade", etc.</p><span>

</span><p>Here they all are together:</p><span>

</span><table class="table table-condensed table-striped">

<tbody><tr>
<th>Concept</th>
<th>Description</th>
</tr>

<tr>
<td><code>succeed</code></td>
<td>A constructor that takes a one-track value and creates a two-track value on the Success branch. In other contexts, this might also be called <code>return</code> or <code>pure</code>.</td>
</tr>

<tr>
<td><code>fail</code></td>
<td>A constructor that takes a one-track value and creates a two-track value on the Failure branch.</td>
</tr>

<tr>
<td><code>bind</code></td>
<td>An adapter that takes a switch function and creates a new function that accepts two-track values as input.</td>
</tr>

<tr>
<td><code>&gt;&gt;=</code></td>
<td>An infix version of bind for piping two-track values into switch functions.</td>
</tr>

<tr>
<td><code>&gt;&gt;</code></td>
<td>Normal composition. A combiner that takes two normal functions and creates a new function by connecting them in series.</td>
</tr>

<tr>
<td><code>&gt;=&gt;</code></td>
<td>Switch composition. A combiner that takes two switch functions and creates a new switch function by connecting them in series.</td>
</tr>

<tr>
<td><code>switch</code></td>
<td>An adapter that takes a normal one-track function and turns it into a switch function. (Also known as a "lift" in some contexts.)</td>
</tr>

<tr>
<td><code>map</code></td>
<td>An adapter that takes a normal one-track function and turns it into a two-track function. (Also known as a "lift" in some contexts.)</td>
</tr>

<tr>
<td><code>tee</code></td>
<td>An adapter that takes a dead-end function and turns it into a one-track function that can be used in a data flow. (Also known as <code>tap</code>.)</td>
</tr>

<tr>
<td><code>tryCatch</code></td>
<td>An adapter that takes a normal one-track function and turns it into a switch function, but also catches exceptions.</td>
</tr>

<tr>
<td><code>doubleMap</code></td>
<td>An adapter that takes two one-track functions and turns them into a single two-track function. (Also known as <code>bimap</code>.)</td>
</tr>

<tr>
<td><code>plus</code></td>
<td>A combiner that takes two switch functions and creates a new switch function by joining them in "parallel" and "adding" the results. (Also known as <code>++</code> and <code>&lt;+&gt;</code> in other contexts.)</td>
</tr>

<tr>
<td><code>&amp;&amp;&amp;</code></td>
<td>The "plus" combiner tweaked specifically for the validation functions, modelled on a binary AND.</td>
</tr>

</tbody></table><span>


</span><h3>The railway track functions: complete code</h3><span>

</span><p>Here is the complete code for all the functions in one place.</p><span>

</span><p>I have made some minor tweaks from the original code presented above:</p><span>

</span><ul>
<li>Most functions are now defined in terms of a core function called <code>either</code>.</li>
<li><code>tryCatch</code> has been given an extra parameter for the exception handler.</li>
</ul><span>


</span><div class="highlight"><pre><code class="fsharp"><span class="c1">// the two-track type</span>
<span class="k">type</span> <span class="nc">Result</span><span class="o">&lt;</span><span class="k">'</span><span class="nc">TSuccess</span><span class="o">,</span><span class="k">'</span><span class="nc">TFailure</span><span class="o">&gt;</span> <span class="o">=</span> 
    <span class="o">|</span> <span class="nc">Success</span> <span class="k">of</span> <span class="k">'</span><span class="nc">TSuccess</span>
    <span class="o">|</span> <span class="nc">Failure</span> <span class="k">of</span> <span class="k">'</span><span class="nc">TFailure</span>

<span class="c1">// convert a single value into a two-track result</span>
<span class="k">let</span> <span class="n">succeed</span> <span class="n">x</span> <span class="o">=</span> 
    <span class="nc">Success</span> <span class="n">x</span>

<span class="c1">// convert a single value into a two-track result</span>
<span class="k">let</span> <span class="n">fail</span> <span class="n">x</span> <span class="o">=</span> 
    <span class="nc">Failure</span> <span class="n">x</span>

<span class="c1">// apply either a success function or failure function</span>
<span class="k">let</span> <span class="n">either</span> <span class="n">successFunc</span> <span class="n">failureFunc</span> <span class="n">twoTrackInput</span> <span class="o">=</span>
    <span class="k">match</span> <span class="n">twoTrackInput</span> <span class="k">with</span>
    <span class="o">|</span> <span class="nc">Success</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="n">successFunc</span> <span class="n">s</span>
    <span class="o">|</span> <span class="nc">Failure</span> <span class="n">f</span> <span class="o">-&gt;</span> <span class="n">failureFunc</span> <span class="n">f</span>

<span class="c1">// convert a switch function into a two-track function</span>
<span class="k">let</span> <span class="n">bind</span> <span class="n">f</span> <span class="o">=</span> 
    <span class="n">either</span> <span class="n">f</span> <span class="n">fail</span>

<span class="c1">// pipe a two-track value into a switch function </span>
<span class="k">let</span> <span class="o">(&gt;&gt;=)</span> <span class="n">x</span> <span class="n">f</span> <span class="o">=</span> 
    <span class="n">bind</span> <span class="n">f</span> <span class="n">x</span>

<span class="c1">// compose two switches into another switch</span>
<span class="k">let</span> <span class="o">(&gt;=&gt;)</span> <span class="n">s1</span> <span class="n">s2</span> <span class="o">=</span> 
    <span class="n">s1</span> <span class="o">&gt;&gt;</span> <span class="n">bind</span> <span class="n">s2</span>

<span class="c1">// convert a one-track function into a switch</span>
<span class="k">let</span> <span class="n">switch</span> <span class="n">f</span> <span class="o">=</span> 
    <span class="n">f</span> <span class="o">&gt;&gt;</span> <span class="n">succeed</span>

<span class="c1">// convert a one-track function into a two-track function</span>
<span class="k">let</span> <span class="n">map</span> <span class="n">f</span> <span class="o">=</span> 
    <span class="n">either</span> <span class="o">(</span><span class="n">f</span> <span class="o">&gt;&gt;</span> <span class="n">succeed</span><span class="o">)</span> <span class="n">fail</span>

<span class="c1">// convert a dead-end function into a one-track function</span>
<span class="k">let</span> <span class="n">tee</span> <span class="n">f</span> <span class="n">x</span> <span class="o">=</span> 
    <span class="n">f</span> <span class="n">x</span><span class="o">;</span> <span class="n">x</span> 

<span class="c1">// convert a one-track function into a switch with exception handling</span>
<span class="k">let</span> <span class="n">tryCatch</span> <span class="n">f</span> <span class="n">exnHandler</span> <span class="n">x</span> <span class="o">=</span>
    <span class="k">try</span>
        <span class="n">f</span> <span class="n">x</span> <span class="o">|&gt;</span> <span class="n">succeed</span>
    <span class="k">with</span>
    <span class="o">|</span> <span class="n">ex</span> <span class="o">-&gt;</span> <span class="n">exnHandler</span> <span class="n">ex</span> <span class="o">|&gt;</span> <span class="n">fail</span>

<span class="c1">// convert two one-track functions into a two-track function</span>
<span class="k">let</span> <span class="n">doubleMap</span> <span class="n">successFunc</span> <span class="n">failureFunc</span> <span class="o">=</span>
    <span class="n">either</span> <span class="o">(</span><span class="n">successFunc</span> <span class="o">&gt;&gt;</span> <span class="n">succeed</span><span class="o">)</span> <span class="o">(</span><span class="n">failureFunc</span> <span class="o">&gt;&gt;</span> <span class="n">fail</span><span class="o">)</span>

<span class="c1">// add two switches in parallel</span>
<span class="k">let</span> <span class="n">plus</span> <span class="n">addSuccess</span> <span class="n">addFailure</span> <span class="n">switch1</span> <span class="n">switch2</span> <span class="n">x</span> <span class="o">=</span> 
    <span class="k">match</span> <span class="o">(</span><span class="n">switch1</span> <span class="n">x</span><span class="o">),(</span><span class="n">switch2</span> <span class="n">x</span><span class="o">)</span> <span class="k">with</span>
    <span class="o">|</span> <span class="nc">Success</span> <span class="n">s1</span><span class="o">,</span><span class="nc">Success</span> <span class="n">s2</span> <span class="o">-&gt;</span> <span class="nc">Success</span> <span class="o">(</span><span class="n">addSuccess</span> <span class="n">s1</span> <span class="n">s2</span><span class="o">)</span>
    <span class="o">|</span> <span class="nc">Failure</span> <span class="n">f1</span><span class="o">,</span><span class="nc">Success</span> <span class="o">_</span>  <span class="o">-&gt;</span> <span class="nc">Failure</span> <span class="n">f1</span>
    <span class="o">|</span> <span class="nc">Success</span> <span class="o">_</span> <span class="o">,</span><span class="nc">Failure</span> <span class="n">f2</span> <span class="o">-&gt;</span> <span class="nc">Failure</span> <span class="n">f2</span>
    <span class="o">|</span> <span class="nc">Failure</span> <span class="n">f1</span><span class="o">,</span><span class="nc">Failure</span> <span class="n">f2</span> <span class="o">-&gt;</span> <span class="nc">Failure</span> <span class="o">(</span><span class="n">addFailure</span> <span class="n">f1</span> <span class="n">f2</span><span class="o">)</span>
</code></pre><span>
</span></div><span>


</span><h2>Types vs. shapes</h2><span>

</span><p>So far, we have focused entirely on the shape of the track, not the cargo on the trains.</p><span>

</span><p>This is a magical railway, where the goods being carried can change as they go along each length of track.</p><span>

</span><p>For example, a cargo of pineapples will magically transform into apples when it goes through the tunnel called <code>function1</code>.</p><span>

</span><p><img src="http://fsharpforfunandprofit.com/assets/img/Recipe_Railway_Cargo1.png" alt="pineapples to apples"></p><span>

</span><p>And a cargo of apples will transform into bananas when it goes through the tunnel called <code>function2</code>.</p><span>

</span><p><img src="http://fsharpforfunandprofit.com/assets/img/Recipe_Railway_Cargo2.png" alt="apples to bananas"></p><span>

</span><p>This magical railway has an important rule, namely that you can only connect tracks which carry the same type of cargo.
In this case we <em>can</em> connect <code>function1</code> to <code>function2</code> because the cargo coming out of <code>function1</code> (apples) is the same as the cargo going into <code>function2</code> (also apples).</p><span>

</span><p><img src="http://fsharpforfunandprofit.com/assets/img/Recipe_Railway_Cargo3.png" alt="connecting functions"></p><span>

</span><p>Of course, it is not always true that the tracks carry the same cargo, and a mismatch in the kind of cargo will cause an error.</p><span>

</span><p>But you'll notice that in this discussion so far, we haven't mentioned the cargo once! Instead, we have spent all our time talking about one-track vs. two track functions.</p><span>

</span><p>Of course, it goes without saying that the cargo must match up. But I hope you can see that it is the <em>shape</em> of the track that is really the important thing, not the cargo that is carried.</p><span>

</span><h3>Generic types are powerful</h3><span>

</span><p>Why have we not worried about the type of cargo? Because all the "adapter" and "combiner" functions are completely generic!  The <code>bind</code> and <code>map</code> and <code>switch</code> and <code>plus</code> functions do not care about the type of the cargo, only the <em>shape</em> of the track.</p><span>

</span><p>Having extremely generic functions is a benefit in two ways. The first way is obvious: the more generic a function is, the more reusable it is. The implementation of <code>bind</code> will work with any types (as long as the shape is right).</p><span>

</span><p>But there is another, more subtle aspect of generic functions that is worth pointing out. Because we generally know <em>nothing</em> about the types involved, we are very constrained in what we can and can't do. As a result, we can't introduce bugs!</p><span>

</span><p>To see what I mean, let's look at the signature for <code>map</code>:</p><span>

</span><div class="highlight"><pre><code class="fsharp"><span class="k">val</span> <span class="n">map</span> <span class="o">:</span> <span class="o">(</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nc">Result</span><span class="o">&lt;</span><span class="k">'</span><span class="n">a</span><span class="o">,</span><span class="k">'</span><span class="n">c</span><span class="o">&gt;</span> <span class="o">-&gt;</span> <span class="nc">Result</span><span class="o">&lt;</span><span class="k">'</span><span class="n">b</span><span class="o">,</span><span class="k">'</span><span class="n">c</span><span class="o">&gt;)</span>
</code></pre><span>
</span></div><span>


</span><p>It takes a function parameter <code>'a -&gt; 'b</code> and a value <code>Result&lt;'a,'c&gt;</code> and returns a value <code>Result&lt;'b,'c&gt;</code>.</p><span>

</span><p>We don't know anything about the types <code>'a</code>, <code>'b</code>, and <code>'c</code>. The only things we know are that:</p><span>

</span><ul>
<li>The <em>same</em> type <code>'a</code> shows up in both the function parameter and the <code>Success</code> case of the first <code>Result</code>.</li>
<li>The <em>same</em> type <code>'b</code> shows up in both the function parameter and the <code>Success</code> case of the second <code>Result</code>.</li>
<li>The <em>same</em> type <code>'c</code> shows up in the <code>Failure</code> cases of both the first and second <code>Result</code>s, but doesn't show up in the function parameter at all.</li>
</ul><span>


</span><p>What can we deduce from this?</p><span>

</span><p>The return value has a type <code>'b</code> in it. But where does it come from?  We don't know what type <code>'b</code> is, so we don't know how to make one. But the function parameter knows how to make one! Give it an <code>'a</code> and it will make a <code>'b</code> for us.</p><span>

</span><p>But where can we get an <code>'a</code> from? We don't know what type <code>'a</code> is either, so again we don't know how to make one. But the first result parameter has an <code>'a</code> we can use, so you can see that we are <em>forced</em> to get the <code>Success</code> value from the <code>Result&lt;'a,'c&gt;</code> parameter and pass it to the function parameter. And then the <code>Success</code> case of the <code>Result&lt;'b,'c&gt;</code> return value <em>must</em> be constructed from the result of the function.</p><span>

</span><p>Finally, the same logic applies to <code>'c</code>. We are forced to get the <code>Failure</code> value from the <code>Result&lt;'a,'c&gt;</code> input parameter and use it to construct the <code>Failure</code> case of the <code>Result&lt;'a,'c&gt;</code> return value.</p><span>

</span><p>In other words, there is basically <em>only one way to implement the <code>map</code> function</em>! The type signature is so generic that we have no choice.</p><span>

</span><p>On the other hand, imagine that the <code>map</code> function had been very specific about the types it needed, like this:</p><span>

</span><div class="highlight"><pre><code class="fsharp"><span class="k">val</span> <span class="n">map</span> <span class="o">:</span> <span class="o">(</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nc">Result</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">,</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">-&gt;</span> <span class="nc">Result</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">,</span><span class="kt">int</span><span class="o">&gt;)</span>
</code></pre><span>
</span></div><span>


</span><p>In this case, we can come up a huge number of different implementations. To list a few:</p><span>

</span><ul>
<li>We could have swapped the success and failure tracks.</li>
<li>We could have added a random number to the success track.</li>
<li>We could have ignored the function parameter altogether, and returned zero on both the success and failure tracks.</li>
</ul><span>


</span><p>All of these implementations are "buggy" in the sense that they don't do what we expect.  But they are all only possible because we know in advance that the type is <code>int</code>, and therefore we can manipulate the values in ways we are not supposed to. The less we know about the types, the less likely we are to make a mistake.</p><span>

</span><h3>The failure type</h3><span>

</span><p>In most of our functions, the transformation only applies to the success track. The failure track is left alone (<code>map</code>), or merged with an incoming failure (<code>bind</code>).</p><span>

</span><p>This implies that the failure track must be <em>same type</em> all the way through. In this post we have just used <code>string</code>, but in the next post we'll change the failure type to be something more useful.</p><span>

</span><h2>Summary and guidelines</h2><span>

</span><p>At the beginning of this series, I promised to give you a simple recipe that you could follow.</p><span>

</span><p>But you might be feeling a bit overwhelmed now. Instead of making things simpler, I seem to have made things more complicated. I have shown you lots of different ways of doing the same thing! Bind vs. compose. Map vs. switch. Which approach should you use? Which way is best?</p><span>

</span><p>Of course, there is never one "right way" for all scenarios, but nevertheless, as promised, here are some guidelines that can be used as the basis of a reliable and repeatable recipe.</p><span>

</span><p><em>Guidelines</em></p><span>

</span><ul>
<li>Use double-track railway as your underlying model for dataflow situations.</li>
<li>Create a function for each step in the use case. The function for each step can in turn be built from smaller functions (e.g. the validation functions).</li>
<li>Use standard composition (<code>&gt;&gt;</code>) to connect the functions.</li>
<li>If you need to insert a switch into the flow, use <code>bind</code>.</li>
<li>If you need to insert a single-track function into the flow, use <code>map</code>.</li>
<li>If you need to insert other types of functions into the flow, create an appropriate adapter block and use it.</li>
</ul><span>


</span><p>These guidelines may result in code that is not particularly concise or elegant, but on the other hand, you will be using a consistent model, and it should be understandable to other people when it needs to be maintained.</p><span>

</span><p>So with these guidelines, here are the main bits of the implementation so far. Note especially the use of <code>&gt;&gt;</code> everywhere in the final <code>usecase</code> function.</p><span>

</span><div class="highlight"><pre><code class="fsharp"><span class="k">open</span> <span class="nc">RailwayCombinatorModule</span> 

<span class="k">let</span> <span class="o">(&amp;&amp;&amp;)</span> <span class="n">v1</span> <span class="n">v2</span> <span class="o">=</span> 
    <span class="k">let</span> <span class="n">addSuccess</span> <span class="n">r1</span> <span class="n">r2</span> <span class="o">=</span> <span class="n">r1</span> <span class="c1">// return first</span>
    <span class="k">let</span> <span class="n">addFailure</span> <span class="n">s1</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">s1</span> <span class="o">+</span> <span class="s2">"; "</span> <span class="o">+</span> <span class="n">s2</span>  <span class="c1">// concat</span>
    <span class="n">plus</span> <span class="n">addSuccess</span> <span class="n">addFailure</span> <span class="n">v1</span> <span class="n">v2</span> 

<span class="k">let</span> <span class="n">combinedValidation</span> <span class="o">=</span> 
    <span class="n">validate1</span> 
    <span class="o">&amp;&amp;&amp;</span> <span class="n">validate2</span> 
    <span class="o">&amp;&amp;&amp;</span> <span class="n">validate3</span> 

<span class="k">let</span> <span class="n">canonicalizeEmail</span> <span class="n">input</span> <span class="o">=</span>
   <span class="o">{</span> <span class="n">input</span> <span class="k">with</span> <span class="n">email</span> <span class="o">=</span> <span class="n">input</span><span class="o">.</span><span class="n">email</span><span class="o">.</span><span class="nc">Trim</span><span class="bp">()</span><span class="o">.</span><span class="nc">ToLower</span><span class="bp">()</span> <span class="o">}</span>

<span class="k">let</span> <span class="n">updateDatabase</span> <span class="n">input</span> <span class="o">=</span>
   <span class="bp">()</span>   <span class="c1">// dummy dead-end function for now</span>

<span class="c1">// new function to handle exceptions</span>
<span class="k">let</span> <span class="n">updateDatebaseStep</span> <span class="o">=</span> 
    <span class="n">tryCatch</span> <span class="o">(</span><span class="n">tee</span> <span class="n">updateDatabase</span><span class="o">)</span> <span class="o">(</span><span class="k">fun</span> <span class="n">ex</span> <span class="o">-&gt;</span> <span class="n">ex</span><span class="o">.</span><span class="nc">Message</span><span class="o">)</span>

<span class="k">let</span> <span class="n">usecase</span> <span class="o">=</span> 
    <span class="n">combinedValidation</span> 
    <span class="o">&gt;&gt;</span> <span class="n">map</span> <span class="n">canonicalizeEmail</span>
    <span class="o">&gt;&gt;</span> <span class="n">bind</span> <span class="n">updateDatebaseStep</span>
    <span class="o">&gt;&gt;</span> <span class="n">log</span>
</code></pre><span>
</span></div><span>


</span><p>One final suggestion. If you are working with a team of non-experts, unfamiliar operator symbols will put people off. So here some extra guidelines with respect to operators:</p><span>

</span><ul>
<li>Don't use any "strange" operators other than <code>&gt;&gt;</code> and <code>|&gt;</code>.</li>
<li>In particular, that means you should <em>not</em> use operators like <code>&gt;&gt;=</code> or <code>&gt;=&gt;</code> unless everyone is aware of them.</li>
<li>An exception can be made if you define the operator at the top of the module or function where it is used. For example, the <code>&amp;&amp;&amp;</code> operator could be defined at the top of the validation module and then used later in that same module.</li>
</ul><span>


</span><h2>Further reading</h2><span>

</span><ul>
<li>If you like this "railway oriented" approach, you can also <a href="http://fsharpforfunandprofit.com/posts/railway-oriented-programming-carbonated/">see it applied to FizzBuzz</a>.</li>
<li>I also have some <a href="http://fsharpforfunandprofit.com/rop/">slides and video</a> that show how take this approach further. (At some point I will turn these into a proper blog post)</li>
</ul><span>


</span><p>I presented on this topic at NDC Oslo 2014 (click image to view video)</p><span>

</span><p><a href="http://vimeo.com/97344498"><img src="http://fsharpforfunandprofit.com/assets/img/rop-ndcoslo.jpg" alt="Video from NDC Oslo 2014"></a></p><span>

</span><p>And here are the slides I used:</p><span>

</span><span>


</span><span>


			
	</span><span>
	
	
	</span><div class="well"><span>
	    </span><a name="series-toc"></a><span>
		</span><h4>The "A recipe for a functional app" series</h4><span>
		
		
			
			</span><span>
			
			
		
		
			
			</span><p>2. Railway oriented programming</p><span>
			
			
		
		
			
			</span><span>
			
			
		
	</span></div><span>



	
	</span><h4>Comments</h4><span>
</span><span>
</span><script type="text/javascript">
	if (window.location.host == 'localhost:4000'){disqus_developer = 1}else{disqus_developer = 0} // developer mode is on

    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'fforfunandprofit'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script><span>
</span><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript><span>
</span><a href="http://disqus.com/" class="dsq-brlink">blog comments powered by </a><span>
</span></div>
            </div>
            <script>var _gaq = _gaq || []; _gaq.push(['_setAccount', 'UA-34802167-1']); _gaq.push(['_setDomainName', 'liuzhe.co']); _gaq.push(['_trackPageview']); (function() { var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true; ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'; var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s); })();</script>
        </body>
        </html>