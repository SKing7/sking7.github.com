<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Dev.Opera — Everything You Need to Know About the CSS will-change Property</title>
<link rel="stylesheet" href="../css/article.css" />
</head>
<body>
<div class="m-content">
<h1>Dev.Opera — Everything You Need to Know About the CSS will-change Property</h1>
<div><h2 id="introduction">Introduction</h2><p>If you’ve ever noticed “that flicker” in WebKit-based browsers while performing certain CSS operations, especially CSS transforms and animations, then you’ve most likely come across the term “hardware acceleration” before.</p><h2 id="the-cpu-gpu-and-hardware-acceleration">The CPU, GPU, and Hardware Acceleration</h2><p>In a nutshell, <em>Hardware acceleration</em> means that the <strong>Graphics Processing Unit</strong> (GPU) will assist your browser in rendering a page by doing some of the heavy lifting, instead of throwing it all onto the <strong>Central Processing Unit</strong> (CPU) to do. When a CSS operation is hardware-accelerated, it usually gets a speed boost as the page rendering gets faster.</p><p>As their names show, both the CPU and the GPU are processing units. The CPU is located on the computer’s motherboard; it processes almost everything and is known as the brain of the computer. The GPU is located on the graphics card of the computer, and is responsible for processing and rendering graphics. Moreover, a GPU is designed specifically for performing the complex mathematical and geometric calculations that are necessary for graphics rendering. Hence, offloading operations onto the GPU can yield massive performance gains and can also reduce CPU contention on mobile devices.</p><p>Hardware acceleration (a.k.a. GPU acceleration) relies on a <em>layering model</em> used by the browser as it renders a page. When certain operations (such as 3D transforms) are performed on an element on a page, that element is moved to its own “layer”, where it can render independently from the rest of the page and be <em>composited in</em> (drawn onto the screen) later. This isolates the rendering of the content so that the rest of the page doesn’t have to be rerendered if the element’s transform is the only thing that changes between frames, and often provides significant speed benefits. It is worth mentioning here that only 3D transforms qualify for their own layer; 2D transforms don’t.</p><p>CSS animations, transforms and transitions are not automatically GPU accelerated, and instead execute from the browser’s slower software rendering engine. However, some browsers provide <a href="http://www.html5rocks.com/en/tutorials/speed/high-performance-animations/">hardware acceleration by means of certain properties</a> to provide better rendering performance. For example, the <code>opacity</code> property is one of the few CSS properties that can be properly accelerated because the GPU can manipulate it easily. Basically, any layer where you want to fade the opacity over a CSS transition or animation, the browser is actually smart enough to throw it onto the GPU and do the manipulation over there and it’s going to be very fast. Of all CSS things, opacity is one of the most performant and you’re not going to have problems using it. Other common hardware-accelerated operations are CSS 3D transforms.</p><h2 id="the-old-the-translatez-or-translate3d-hack">The Old: The <code>translateZ()</code> (or <code>translate3d()</code>) Hack</h2><p>For quite some time now, we’ve been using what has been known as the <code>translateZ()</code> (or <code>translate3d()</code>) hack (sometimes also called the null transform hack) to <strong>trick the browser</strong> into pushing our animations and transforms into hardware acceleration. We’ve been doing that by adding a simple 3D transformation to an element that will <em>not</em> be transforming in three-dimensional space. For example, an element that’s animated in two-dimensional space can be hardware-accelerated by adding this simple rule to it:</p><pre><code>transform: translate3d(0, 0, 0);
</code></pre><p>Hardware-accelerating an operation results in the creation of what is known as a compositor layer that is uploaded to and composited by the GPU. However, force-hacking layer creation may not always be the solution to certain performance bottlenecks on a page. Layer creation techniques can boost page speed, but they come with a cost: they take up memory in system RAM and on the GPU (particularly limited on mobile devices) and having lots of them can have a bad impact (especially on mobile devices), so they must be used wisely and you need to make sure that hardware-accelerating your operation will really help the performance of your page, and that a performance bootleneck is not being caused by another operation on your page.</p><p>In order to avoid layer-creation hacks, a new CSS property has been introduced, that allows us to inform the browser ahead of time of what kinds of changes we are likely to make to an element, thus allowing it to optimize how it handles the element ahead of time, performing potentially-expensive work preparing for an operation such as an animation, for example, before the animation actually begins. This property is the new <code>will-change</code> property.</p><h2 id="the-new-the-glorious-will-change-property">The New: The Glorious <code>will-change</code> Property</h2><p>The <code>will-change</code> property allows you to inform the browser ahead of time of what kinds of changes you are likely to make to an element, so that it can set up the appropriate optimizations before they’re needed, therefore avoiding a non-trivial start-up cost which can have a negative effect on the responsiveness of a page. The elements can be changed and rendered faster, and the page will be able to update snappily, resulting in a smoother experience.</p><p>For example, when using CSS 3D Transforms on an element, the element and its contents might be promoted to a layer, as we mentioned earlier, before they are composited in (drawn onto the screen) later. However, setting up the element in a fresh layer is a relatively expensive operation, which can delay the start of a transform animation by a noticeable fraction of a second, causing that noticable “flicker”.</p><p>In order to avoid this delay, you can inform the browser about the changes some time <em>before</em> they actually happen. That way, it will have some time to prepare for these changes, so that when these changes occur, the element’s layer will be ready and the transform animation can be performed and then the element can be rendered and the page updated in quickly.</p><p>Using <code>will-change</code>, hinting to the browser about an upcoming transformation can be as simple as adding this rule to the element that you’re expecting to be transformed:</p><pre><code>will-change: transform;
</code></pre><p>You can also declare to the browser your intention to change an element’s scroll position (the element’s position in the visible scroll window and how much of it is visible within that window), its contents, or one or more of its CSS property values by specifying the name of the properties you’re expecting to change. If you expect or plan to change mutliple values/aspects of an element, you can provide a list of comma-separated values. For example, if you’re expecting the element to be animated and moved (its position changed), you can declare that to the browser like so:</p><pre><code>will-change: animation, position;
</code></pre><p>Specifying what exactly you want to change allows the browser to make better decisions about the optimizations that it needs to make for these particular changes. This is obviously a better way to achieve a speed boost without resorting to hacks and forcing the browser into layer creations that may or may not be necessary or useful.</p><h3 id="does-will-change-affect-the-element-it-is-applied-to-beyond-hinting-the-browser-about-the-changes-to-that-element">Does <code>will-change</code> affect the element it is applied to beyond hinting the browser about the changes to that element?</h3><p>The answer is yes and no—it depends on the properties that you’re specifying and informing the browser about. If any non-initial value of a property would create a <a href="http://reference.sitepoint.com/css/stacking">stacking</a> <a href="http://www.w3.org/TR/CSS2/zindex.html">context</a> on the element, specifying that property in <code>will-change</code> will create a stacking context on the element.</p><p>For example, the <code>clip-path</code> property and the <code>opacity</code> property both lead to the creation of a stacking context on the element they are applied to, when they are used with values other than their initial values. Hence, using one of (or both of) these properties as values for <code>will-change</code> will create a stacking context on the element, <strong>even before the change actually happens</strong>. The same applies to other properties that would create a stacking context on an element.</p><p>Also, some properties can lead to the creation of a <strong>containing block</strong> for fixed-position elements. For example, a <a href="http://meyerweb.com/eric/thoughts/2011/09/12/un-fixing-fixed-elements-with-css-transforms/">transformed element creates a containing block for all its positioned descendants</a>, even those that have been set to <code>position: fixed</code>. So, if a property leads to the creation of a containing block, then specifying it as a value for <code>will-change</code> will also lead to the generation of a containing block for fixed-position elements.</p><p>Other than that, the <code>will-change</code> property has no direct effect on the element it is applied to—it is merely a rendering hint to the browser allowing it to set up optimizations for the changes that will occur to that element. It has no direct effect on an element beyond the creation of stacking contexts and containing blocks in the situations mentioned above.</p><h2 id="using-will-change-the-dos-and-the-donts">Using <code>will-change</code>: The Do’s and The Don’ts</h2><p>Knowing what <code>will-change</code> does, it can be very tempting to think: “Just have the browser optimize EVERYTHING!”. I mean it makes sense, right? Who wouldn’t want all of their changes to be optimized for and ready to roll on demand?</p><p>As powerful and great as <code>will-change</code> is, it’s not any different from any other kind of power, so, as with other sources of power, there comes responsibility. <code>will-change</code> should be used wisely, otherwise it will end up resulting in performance hits that could actually crash your page.</p><p>As with any performance hints, <code>will-change</code> has its side effects that aren’t directly detectable (after all, it is just a way to talk to the browser behind the scenes), so it may be tricky to use. Here are some things to keep in mine when you use this property, to make sure you get the best out of it while avoiding the harm that can come from misusing it.</p><h3 id="dont-use-will-change-to-declare-changes-to-too-many-properties-or-elements">Don’t Use <code>will-change</code> to Declare Changes to Too Many Properties or Elements</h3><p>As I mentioned earlier, it might be very tempting to just tell the browser to optimize for changes that may occur to <em>all</em> properties on <em>all</em> elements; so adding the following rule to our style sheet might make some sense at first:</p><pre><code>*,
*::before,
*::after {
	will-change: all;
}
</code></pre><p>As good as this looks (I know it looked good and made sense to me at first), this is in fact very harmful, and more so invalid. Not only is the all keyword an invalid value for <code>will-change</code> (we’ll cover the list of valid and invalid values later in the article), but such a blanket rule wouldn’t be useful. You see, the browser <strong>does already try to optimize for everything</strong> as much as it can (remember <code>opacity</code> and 3D transforms?), so explicitly telling it to do that doesn’t really change anything or help in any way. As a matter of fact, doing this has the capacity to do a lot of harm, because some of the stronger optimizations that are likely to be tied to <code>will-change</code> end up using a lot of a machine’s resources, and when overused like this can cause the page to slow down or even crash.</p><p>In other words, putting the browser on guard for changes that may or may not occur is a bad idea, and will do more harm that good. <strong>Don’t do it.</strong></p><h3 id="give-the-browser-enough-time-to-work">Give the Browser Enough Time to Work</h3><p>The <code>will-change</code> property is named like that for an obvious reason: informing the browser about changes that <strong>will</strong> occur, not changes that <strong>are</strong> occuring. Using <code>will-change</code>, we’re asking the browser to make certain optimizations for the changes we’re declaring, and in order for that to happen, the browser needs some time to actually make these optimizations, so that when the changes occur, the optimizations can be applied without any delays.</p><p>Setting <code>will-change</code> on an element immediately before it changes has little to no effect. (It might actually be worse than not setting it at all. You could incur the cost of a new layer when what you’re animating wouldn’t have previously qualified for a new layer!) For example, if a change is going to happen on hover, then this:</p><pre><code>.element:hover {
	will-change: animation;
	animation: my-anim 2s linear infinite alternate;
}
</code></pre><p>…tells the browser to make optimizations for a change that is already taking place, and that’s useless and kind of negates the whole concept behind <code>will-change</code>. Instead, you should find a way to to predict at least slightly ahead of time that something will change, and set <code>will-change</code> <em>then</em>.</p><p>For example, if an element will change when it is clicked, then setting up <code>will-change</code> when that element is hovered gives the browser enough time to optimize for that change. The time between hovering the element and actually clicking it by the user is enough for the browser to set up the optimizations, because human reaction time is relatively slow, so this will give the browser around 200ms time window before the change actually happens, and this is enough for it to set up the optimizations.</p><pre><code>.element {
	/* style rules */
	transition: transform 1s ease-out;
}
.element:hover {
	will-change: transform;
}
.element:active {
	transform: rotateY(180deg);
}
</code></pre><p>But what if you expect the change to happen <strong>on hover</strong>, not on click? The above declaration will be useless as we mentioned. In this case, it is often still possible to find <em>some</em> way to predict the action before it occurs. For example, hovering an ancestor of the changing element may give enough lead time:</p><pre><code>.element {
	transition: opacity .3s linear;
}
/* declare changes on the element when the mouse enters / hovers its ancestor */
.ancestor:hover .element {
	will-change: opacity;
}
/* apply change when element is hovered */
.element:hover {
	opacity: .5;
}
</code></pre><p>However, hovering the ancestor does not always indicate that the element will be interacted with for sure, so you could do something like set <code>will-change</code> when a view becomes active in your application, or if the element is within the visible part of the viewport, which increases the chances of the element being interacted with.</p><h3 id="remove-will-change-after-the-changes-are-done">Remove <code>will-change</code> After the Changes Are Done</h3><p>The optimizations that the browser makes for changes that are about to occur are usually costly and, as we mentioned earlier, can take up much of the machine’s resources. The usual browser behavior for optimizations that it makes is to remove these optimzations and revert back to normal behavior as soon as it can. However, <code>will-change</code> <strong>overrides this behavior</strong> maintaining the optimizations for much longer than the browser would otherwise do.</p><p>As such, you should always remember to <em>remove</em> <code>will-change</code> after the element is done changing, so the browser can recover whatever resources the optimizations are claiming.</p><p>It’s not possible to remove <code>will-change</code> if it is declared in the style sheet, which is why it is almost always recommended that you set and unset it using JavaScript. By scripting, you can declare your changes to the browser, and then remove <code>will-change</code> after the changes are done, by listening to when these changes have finished. For example, just like we did in the style rules in the previous section, you could listen for when the element (or its ancestor) is hovered, and then set <code>will-change</code> on <code>mouseenter</code>. If your element is being animated, you can listen for when the animation has ended using the DOM event <code>animationEnd</code>, and then remove <code>will-change</code> once <code>animationEnd</code> is fired.</p><pre><code>// Rough generic example
// Get the element that is going to be animated on click, for example
var el = document.getElementById('element');

// Set will-change when the element is hovered
el.addEventListener('mouseenter', hintBrowser);
el.addEventListener('animationEnd', removeHint);

function hintBrowser() {
	this.style.willChange = 'animation';
}

function removeHint() {
	this.style.willChange = 'auto';
}
</code></pre><p>Craig Buckler has written <a href="http://www.sitepoint.com/css3-animation-javascript-event-handlers/">an article</a> about capturing CSS animation events in JavaScript that you should check out if you’re not familiar with this. There’s also an article about <a href="http://css-tricks.com/controlling-css-animations-transitions-javascript/">controlling CSS animations and transitions</a> on CSS-Tricks that’s also worth checking out.</p><h3 id="use-will-change-sparingly-in-style-sheets">Use <code>will-change</code> Sparingly in Style Sheets</h3><p>As we’ve seen in the previous section, <code>will-change</code> can be used to hint the browser about changes that are just about to occur to an element within a few milliseconds. This is one of the use cases where declaring <code>will-change</code> in a style sheet is okay. Although it’s recommended to set and unset <code>will-change</code> using JavaScript, there are some situations where setting it in the style sheet (and keeping it) is appropriate.</p><p>One example is setting <code>will-change</code> on a small number of elements that are likely to be interacted with by the user over and over again, and that should respond to the user’s interaction in a snappy manner. The limited number of elements means that the optimizations made by the browser won’t be overused and therefore won’t hurt as much. For example, transforming a sidebar by sliding it out when the user requests it. The following rule would be appropriate:</p><pre><code>.sidebar {
	will-change: transform;
}
</code></pre><p>Another example is using <code>will-change</code> on an element that changes nearly constantly, like an element that responds to the user’s mouse movement and is moved around the screen as the mouse moves. In this case, just declaring the will-change value in the stylesheet is fine, as it accurately describes that the element will regularly/constantly change, and so should be kept optimized.</p><pre><code>.annoying-element-stuck-to-the-mouse-cursor {
	will-change: left, top;
}
</code></pre><h3 id="will-change-property-values"><code>will-change</code> Property Values</h3><p>The <code>will-change</code> property takes one of four possible values: <code>auto</code>, <code>scroll-position</code>, <code>contents</code>, and <code>&lt;custom-ident&gt;</code>.</p><p>The <code>&lt;custom-ident&gt;</code> value is used to specify the name(s) of one or more properties that you expect to change. Multiple properties are comma-separated. The following are examples of valid <code>will-change</code> declarations with specified property names:</p><pre><code>will-change: transform;
will-change: animation, position;
will-change: top, left, bottom;
will-change: opacity;
</code></pre><p>The <code>&lt;custom-ident&gt;</code> value excludes the keywords <code>will-change</code>, <code>none</code>, <code>all</code>, <code>auto</code>, <code>scroll-position</code>, and <code>contents</code>, in addition to the keywords normally excluded from <a href="http://dev.w3.org/csswg/css-values-3/#identifier-value"><code>&lt;custom-ident&gt;</code></a>. So, as we mentioned in the beginning of the article, the <code>will-change: all</code> declaration is invalid and will thus be ignored by the browser.</p><p>The value <code>auto</code> indicates no particular intent, meaning that the browser will not set up any special optimizations other than the ones it normally does.</p><p>The <code>scroll-position</code> value indicates, as the name suggests, that you expect to change an element’s scroll position any time in the near future. This value is useful because, when used, the browser will prepare for and render content beyond that which is visible in the scroll window on a scrollable element. Browsers often only render the content <em>in</em> the scroll window, and some of the content past that window, balancing memory and time savings from the skipped rendering against making scrolling look nice. Using <code>will-change: scroll-position</code>, it can make further rendering optimizations so that longer and/or faster content scrolls can be done smoothly.</p><p>The <code>contents</code> value indicates that the element’s content is expected to change. Browsers usually “cache” rendering of elements over time, because most things don’t change very often, or only change their position. This value will be read by the browser as a signal to do less caching on the element, or avoid caching on the element altogether, because if the element’s content is regularly changing, then keeping a cache of the content will be useless and a waste of time, so the browser will just stop caching and continue rendering the element from scratch whenever its content changes.</p><p>As mentioned before, some properties will have no effect when specified in <code>will-change</code>, because the browser doesn’t perform any special optimizations for changes in most properties. It is still safe to specify them, though; it’ll simply have no effect. Other properties may result in the creation of stacking contexts (<code>opacity</code>, <code>clip-path</code>, etc.) and/or containing blocks.</p><h2 id="browser-support">Browser Support</h2><p>At the time of writing of this article, only WebKit and Firefox Nightly builds have implemented the <code>will-change</code> property. There is also <a href="https://groups.google.com/a/chromium.org/forum/#!topic/blink-dev/LwvyVCMQx1k">an intent to ship in Blink</a> too. And word says that it won’t be long before it is supported in all modern browsers.</p><h2 id="final-words">Final Words</h2><p>The <code>will-change</code> property is a will help us write hack-free performance-optimized code, and emphasize the importance of speed and performance to our CSS operations. But, as with all things, with great power comes great reponsibility, and <code>will-change</code> is one of those properties that should not be taken lightly and should be used wisely. At this point, I’m going to quote Tab Atkins Jr., the <code>will-change</code> <a href="http://dev.w3.org/csswg/css-will-change/">specification</a> editor:</p><blockquote><p>Set <code>will-change</code> to the properties you’ll actually change, on the elements that are actually changing. And remove it when they stop.</p></blockquote><p>Thank you for reading!</p><p><em>A very big thank you to Paul Lewis for his review and feedback, and to Tab Atkins for his support and answers, and to Bruce Lawson and Mathias Bynens for reviewing the article.</em></p></div></div>
<script>var _gaq = _gaq || []; _gaq.push(['_setAccount', 'UA-34802167-1']); _gaq.push(['_setDomainName', 'liuzhe.co']); _gaq.push(['_trackPageview']); (function() { var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true; ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'; var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s); })();</script></body>
</html>