<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Rethinking JavaScript’s Try/Catch | Flippin' Awesome</title>
<link rel="stylesheet" href="../css/article.css" />
</head>
<body>
<div class="m-content">
<h1>Rethinking JavaScript’s Try/Catch | Flippin' Awesome</h1>
<div><p><em>By <a href="/authors/ryan-morr">Ryan Morr</a></em></p><p>The try/catch block is a unique construct, both in how it works and what it is capable of. Fundamentally, it is able to isolate one or more statements to capture and suppress any runtime errors that may be encountered as a result of execution. It is such a powerful construct that in a perfect world you would want to wrap everything in a try/catch block to provide simple and effective error trapping. However, due to concerns in performance critical situations, employing it is often frowned upon in JavaScript. But what if I told you there was a means of emulating the try/catch block in JavaScript without the concern for performance? This article will be exploring just such a method.</p><h2>Performance Implications of the Try/Catch Block</h2><p>What makes this construct unique is in the manner in which the catch block augments the scope chain. Rather than creating a new execution context and pushing it to the top of the execution stack, the catch block will actually create a new variable object and place it ahead of the activation object in the scope chain of the current execution context. This creates what is known as a&nbsp;<em>dynamic scope</em>, similar to the effect of the <code>with</code>&nbsp;statement, which lends to its bad reputation as well. As a result, the <code>error</code> object passed to the catch block does not exist outside of it, even within the same scope. It is created at the start of the <code>catch</code> clause and destroyed at the end of it. This type of manipulation of the scope chain is the primary reason for the performance hit.</p><p>At this point you may be thinking that as long as an error is not raised than performance should not be affected. That is a fair assumption, but you’d be wrong. Some JavaScript engines, such as V8 (Chrome) do not optimize functions that make use of a try/catch block as the optimizing compiler will skip it when encountered. No matter what context you use a try/catch block in, there will always be an inherent performance hit, quite possibly a substantial one.</p><p>These limitations are well documented, for instance, look at the following test cases:&nbsp;<a href="http://jsperf.com/try-catch-block-performance-comparison" onclick="javascript:_gaq.push(['_trackEvent','outbound-article','http://jsperf.com']);" target="_blank">http://jsperf.com/try-catch-block-performance-comparison</a>and&nbsp;<a href="http://jsperf.com/try-catch-block-loop-performance-comparison" onclick="javascript:_gaq.push(['_trackEvent','outbound-article','http://jsperf.com']);" target="_blank">http://jsperf.com/try-catch-block-loop-performance-comparison</a>. The former confirms that not only is there up to a 90% loss in performance when no error even occurs, but the performance is significantly worse when an error is raised and control enters the catch block. The latter test case proves that the loss is compounded in loops, where most performance intensive operations typically occur.</p><h2>The Solution</h2><p>To find a suitable alternative, we require a reliable means of error notification. For this, there is really only one viable source in the browser we can turn to for error trapping, that being&nbsp;<code>window.onerror</code>. The question is, can we leverage the event as a means of closely mimicking the functionality of a try/catch block? The answer is yes…for the most part. The event is capable of detecting runtime errors including any errors that you explicitly throw yourself. We can also imitate the error suppression of a <code>catch</code> block by returning false from&nbsp;<code>window.onerror</code>, while returning true allows the error to propagate to the browser.</p><p>With these advantages, creating a custom alternative that is capable of simulating the primary functionality of a try/catch block becomes rather easy. In its simplest form, the solution involves temporarily caching a <code>catch</code> function before invoking a <code>try</code> function, then quickly nullifying the <code>catch</code> function after the <code>try</code> function has completed execution. This allows us to reliably resolve the source of an error when one is encountered. We then invoke the associated <code>catch</code> handler passing an error object constructed from the message, file name, and line number provided to the&nbsp;<code>window.onerror</code>&nbsp;event handler:</p><pre><code>(function(win){
    "use strict";

    var callback = null, handler = win.onerror;

    win.tryCatch = function(tryFn, catchFn){
        callback = catchFn;
        tryFn();
        callback = null;
    };

    win.onerror = function(msg, file, line){
        var error = new Error(), suppress;
        error.message = msg;
        error.fileName = file;
        error.lineNumber = line;
        if(callback){
            suppress = callback(error);
            callback = null;
            return suppress === false ? false : true;
        }
        return handler ? handler.apply(win, arguments) : false;
    };

})(this);</code></pre><p>The function, appropriately named&nbsp;<code>tryCatch</code>, allows us to wrap error-prone or sensitive code in a similar fashion as a try/catch block. The syntax is similar as well, the exception being the use of functions instead of block statements, such as the following:</p><pre><code>tryCatch(function(){
    // try something    
}, function(error){
    // handle error
});</code></pre><p>One of the advantages to this approach is the countless ways we can augment and expand the method to suit various needs. For example, we could add greater debugging capabilities by storing additional information about the source of an error such as the test function itself or any variables the function makes use of. This could help expand error logging to better understand where and why an error took place.</p><h2>Performance Comparison</h2><p>When we measure the performance of this custom solution against a try/catch block, we get some interesting results. Based on some preliminary tests, I found performance comparisons between the browsers fairly inconsistent. Firefox, IE, and Opera all showed improved performance using the&nbsp;<code>tryCatch</code>&nbsp;function as opposed to a try/catch block, while the results were opposite for Chrome and Safari. However, when we avoid needlessly creating anonymous functions for every invocation of the&nbsp;<code>tryCatch</code>&nbsp;function and instead use predefined functions, performance actually improves quite a bit in all browsers. Check out the results and try it yourself at:&nbsp;<a href="http://jsperf.com/native-try-catch-vs-custom-try-catch/7" onclick="javascript:_gaq.push(['_trackEvent','outbound-article','http://jsperf.com']);" target="_blank">http://jsperf.com/native-try-catch-vs-custom-try-catch/7</a>. The real advantages come inside loops, in this case performance increased dramatically in most browsers:&nbsp;<a href="http://jsperf.com/native-try-catch-vs-custom-trycatch-loop" onclick="javascript:_gaq.push(['_trackEvent','outbound-article','http://jsperf.com']);" target="_blank">http://jsperf.com/native-try-catch-vs-custom-trycatch-loop</a>.</p><h2>Drawbacks</h2><p>Despite some of the advantages to this approach, it is not without its caveats. Most of these disadvantages are closely related to the <code>window.onerror</code>&nbsp;event and can be avoided if used properly in the right circumstances.</p><p>One such disadvantage is when the <code>catch</code> handler is invoked in the case of an error and another error occurs within the handler, then both errors will propagate to the browser. This happens because control still hasn’t left the&nbsp;<code>window.onerror</code>&nbsp;event handler from the initial error, raising another error will stop execution and fall back to the default behaviour.</p><p>There is also a lack of information available beyond the message, fil<code>e name, and line number of the error provided to the&nbsp;window.onerror</code> event handler. We don’t get the error type contained in the&nbsp;name&nbsp;property of an error object, although Firefox does prepend this to the message itself. We also don’t get a stack trace, simple reason being that a stack trace is related to an execution context, whereas <code>window.onerror</code>&nbsp;is invoked in the global execution context. These omissions do limit our ability to more effectively debug an error.</p><p>Another drawback inherent to&nbsp;<code>window.onerror</code>&nbsp;is that once an error is encountered, the browser will stop execution following the invocation of the event handler. Any code following the&nbsp;<code>tryCatch</code>&nbsp;call will be skipped as the interpreter will instead proceed to the next script block (<code>&lt;script&gt;&lt;/script&gt;</code>). This is unavoidable. Only a <code>catch</code> block is capable of truly suppressing an error without halting execution. Of course, if no further execution is required than this drawback is irrelevant.</p><p>Perhaps the greatest disadvantage to this solution are the question marks surrounding&nbsp;<code>window.onerror</code>. For example, it’s not even clear what errors trigger the event and which don’t. The&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers.onerror" onclick="javascript:_gaq.push(['_trackEvent','outbound-article','http://developer.mozilla.org']);" target="_blank">official Mozilla documentation</a>&nbsp;supports this:</p><blockquote>
<p>Note that some/many error events do not trigger <code>window.onerror</code>, you have to listen for them specifically.</p>
</blockquote><p>Unfortunately, Mozilla doesn’t get any more specific in terms of which errors are actually caught by&nbsp;<code>window.onerror</code>. According to the&nbsp;<a href="http://msdn.microsoft.com/en-us/library/ie/cc197053%28v=vs.85%29.aspx" onclick="javascript:_gaq.push(['_trackEvent','outbound-article','http://msdn.microsoft.com']);" target="_blank">Internet Explorer documentation</a>, the following errors trigger the event:</p><blockquote>
<ul>
<li>Run-time script error, such as an invalid object reference or security violation.</li>
<li>Error while downloading an object, such as an image.</li>
<li>Windows Internet Explorer 9. An error occurs while fetching media data</li>
</ul>
</blockquote><p>This seems to be consistent with most browsers, but again, not confirmed. While it is easy to test for which errors currently trigger the event, it is the lack of a clear definition for what should trigger it that makes for the problem. Instead, each browser is left to their own devices to decide what should and should not constitute the triggering of&nbsp;<code>window.onerror</code>. With that type of implementation, how can we trust such an event in every scenario moving forward?</p><h2>Conclusion</h2><p>When I initially began experimenting with this method, I was looking for a means of replacing a try/catch block for performance benefits. However, in the end, it started to dawn on me that perhaps the greatest advantage to this solution is in the numerous opportunities for customization. The ability to tailor the&nbsp;<code>tryCatch</code>&nbsp;function for different use cases and meet various requirements you otherwise couldn’t achieve with a try/catch block could prove to be a more valuable means of error trapping and debugging.</p><p>You could look at it as a suitable median. On one hand, you have a method that mimics a try/catch block but has greater opportunities in terms of functionality while also being more beneficial in performance critical situations in some circumstances. On the other hand, it can narrow the scope of a&nbsp;<code>window.onerror</code>&nbsp;event to specific fragments of code for more effective debugging. Kind of a best of both worlds mashup.</p><p>Now let me be clear, I am absolutely <em>not</em> advocating that you replace all your try/catch blocks using this method. This is still very much in the experimental stage, relying on this method in any type of production environment would be premature. There are just too many questions that need answering.</p><p>I would, however, encourage you to <a href="https://github.com/ryanmorr/try-catch" onclick="javascript:_gaq.push(['_trackEvent','outbound-article','http://github.com']);" target="_blank">fork the code on GitHub</a>. Tweak it, improve it, test it out in scenarios I haven’t even thought of, and maybe we can learn more.</p><p><em>This article was originally published at http://ryanmorr.com/reinventing-the-try-catch-block/</em></p></div></div>
<script>var _gaq = _gaq || []; _gaq.push(['_setAccount', 'UA-34802167-1']); _gaq.push(['_setDomainName', 'liuzhe.co']); _gaq.push(['_trackPageview']); (function() { var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true; ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'; var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s); })();</script></body>
</html>