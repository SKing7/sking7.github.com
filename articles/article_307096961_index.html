<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">
    <title></title>
  </head>
  <body>
        <!-- MAIN CONTENT -->
        <div id="main_content_wrap" class="outer">
        <textarea style="visibility:none" id="html-area">
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
<html xmlns="http://www.w3.org/1999/xhtml"&gt;
<head&gt;
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;
<meta name="keywords" content="web performance faster web sites high performance web sites website optimization best practices javascript css web development mobile"&gt;
<title&gt;Reloading post-onload resources | High Performance Web Sites</title&gt;
<link rel="stylesheet" type="text/css" media="all" href="http://www.stevesouders.com/blog/wp-content/themes/SteveSouders/style.css" /&gt;
<link rel="alternate" type="application/rss+xml" title="High Performance Web Sites &raquo; Reloading post-onload resources Comments Feed" href="http://www.stevesouders.com/blog/2013/02/26/reloading-post-onload-resources/feed/" /&gt;
<link rel="EditURI" type="application/rsd+xml" title="RSD" href="http://www.stevesouders.com/blog/xmlrpc.php?rsd" /&gt;
<link rel="wlwmanifest" type="application/wlwmanifest+xml" href="http://www.stevesouders.com/blog/wp-includes/wlwmanifest.xml" /&gt; 
<link rel='prev' title='HTTP Archive: new stats' href='http://www.stevesouders.com/blog/2013/02/16/http-archive-new-stats/' /&gt;
<link rel='next' title='Zopflinator' href='http://www.stevesouders.com/blog/2013/03/08/zopflinator/' /&gt;
<meta name="generator" content="WordPress 3.6.1" /&gt;
<link rel='canonical' href='http://www.stevesouders.com/blog/2013/02/26/reloading-post-onload-resources/' /&gt;
<link rel='shortlink' href='http://www.stevesouders.com/blog/?p=3225' /&gt;
<script type="text/javascript"&gt;
	window._wp_rp_static_base_url = 'http://dtmvdvtzf8rz0.cloudfront.net/static/';
	window._wp_rp_wp_ajax_url = "http://www.stevesouders.com/blog/wp-admin/admin-ajax.php";
	window._wp_rp_plugin_version = '2.6';
	window._wp_rp_post_id = '3225';
	window._wp_rp_num_rel_posts = '5';
</script&gt;

<script&gt;
(function(d, s) {
	var js = d.getElementsByTagName(s)[0],
		ln = d.createElement(s);
	ln.src = '//lognormal.net/boomerang/8fa4fc2785a82fae20c596ca4f45d1b218a9ab12ffef741d09b29532';
	js.parentNode.insertBefore(ln, js);
})(document, 'script');
</script&gt;

<script type="text/javascript"&gt;
// GOOGLE ANALYTICS
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-15026169-1']);
_gaq.push(['_setSiteSpeedSampleRate', 100]);
_gaq.push(['_trackPageview']);

(function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script&gt;
</head&gt;

<body&gt;
<div id="header"&gt;
	<div class="containerwrapper"&gt;
  		<h1 id="logo"&gt;<a href="http://stevesouders.com/"&gt;<span&gt;SteveSouders.com</span&gt;</a&gt;</h1&gt;
        <ul id="topnav"&gt;
        <li&gt;<a href="http://stevesouders.com/about.php"&gt;about</a&gt;</li&gt;
        <li&gt;<a href="http://stevesouders.com/contact.php"&gt;contact</a&gt;</li&gt;
        <li class="last"&gt; <a href="http://twitter.com/#!/souders/"&gt;<img src="/images/twitter-icon.png" width=16 height=16 border=0 style="vertical-align: bottom;"&gt;</a&gt;
        </ul&gt;
	</div&gt;    
</div&gt;
<div id="contentWrapper" class="containerwrapper"&gt;
<div id="sidebar"&gt;
<div id="search-3" class="widget widget_search"&gt;<form role="search" method="get" id="searchform" class="searchform" action="http://www.stevesouders.com/blog/"&gt;
				<div&gt;
					<label class="screen-reader-text" for="s"&gt;Search for:</label&gt;
					<input type="text" value="" name="s" id="s" /&gt;
					<input type="submit" id="searchsubmit" value="Search" /&gt;
				</div&gt;
			</form&gt;</div&gt;<div id="custom-recent-posts-3" class="widget custom-recent-posts"&gt;<h3 class="blockheader"&gt;Most Recent Posts</h3&gt;		<ul style="list-style-type: none; margin-left: 20px; text-indent: -20px;"&gt;
        		<li&gt;<a href="http://www.stevesouders.com/blog/2013/09/05/domain-sharding-revisited/" rel="bookmark"&gt;Domain Sharding revisited</a&gt;</li&gt;
				<li&gt;<a href="http://www.stevesouders.com/blog/2013/08/27/web-performance-for-the-future/" rel="bookmark"&gt;Web performance for the future</a&gt;</li&gt;
				<li&gt;<a href="http://www.stevesouders.com/blog/2013/07/16/activetable-bookmarklet/" rel="bookmark"&gt;ActiveTable bookmarklet</a&gt;</li&gt;
				<li&gt;<a href="http://www.stevesouders.com/blog/2013/07/15/twitter-widget-update/" rel="bookmark"&gt;Twitter widget update</a&gt;</li&gt;
				<li&gt;<a href="http://www.stevesouders.com/blog/2013/06/16/browser-busy-indicators/" rel="bookmark"&gt;Browser Busy Indicators</a&gt;</li&gt;
				</ul&gt;
		<a href="http://www.stevesouders.com/blog/archives/"&gt;View Archive</a&gt;</div&gt;<div id="text-3" class="widget widget_text"&gt;<h3 class="blockheader"&gt;Feeds</h3&gt;			<div class="textwidget"&gt;<a href="http://www.stevesouders.com/blog/feed/"&gt;<img src="/blog/wp-content/uploads/2011/02/feed.png" width="10" height="10" /&gt; </a&gt;<a href="http://www.stevesouders.com/blog/feed/"&gt;Posts</a&gt;<br /&gt;
<a href="http://www.stevesouders.com/blog/comments/feed/"&gt;<img src="/blog/wp-content/uploads/2011/02/feed.png" width="10" height="10" /&gt; </a&gt;<a href="http://www.stevesouders.com/blog/comments/feed/"&gt;Comments</a&gt;</li&gt;</div&gt;
		</div&gt;        
</div&gt;<div id="content"&gt;



		<div id="post-3225" class="post-3225 post type-post status-publish format-standard hentry category-browsers category-chrome category-firefox category-internet-explorer category-performance category-web-development tag-onload tag-reload"&gt;
        	            	<h1&gt;Reloading post-onload resources</h1&gt;
            
			<p class="meta"&gt;February 26, 2013 5:35 pm | <a href="http://www.stevesouders.com/blog/2013/02/26/reloading-post-onload-resources/#comments" title="Comment on Reloading post-onload resources"&gt;16 Comments</a&gt;</p&gt;<!-- .entry-meta --&gt;

			<p&gt;Two performance best practices are to <a title="High Performance Web Sites: Rule 3 – Add an Expires Header" href="http://developer.yahoo.com/blogs/ydn/posts/2007/05/high_performanc_2/"&gt;add a far future expiration date</a&gt; and to <a title="Splitting the Initial Payload" href="http://www.stevesouders.com/blog/2008/05/14/split-the-initial-payload/"&gt;delay loading resources</a&gt; (esp. scripts) until after the onload event. But it turns out that the combination of these best practices leads to a situation where it&#8217;s hard for users to refresh resources. More specifically, hitting Reload (or even shift+Reload) doesn&#8217;t refresh these cacheable, lazy-loaded resources in Firefox, Chrome, Safari, Android, and iPhone.</p&gt;
<h4&gt;What we expect from Reload</h4&gt;
<p&gt;The browser has a cache (or <a title="Chrome's 10 Caches" href="http://gent.ilcore.com/2011/02/chromes-10-caches.html"&gt;10</a&gt;) where it saves copies of responses. If the user feels those cached responses are stale, she can hit the Reload button to ignore the cache and refetch everything, thus ensuring she&#8217;s seeing the latest copy of the website&#8217;s content. I couldn&#8217;t find anything in the <a title="Rfc 2616 - W3C" href="http://www.w3.org/Protocols/rfc2616/rfc2616.txt"&gt;HTTP Spec</a&gt; dictating the behavior of the Reload button, but all browsers have this behavior AFAIK:</p&gt;
<ul&gt;
<li&gt;If you click Reload (or control+R or command+R) then all the resources are refetched using a <a title="MNot's Caching Tutorial" href="http://www.mnot.net/cache_docs/"&gt;Conditional GET request</a&gt; (with the If-Modified-Since and If-None-Match validators). If the server&#8217;s version of the response has <em&gt;not</em&gt; changed, it returns a short &#8220;304 Not Modified&#8221; status with no response body. If the response <em&gt;has</em&gt; changed then &#8220;200 OK&#8221; and the entire response body is returned.</li&gt;
<li&gt;If you click shift+Reload (or control+Reload or control+shift+R or command+shift+R) then all the resources are refetched withOUT the validation headers. This is less efficient since every response body is returned, but guarantees that any cached responses that are stale are overwritten.</li&gt;
</ul&gt;
<p&gt;Bottomline, regardless of expiration dates we expect that hitting Reload gets the latest version of the website&#8217;s resources, and shift+Reload will do so even more aggressively.</p&gt;
<h4&gt;Welcome to Reload 2.0</h4&gt;
<p&gt;In the days of Web 1.0, resources were requested using HTML markup &#8211; IMG, SCRIPT, LINK, etc. With Web 2.0 resources are often requested dynamically. Two common examples are <a href="http://www.stevesouders.com/blog/2009/04/27/loading-scripts-without-blocking/"&gt;loading scripts asynchronously</a&gt; (e.g., <a href="https://developers.google.com/analytics/devguides/collection/gajs/asyncTracking"&gt;Google Analytics</a&gt;) and dynamically fetching images (e.g., for photo carousels or images below-the-fold). Sometimes these resources are requested after window onload so that the main page can render quickly for a better user experience, better metrics, etc. If these resources have a far future expiration date, the browser needs extra intelligence to do the right thing.</p&gt;
<ul&gt;
<li&gt;If the user navigates to the page normally (clicking on a link, typing a URL, using a bookmark, etc.) and the dynamic resource is in the cache, the browser should use the cached copy (assuming the expiration date is still in the future).</li&gt;
<li&gt;If the user reloads the page, the browser should refetch all the resources including resources loaded dynamically in the page.</li&gt;
<li&gt;If the user reloads the page, I would think resources loaded in the onload handler should also be refetched. These are likely part of the basic construction of the page and they should be refetched if the user wants to refresh the page&#8217;s contents.</li&gt;
<li&gt;But what should the browser do if the user reloads the page and there are resources loaded <em&gt;after</em&gt; the onload event? Some web apps are long lived with sessions that last hours or even days. If the user does a reload, should <em&gt;every</em&gt; dynamically-loaded resource for the life of the web app be refetched ignoring the cache?</li&gt;
</ul&gt;
<h4&gt;An Example</h4&gt;
<p&gt;Let&#8217;s look at an example: <a style="font-size: 1.1em; font-weight: bold;" href="http://stevesouders.com/tests/postonload.php"&gt;Postonload Reload</a&gt;.</p&gt;
<p&gt;This page loads an image and a script using five different techniques:</p&gt;
<ol&gt;
<li&gt;<strong&gt;markup</strong&gt; &#8211; The basic HTML approach: <code&gt;&lt;img src=</code&gt; and <code&gt;&lt;script src=</code&gt;.</li&gt;
<li&gt;<strong&gt;dynamic in body</strong&gt; &#8211; In the body of the page is a script block that creates an image and a script element dynamically and sets the SRC causing the resource to be fetched. This code executes before onload.</li&gt;
<li&gt;<strong&gt;onload</strong&gt; &#8211; An image and a script are dynamically created in the onload handler.</li&gt;
<li&gt;<strong&gt;1 ms post-onload</strong&gt; &#8211; An image and a script are dynamically created via a 1 millisecond setTimeout callback in the onload handler.<strong&gt;</strong&gt;</li&gt;
<li&gt;<strong&gt;5 second post-onload</strong&gt; &#8211; An image and a script are dynamically created via a 5 second setTimeout callback in the onload handler.</li&gt;
</ol&gt;
<p&gt;All of the images and scripts have an expiration date one month in the future. If the user hits Reload, which of the techniques should result in a refetch? Certainly we&#8217;d expect techniques 1 &amp; 2 to cause a refetch. I would hope 3 would be refetched. I think 4 should be refetched but doubt many browsers do that, and 5 probably shouldn&#8217;t be refetched. Settle on your expected results and then take a look at the table below.</p&gt;
<h4&gt;The Results</h4&gt;
<p&gt;Before jumping into the Reload results, let&#8217;s first look at what happens if the user just navigates to the page. This is achieved by clicking on the &#8220;try again&#8221; link in the <a href="http://stevesouders.com/tests/postonload.php"&gt;example</a&gt;. In this case none of the resources are refetched. All of the resources have been saved to the cache with an expiration date one month in the future, so every browser I tested just reads them from cache. This is good and what we would expect.</p&gt;
<p&gt;But the behavior diverges when we look at the Reload results captured in the following table.</p&gt;
<table style="padding: 0; margin: 0; border: 0; border-spacing: 0; margin-bottom: 1em;"&gt;
<tbody&gt;
<tr&gt;
<td style="text-align: center; font-weight: bold; padding-bottom: 5px;" colspan="9"&gt;Table 1. Resources that are refetched on Reload</td&gt;
</tr&gt;
<tr&gt;
<th&gt;technique</th&gt;
<th&gt;resource</th&gt;
<th&gt;Chrome 25</th&gt;
<th&gt;Safari 6</th&gt;
<th&gt;Android Safari/534</th&gt;
<th&gt;iPhone Safari/7534</th&gt;
<th&gt;Firefox 19</th&gt;
<th&gt;IE 8,10</th&gt;
<th&gt;Opera 12</th&gt;
</tr&gt;
<tr&gt;
<td style="border-top: 1px solid #999;" rowspan="2"&gt;markup</td&gt;
<td style="border-top: 1px solid #999;"&gt;image 1</td&gt;
<td style="text-align: center; border-top: 1px solid #999;"&gt;Y</td&gt;
<td style="text-align: center; border-top: 1px solid #999;"&gt;Y</td&gt;
<td style="text-align: center; border-top: 1px solid #999;"&gt;Y</td&gt;
<td style="text-align: center; border-top: 1px solid #999;"&gt;Y</td&gt;
<td style="text-align: center; border-top: 1px solid #999;"&gt;Y</td&gt;
<td style="text-align: center; border-top: 1px solid #999;"&gt;Y</td&gt;
<td style="text-align: center; border-top: 1px solid #999;"&gt;Y</td&gt;
</tr&gt;
<tr&gt;
<td&gt;script 1</td&gt;
<td style="text-align: center;"&gt;Y</td&gt;
<td style="text-align: center;"&gt;Y</td&gt;
<td style="text-align: center;"&gt;Y</td&gt;
<td style="text-align: center;"&gt;Y</td&gt;
<td style="text-align: center;"&gt;Y</td&gt;
<td style="text-align: center;"&gt;Y</td&gt;
<td style="text-align: center;"&gt;Y</td&gt;
</tr&gt;
<tr&gt;
<td style="border-top: 1px solid #999;" rowspan="2"&gt;dynamic</td&gt;
<td style="border-top: 1px solid #999;"&gt;image 2</td&gt;
<td style="text-align: center; border-top: 1px solid #999;"&gt;Y</td&gt;
<td style="text-align: center; border-top: 1px solid #999;"&gt;Y</td&gt;
<td style="text-align: center; border-top: 1px solid #999;"&gt;Y</td&gt;
<td style="text-align: center; border-top: 1px solid #999;"&gt;Y</td&gt;
<td style="text-align: center; border-top: 1px solid #999;"&gt;Y</td&gt;
<td style="text-align: center; border-top: 1px solid #999;"&gt;Y</td&gt;
<td style="text-align: center; border-top: 1px solid #999;"&gt;Y</td&gt;
</tr&gt;
<tr&gt;
<td&gt;script 2</td&gt;
<td style="text-align: center;"&gt;Y</td&gt;
<td style="text-align: center;"&gt;Y</td&gt;
<td style="text-align: center;"&gt;Y</td&gt;
<td style="text-align: center;"&gt;Y</td&gt;
<td style="text-align: center;"&gt;Y</td&gt;
<td style="text-align: center;"&gt;Y</td&gt;
<td style="text-align: center;"&gt;Y</td&gt;
</tr&gt;
<tr&gt;
<td style="border-top: 1px solid #999;" rowspan="2"&gt;onload</td&gt;
<td style="border-top: 1px solid #999;"&gt;image 3</td&gt;
<td style="text-align: center; border-top: 1px solid #999;"&gt;-</td&gt;
<td style="text-align: center; border-top: 1px solid #999;"&gt;-</td&gt;
<td style="text-align: center; border-top: 1px solid #999;"&gt;-</td&gt;
<td style="text-align: center; border-top: 1px solid #999;"&gt;-</td&gt;
<td style="text-align: center; border-top: 1px solid #999;"&gt;Y</td&gt;
<td style="text-align: center; border-top: 1px solid #999;"&gt;Y</td&gt;
<td style="text-align: center; border-top: 1px solid #999;"&gt;Y</td&gt;
</tr&gt;
<tr&gt;
<td&gt;script 3</td&gt;
<td style="text-align: center;"&gt;-</td&gt;
<td style="text-align: center;"&gt;-</td&gt;
<td style="text-align: center;"&gt;-</td&gt;
<td style="text-align: center;"&gt;-</td&gt;
<td style="text-align: center;"&gt;-</td&gt;
<td style="text-align: center;"&gt;Y</td&gt;
<td style="text-align: center;"&gt;Y</td&gt;
</tr&gt;
<tr&gt;
<td style="border-top: 1px solid #999;" rowspan="2"&gt;1ms postonload</td&gt;
<td style="border-top: 1px solid #999;"&gt;image 4</td&gt;
<td style="text-align: center; border-top: 1px solid #999;"&gt;-</td&gt;
<td style="text-align: center; border-top: 1px solid #999;"&gt;-</td&gt;
<td style="text-align: center; border-top: 1px solid #999;"&gt;-</td&gt;
<td style="text-align: center; border-top: 1px solid #999;"&gt;-</td&gt;
<td style="text-align: center; border-top: 1px solid #999;"&gt;-</td&gt;
<td style="text-align: center; border-top: 1px solid #999;"&gt;-</td&gt;
<td style="text-align: center; border-top: 1px solid #999;"&gt;Y</td&gt;
</tr&gt;
<tr&gt;
<td&gt;script 4</td&gt;
<td style="text-align: center;"&gt;-</td&gt;
<td style="text-align: center;"&gt;-</td&gt;
<td style="text-align: center;"&gt;-</td&gt;
<td style="text-align: center;"&gt;-</td&gt;
<td style="text-align: center;"&gt;-</td&gt;
<td style="text-align: center;"&gt;-</td&gt;
<td style="text-align: center;"&gt;Y</td&gt;
</tr&gt;
<tr&gt;
<td style="border-top: 1px solid #999;" rowspan="2"&gt;5sec postonload</td&gt;
<td style="border-top: 1px solid #999;"&gt;image 5</td&gt;
<td style="text-align: center; border-top: 1px solid #999;"&gt;-</td&gt;
<td style="text-align: center; border-top: 1px solid #999;"&gt;-</td&gt;
<td style="text-align: center; border-top: 1px solid #999;"&gt;-</td&gt;
<td style="text-align: center; border-top: 1px solid #999;"&gt;-</td&gt;
<td style="text-align: center; border-top: 1px solid #999;"&gt;-</td&gt;
<td style="text-align: center; border-top: 1px solid #999;"&gt;-</td&gt;
<td style="text-align: center; border-top: 1px solid #999;"&gt;-</td&gt;
</tr&gt;
<tr&gt;
<td&gt;script 5</td&gt;
<td style="text-align: center;"&gt;-</td&gt;
<td style="text-align: center;"&gt;-</td&gt;
<td style="text-align: center;"&gt;-</td&gt;
<td style="text-align: center;"&gt;-</td&gt;
<td style="text-align: center;"&gt;-</td&gt;
<td style="text-align: center;"&gt;-</td&gt;
<td style="text-align: center;"&gt;-</td&gt;
</tr&gt;
</tbody&gt;
</table&gt;
<p&gt;The results for Chrome, Safari, Android mobile Safari, and iPhone mobile Safari are the same. When you click Reload in these browsers the resources in the page get refetched (resources 1&amp;2), but not so for the resources loaded in the onload handler and later (resources 3-5).</p&gt;
<p&gt;Firefox is interesting. It loads the four resources in the page plus the onload handler&#8217;s image (image 3), but not the onload handler&#8217;s script (script 3). Curious.</p&gt;
<p&gt;IE 8 and 10 are the same: they load the four resources in the page as well as the image &amp; script from the onload handler (resources 1-3). I didn&#8217;t test IE 9 but I assume it&#8217;s the same.</p&gt;
<p&gt;Opera has the best results in my opinion. It refetches all of the resources in the main page, the onload handler, and 1 millisecond after onload (resources 1-4), but it does <em&gt;not</em&gt; refetch the resources 5 seconds after onload (image 5 &amp; script 5). I poked at this a bit. If I raise the delay from 1 millisecond to 50 milliseconds, then image 4 &amp; script 4 are <em&gt;not</em&gt; refetched. I think this is a race condition where if Opera is still downloading resources from the onload handler when these first delayed resources are created, then they are also refetched. To further verify this I raised the delay to 500 milliseconds and confirmed the resources were not refetched, but then increased the response time of all the resources to 1 second (instead of instantaneous) and this caused image 4 &amp; script 4 to be refetched, even though the delay was 500 milliseconds after onload.</p&gt;
<p&gt;Note that pressing shift+Reload (and other combinations) didn&#8217;t alter the results.</p&gt;
<h4&gt;Takeaways</h4&gt;
<p&gt;A bit esoteric? Perhaps. This is a deep dive on a niche issue, I&#8217;ll grant you that. But I have a few buts:</p&gt;
<p&gt;If you&#8217;re a web developer using far future expiration dates and lazy loading, you might get unexpected results when you change a resource and hit Reload, and even shift+Reload. If you&#8217;re not getting the latest version of your dev resources you might have to clear your cache.</p&gt;
<p&gt;This isn&#8217;t just an issue for web devs. It affects users as well. Numerous sites lazy-load resources with far future expiration dates including 8 of the top 10 sites: <a title="HTTP Archive results" href="http://httparchive.org/viewsite.php?pageid=6411094"&gt;Google</a&gt;, <a title="HTTP Archive results" href="http://httparchive.org/viewsite.php?pageid=6411185"&gt;YouTube</a&gt;, <a title="HTTP Archive results" href="http://httparchive.org/viewsite.php?pageid=6420420"&gt;Yahoo</a&gt;, <a title="HTTP Archive results" href="http://httparchive.org/viewsite.php?pageid=6411204"&gt;Microsoft Live</a&gt;, <a title="HTTP Archive results" href="http://httparchive.org/viewsite.php?pageid=6411193"&gt;Tencent QQ</a&gt;, <a title="HTTP Archive results" href="http://httparchive.org/viewsite.php?pageid=6420424"&gt;Amazon</a&gt;, and <a title="HTTP Archive results" href="http://httparchive.org/viewsite.php?pageid=6411172"&gt;Twitter</a&gt;. If you Reload any of these sites with a packet sniffer open in the first four browsers listed, you&#8217;ll see a curious pattern: cacheable resources loaded before onload have a 304 response status, while those after onload are read from cache and don&#8217;t get refetched. The only way to ensure you get a fresh version is to clear your cache, defeating the expected benefit of the Reload button.</p&gt;
<p&gt;Here&#8217;s a waterfall showing the requests when Amazon is reloaded in Chrome. The red vertical line marks the onload event. Notice how the resources before onload have 304 status codes. Right after the onload are some image beacons that aren&#8217;t cacheable, so they get refetched and return 200 status codes. The cacheable images loaded after onload are all read from cache, so any updates to those resources are missed.</p&gt;
<p&gt;<img class="aligncenter" title="Reload Waterfall for Amazon" src="http://stevesouders.com/images/reload-waterfall.png" alt="" width="492" height="405" /&gt;</p&gt;
<p&gt;Finally, whenever behavior varies across browsers it&#8217;s usually worthwhile to investigate why. Often one behavior is preferred over another, and we should get the specs and vendors aligned in that direction. In this case, we should make Reload more consistent and have it refetch resources, even those loaded dynamically in the onload handler.</p&gt;

<div class="wp_rp_wrap  wp_rp_momma" id="wp_rp_first"&gt;<div class="wp_rp_content"&gt;<h3 class="related_post_title"&gt;Related Posts</h3&gt;<ul class="related_post wp_rp" style="visibility: visible"&gt;<li &gt;<a href="http://www.stevesouders.com/blog/2009/08/11/f5-and-xhr-deep-dive/" class="wp_rp_title"&gt;F5 and XHR deep dive</a&gt;</li&gt;<li &gt;<a href="http://www.stevesouders.com/blog/2011/06/27/unexpected-reloads-in-webkit/" class="wp_rp_title"&gt;Unexpected Reloads in WebKit</a&gt;</li&gt;<li &gt;<a href="http://www.stevesouders.com/blog/2009/12/10/speed-tracer/" class="wp_rp_title"&gt;Speed Tracer &#8211; visibility into the browser</a&gt;</li&gt;<li &gt;<a href="http://www.stevesouders.com/blog/2010/04/26/call-to-improve-browser-caching/" class="wp_rp_title"&gt;Call to improve browser caching</a&gt;</li&gt;<li &gt;<a href="http://www.stevesouders.com/blog/2010/02/12/5e-speculative-background-images/" class="wp_rp_title"&gt;5e speculative background images</a&gt;</li&gt;</ul&gt;<div class="wp_rp_footer"&gt;<a class="wp_rp_backlink" target="_blank" rel="nofollow" href="http://www.zemanta.com/?wp-related-posts"&gt;Zemanta</a&gt;</div&gt;</div&gt;</div&gt;
            
            			
		</div&gt;<!-- #post-## --&gt;


		
			<div id="comments"&gt;

			<h3 id="comments-title"&gt;16 Responses to <em&gt;Reloading post-onload resources</em&gt;</h3&gt;


			<ol class="commentlist"&gt;
				<li class="comment even thread-even depth-1" id="li-comment-26079"&gt;
<div id="comment-26079"&gt;
<p class="comment-metadata"&gt;
<strong&gt;Myron</strong&gt; | 26-Feb-13 at 6:07 pm | <a href="http://www.stevesouders.com/blog/2013/02/26/reloading-post-onload-resources/#comment-26079"&gt;Permalink</a&gt; |  </p&gt;


<p&gt;I am curious as to why this is the case: &#8220;(Technique) 5 probably shouldn’t be refetched.&#8221;</p&gt;
</div&gt;
</li&gt;<!-- #comment-## --&gt;
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-26099"&gt;
<div id="comment-26099"&gt;
<p class="comment-metadata"&gt;
<strong&gt;<a href='http://tech.bluesmoon.info/' rel='external nofollow' class='url'&gt;Philip Tellis</a&gt;</strong&gt; | 26-Feb-13 at 8:35 pm | <a href="http://www.stevesouders.com/blog/2013/02/26/reloading-post-onload-resources/#comment-26099"&gt;Permalink</a&gt; |  </p&gt;


<p&gt;Man you followed up on this fast!  Wish I still had the time to run experiments.</p&gt;
<p&gt;Interesting results that have brought up a few more questions&#8230;</p&gt;
<p&gt;1. On Windows most browsers have a setTimeout least count of 15ms.  Don&#8217;t think that&#8217;s an issue here though, but could you try with setImmediate as well?</p&gt;
<p&gt;2. When you delayed the resources for 1 second in the Opera test, shouldn&#8217;t that have also delayed onload?</p&gt;
</div&gt;
</li&gt;<!-- #comment-## --&gt;
<li class="comment even thread-even depth-1" id="li-comment-26100"&gt;
<div id="comment-26100"&gt;
<p class="comment-metadata"&gt;
<strong&gt;<a href='http://tech.bluesmoon.info/' rel='external nofollow' class='url'&gt;Philip Tellis</a&gt;</strong&gt; | 26-Feb-13 at 8:37 pm | <a href="http://www.stevesouders.com/blog/2013/02/26/reloading-post-onload-resources/#comment-26100"&gt;Permalink</a&gt; |  </p&gt;


<p&gt;I should also add that you&#8217;ll see the same behaviour when calling location.reload(true) from JavaScript inside the page.</p&gt;
</div&gt;
</li&gt;<!-- #comment-## --&gt;
<li class="comment byuser comment-author-sowrock bypostauthor odd alt thread-odd thread-alt depth-1 author" id="li-comment-26105"&gt;
<div id="comment-26105"&gt;
<p class="comment-metadata"&gt;
<strong&gt;<a href='http://stevesouders.com' rel='external nofollow' class='url'&gt;Steve Souders</a&gt;</strong&gt; | 26-Feb-13 at 9:01 pm | <a href="http://www.stevesouders.com/blog/2013/02/26/reloading-post-onload-resources/#comment-26105"&gt;Permalink</a&gt; |  </p&gt;


<p&gt;Myron: Since web apps can be long lived, it would generally be bad to ALWAYS refetch every dynamic resource if the web app was reloaded. You can imagine hours or days after the app was reloaded that user visited their photo album with a dynamic slideshow. IMO those photos should be read from cache and not refetched. So the browser has to decide at some point to stop refetching everything. 5 seconds seems like a good stopping point, albeit subjective and untested.</p&gt;
</div&gt;
</li&gt;<!-- #comment-## --&gt;
<li class="comment byuser comment-author-sowrock bypostauthor even thread-even depth-1 author" id="li-comment-26110"&gt;
<div id="comment-26110"&gt;
<p class="comment-metadata"&gt;
<strong&gt;<a href='http://stevesouders.com' rel='external nofollow' class='url'&gt;Steve Souders</a&gt;</strong&gt; | 26-Feb-13 at 9:13 pm | <a href="http://www.stevesouders.com/blog/2013/02/26/reloading-post-onload-resources/#comment-26110"&gt;Permalink</a&gt; |  </p&gt;


<p&gt;Philip: Here&#8217;s a version with <a href="http://stevesouders.com/tests/postonload-setimmediate.php" rel="nofollow"&gt;setImmediate</a&gt;. What browser are you going to test that on? Chrome, Safari, &#038; Firefox are the most interesting ones to test (to see if they get more aggressive about refetching) but I don&#8217;t think they support it. Anyway, I don&#8217;t think it&#8217;s the 15ms setTimeout issue because I raised it to 40ms and it still didn&#8217;t refetch in Chrome.</p&gt;
<p&gt;Here&#8217;s a version with the <a href="http://stevesouders.com/tests/postonload-sleep.php" rel="nofollow"&gt;sleep=1</a&gt;. It does push out the onload, but the resources in question are loaded during or after the onload, so delaying onload doesn&#8217;t affect them.</p&gt;
</div&gt;
</li&gt;<!-- #comment-## --&gt;
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-26114"&gt;
<div id="comment-26114"&gt;
<p class="comment-metadata"&gt;
<strong&gt;<a href='http://tech.bluesmoon.info/' rel='external nofollow' class='url'&gt;Philip Tellis</a&gt;</strong&gt; | 26-Feb-13 at 9:52 pm | <a href="http://www.stevesouders.com/blog/2013/02/26/reloading-post-onload-resources/#comment-26114"&gt;Permalink</a&gt; |  </p&gt;


<p&gt;Steve: you&#8217;re right about the browser support for setImmediate.  IE10 is the only one that supports it.</p&gt;
</div&gt;
</li&gt;<!-- #comment-## --&gt;
<li class="comment even thread-even depth-1" id="li-comment-26141"&gt;
<div id="comment-26141"&gt;
<p class="comment-metadata"&gt;
<strong&gt;Dan Fabulich</strong&gt; | 26-Feb-13 at 11:58 pm | <a href="http://www.stevesouders.com/blog/2013/02/26/reloading-post-onload-resources/#comment-26141"&gt;Permalink</a&gt; |  </p&gt;


<p&gt;I&#8217;m not sure I agree that it&#8217;s important for the Refresh button to reload non-expired post-onload resources.</p&gt;
<p&gt;Many users refresh sites just to try to get new data (e.g. refreshing CNN.com for headlines). Refreshing the post-onload JS on that page, even if it&#8217;s just a 304 request, would be a waste of the user&#8217;s time.</p&gt;
<p&gt;Indeed, when I know that everything on a page is cached except for short-lived data on the page, I&#8217;ve wished the browser would let me override the refresh button, allowing me to just re-request short-lived AJAX data without going through a full-page reload at all. Why make the user wait for all of that stuff, flash the screen, etc.?</p&gt;
</div&gt;
</li&gt;<!-- #comment-## --&gt;
<li class="comment byuser comment-author-sowrock bypostauthor odd alt thread-odd thread-alt depth-1 author" id="li-comment-26215"&gt;
<div id="comment-26215"&gt;
<p class="comment-metadata"&gt;
<strong&gt;<a href='http://stevesouders.com' rel='external nofollow' class='url'&gt;Steve Souders</a&gt;</strong&gt; | 27-Feb-13 at 5:40 am | <a href="http://www.stevesouders.com/blog/2013/02/26/reloading-post-onload-resources/#comment-26215"&gt;Permalink</a&gt; |  </p&gt;


<p&gt;Dan: I can see your motivation for a &#8220;lighter&#8221; version of Reload, but sometimes people reload in order to refresh more than text &#8211; they actually want to refresh the JS or CSS, etc. Regardless, the point of this article is that all those resources are refetched if they occur before onload. Since more and more resources are being loaded after onload it would be more consistent to also refetch those.</p&gt;
</div&gt;
</li&gt;<!-- #comment-## --&gt;
<li class="comment even thread-even depth-1" id="li-comment-26282"&gt;
<div id="comment-26282"&gt;
<p class="comment-metadata"&gt;
<strong&gt;Jason</strong&gt; | 27-Feb-13 at 10:43 am | <a href="http://www.stevesouders.com/blog/2013/02/26/reloading-post-onload-resources/#comment-26282"&gt;Permalink</a&gt; |  </p&gt;


<p&gt;I suspect Webapp frameworks with their own asset compilation pipeline are going to win out.  This is a shining example of why.</p&gt;
<p&gt;If my page loads general.js asynchronously then you&#8217;re right, and I&#8217;m hosed by the reload semantics of the user agent.  If it&#8217;s loading general-345636.js  and the new page is loading general-753632.js then I have no problem.</p&gt;
</div&gt;
</li&gt;<!-- #comment-## --&gt;
<li class="comment byuser comment-author-sowrock bypostauthor odd alt thread-odd thread-alt depth-1 author" id="li-comment-26288"&gt;
<div id="comment-26288"&gt;
<p class="comment-metadata"&gt;
<strong&gt;<a href='http://stevesouders.com' rel='external nofollow' class='url'&gt;Steve Souders</a&gt;</strong&gt; | 27-Feb-13 at 11:07 am | <a href="http://www.stevesouders.com/blog/2013/02/26/reloading-post-onload-resources/#comment-26288"&gt;Permalink</a&gt; |  </p&gt;


<p&gt;Jason: Great great point. You really should never change the contents of a public resource without also changing the URL.</p&gt;
</div&gt;
</li&gt;<!-- #comment-## --&gt;
<li class="comment even thread-even depth-1" id="li-comment-26304"&gt;
<div id="comment-26304"&gt;
<p class="comment-metadata"&gt;
<strong&gt;Eric Lawrence</strong&gt; | 27-Feb-13 at 1:09 pm | <a href="http://www.stevesouders.com/blog/2013/02/26/reloading-post-onload-resources/#comment-26304"&gt;Permalink</a&gt; |  </p&gt;


<p&gt;I have a fairly long writeup of IE&#8217;s behavior on Refresh here: <a href="http://blogs.msdn.com/b/ieinternals/archive/2010/07/08/technical-information-about-conditional-http-requests-and-the-refresh-button.aspx" rel="nofollow"&gt;http://blogs.msdn.com/b/ieinternals/archive/2010/07/08/technical-information-about-conditional-http-requests-and-the-refresh-button.aspx</a&gt;</p&gt;
<p&gt;As noted in that article, a change was made to IE10 vis-à-vis refresh: IE10 applies cache-busting flags when XHR is used after a page is refreshed with CTRL+F5.</p&gt;
</div&gt;
</li&gt;<!-- #comment-## --&gt;
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-26305"&gt;
<div id="comment-26305"&gt;
<p class="comment-metadata"&gt;
<strong&gt;Eric Lawrence</strong&gt; | 27-Feb-13 at 1:12 pm | <a href="http://www.stevesouders.com/blog/2013/02/26/reloading-post-onload-resources/#comment-26305"&gt;Permalink</a&gt; |  </p&gt;


<p&gt;To Dan&#8217;s point above: various folks contacted IE to request control of the refresh button for the very reason he describes&#8211; the user is *frequently* using the Refresh button on an AJAX-y site whereby the site&#8217;s script itself could do a better job in giving the user what they want (e.g. latest status updates or whatnot) without a flood of 302s. </p&gt;
<p&gt;Ultimately, we elected not to make that change in IE10 for the very reasons you alluded too&#8211; if the user&#8217;s version of the page was corrupt for some reason, then such a change could be very bad for the user-experience.</p&gt;
</div&gt;
</li&gt;<!-- #comment-## --&gt;
<li class="comment byuser comment-author-sowrock bypostauthor even thread-even depth-1 author" id="li-comment-26314"&gt;
<div id="comment-26314"&gt;
<p class="comment-metadata"&gt;
<strong&gt;<a href='http://stevesouders.com' rel='external nofollow' class='url'&gt;Steve Souders</a&gt;</strong&gt; | 27-Feb-13 at 1:33 pm | <a href="http://www.stevesouders.com/blog/2013/02/26/reloading-post-onload-resources/#comment-26314"&gt;Permalink</a&gt; |  </p&gt;


<p&gt;Eric: Hi! Thanks for the link. Most of the postonload resources that are NOT refetched are regular images and scripts &#8211; they are not XHRs. Is the IE10 change just for XHRs, or does it also apply to &#8220;items pulled down by JavaScript&#8221;? In my tests it appears this change doesn&#8217;t happen for regular images and scripts in IE10.</p&gt;
</div&gt;
</li&gt;<!-- #comment-## --&gt;
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-40329"&gt;
<div id="comment-40329"&gt;
<p class="comment-metadata"&gt;
<strong&gt;<a href='http://ninja.sg/' rel='external nofollow' class='url'&gt;Sebastiaan Deckers</a&gt;</strong&gt; | 23-Mar-13 at 7:55 pm | <a href="http://www.stevesouders.com/blog/2013/02/26/reloading-post-onload-resources/#comment-40329"&gt;Permalink</a&gt; |  </p&gt;


<p&gt;Why not just clear all current page assets from the browser cache on a Force-Reload?</p&gt;
</div&gt;
</li&gt;<!-- #comment-## --&gt;
<li class="comment even thread-even depth-1" id="li-comment-60005"&gt;
<div id="comment-60005"&gt;
<p class="comment-metadata"&gt;
<strong&gt;<a href='http://braincracking.org' rel='external nofollow' class='url'&gt;jpvincent</a&gt;</strong&gt; | 18-Apr-13 at 9:08 am | <a href="http://www.stevesouders.com/blog/2013/02/26/reloading-post-onload-resources/#comment-60005"&gt;Permalink</a&gt; |  </p&gt;


<p&gt;hi Steve</p&gt;
<p&gt;thanks for the research.</p&gt;
<p&gt;At the time of writing this comment, your example seems to have a problem : the cache headers on the resources you are using is set to + 1 Month, because you are using this kind of URL :</p&gt;
<p&gt;<a href="http://www.stevesouders.com/bin/resource.cgi?type=js&#038;sleep=0&#038;expires=1&#038;n=5" rel="nofollow"&gt;http://www.stevesouders.com/bin/resource.cgi?type=js&#038;sleep=0&#038;expires=1&#038;n=5</a&gt;</p&gt;
<p&gt;I copied back your code and tested with an expires=-1 and expires=0 . The results confirm your theory with expires = 0 but there is new stuff to get for the expires = -1 :</p&gt;
<p&gt;- Chrome with expires 0 and document.location.reload() :<br /&gt;
<a href="http://www.webpagetest.org/results.php?test=130418_GJ_a11707efcfa343cc5004b7723b413df9" rel="nofollow"&gt;http://www.webpagetest.org/results.php?test=130418_GJ_a11707efcfa343cc5004b7723b413df9</a&gt;</p&gt;
<p&gt;in this configuration, no expires header is set, resources onload and post-onload are taken from the cache, as in your results</p&gt;
<p&gt;- Chrome with expires -1 and document.location.reload() :</p&gt;
<p&gt;<a href="http://www.webpagetest.org/results.php?test=130418_S2_02fc87adbef561ce611bae44fee23504" rel="nofollow"&gt;http://www.webpagetest.org/results.php?test=130418_S2_02fc87adbef561ce611bae44fee23504</a&gt;</p&gt;
<p&gt;here, expires header are set to 0 and expiration date is in the past. Chrome seems to react in a sane way (for the developer at least) and DOES NOT USE CACHE</p&gt;
<p&gt;For reference the cache + 1 as in your current example, and works as expected : <a href="http://www.webpagetest.org/result/130418_CT_e20e850d48299321efd65e869e76004b/1/details/" rel="nofollow"&gt;http://www.webpagetest.org/result/130418_CT_e20e850d48299321efd65e869e76004b/1/details/</a&gt;</p&gt;
<p&gt;I guess we should try to reproduce that with all the other browsers now and check if behaviour is same for all. Also I&#8217;m wondering how the lack of expire header is interpreted in this case for all browsers</p&gt;
</div&gt;
</li&gt;<!-- #comment-## --&gt;
<li class="comment odd alt thread-odd thread-alt depth-1" id="li-comment-60006"&gt;
<div id="comment-60006"&gt;
<p class="comment-metadata"&gt;
<strong&gt;<a href='http://braincracking.org' rel='external nofollow' class='url'&gt;jpvincent</a&gt;</strong&gt; | 19-Apr-13 at 3:05 am | <a href="http://www.stevesouders.com/blog/2013/02/26/reloading-post-onload-resources/#comment-60006"&gt;Permalink</a&gt; |  </p&gt;


<p&gt;Ok, did more tests using WPT to have my own table<br /&gt;
<a href="https://docs.google.com/spreadsheet/ccc?key=0AirWN83fytRxdGpoS24tRXVKZzB0d01oWTcwWEMxT3c&#038;usp=sharing" rel="nofollow"&gt;https://docs.google.com/spreadsheet/ccc?key=0AirWN83fytRxdGpoS24tRXVKZzB0d01oWTcwWEMxT3c&#038;usp=sharing</a&gt;</p&gt;
<p&gt;My goal was to answer to the question : are post-onload resources loaded from cache or not ?<br /&gt;
the answers variy between browsers with no cache header or with cache headers set to + 1 month.<br /&gt;
However, that looks consistent with those headers :<br /&gt;
Expires: &#8221; &#8211; 1 month &#8221;<br /&gt;
Cache-Control: public, max-age=0<br /&gt;
no eTag or Last-Modified</p&gt;
<p&gt;We should probably make more tests with eTag caching and so on.</p&gt;
</div&gt;
</li&gt;<!-- #comment-## --&gt;
			</ol&gt;







</div&gt;<!-- #comments --&gt;


</div&gt; <!-- end div id="content" --&gt;
</div&gt;
<div id="footer" class="containerwrapperpadded"&gt;
<p&gt;&copy; Steve Souders</p&gt;
</div&gt;
</body&gt;
</html&gt;

<!-- Performance optimized by W3 Total Cache. Learn more: http://www.w3-edge.com/wordpress-plugins/

Page Caching using disk: enhanced
Database Caching 14/32 queries in 0.347 seconds using disk

 Served from: www.stevesouders.com @ 2013-09-30 02:42:30 by W3 Total Cache --&gt;
        </textarea>
        </div>
        <script src="http://libs.baidu.com/jquery/2.0.0/jquery.min.js"></script>
        <script src="../js/clearly.js"></script>
        <script>
            var html = window.__getMyClearlyResults().html;
            $('#main_content_wrap').html(html);
        </script>
  </body>
</html>
