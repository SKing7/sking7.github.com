
        <!doctype html>
        <html>
        <head>
            <meta charset="utf-8"/>
            <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
            <title>JavaScript inheritance patterns</title>
            <link rel="stylesheet" href="../css/article.css" />;
        </head>
        <body>
            <div class="m-content">
            <h1>JavaScript inheritance patterns</h1>
            <div class="section-inner layoutSingleColumn"><h3 name="70bc" id="70bc" class="graf--h3">An overview and comparison</h3><figure name="c55c" id="c55c" class="graf--figure"><div class="aspectRatioPlaceholder is-locked"><img class="graf-image" data-image-id="1*pWfJGrCbLcK6cy5TDT4DiA.jpeg" data-width="2432" data-height="1448" data-action="zoom" data-action-value="1*pWfJGrCbLcK6cy5TDT4DiA.jpeg" src="https://cdn-images-1.medium.com/max/800/1*pWfJGrCbLcK6cy5TDT4DiA.jpeg"></div></figure><p name="b210" id="b210" class="graf--p">JavaScript is a very powerful language. So powerful, in fact, that there are multiple different ways of designing prototypes and instantiating objects. There are tradeoffs when using each different method, and I aim to assist newcomers to the language by clearing up the mess. This is a follow-up to my previous post, <a href="https://medium.com/@PitaJ/stop-classifying-javascript-4cc823dfbedf" data-href="https://medium.com/@PitaJ/stop-classifying-javascript-4cc823dfbedf" class="markup--anchor markup--p-anchor">Stop Classifying JavaScript</a>. I received many comments and responses asking for code examples, so here they are.</p><h4 name="4ed4" id="4ed4" class="graf--h4"><strong class="markup--strong markup--h4-strong">JavaScript has <em class="markup--em markup--h4-em">Prototypal Inheritance</em></strong></h4><p name="89a3" id="89a3" class="graf--p">This means that, in JavaScript, objects inherit from other objects. Basic objects in JavaScript, created with the <em class="markup--em markup--p-em">{ }</em> curly braces, have only one prototype: <em class="markup--em markup--p-em">Object.prototype. Object.prototype </em>is, in itself, an object, and all members of <em class="markup--em markup--p-em">Object.prototype</em> are accessible from all objects.</p><p name="f70c" id="f70c" class="graf--p">Basic arrays, created with the <em class="markup--em markup--p-em">[ ]</em> square brackets, have multiple prototypes, including <em class="markup--em markup--p-em">Object.prototype </em>and <em class="markup--em markup--p-em">Array.prototype. </em>This means that all members of <em class="markup--em markup--p-em">Object.prototype </em>and all members of <em class="markup--em markup--p-em">Array.prototype</em> are accessible as members of arrays. Any members that overlap, like&nbsp;<em class="markup--em markup--p-em">.valueOf </em>and&nbsp;<em class="markup--em markup--p-em">.toString, </em>are overridden by the closest prototype, <em class="markup--em markup--p-em">Array.prototype</em> in this case.</p><h4 name="c9f7" id="c9f7" class="graf--h4"><strong class="markup--strong markup--h4-strong">Prototype definitions and object instantiation</strong></h4><p name="471e" id="471e" class="graf--p"><strong class="markup--strong markup--p-strong">Method 1: Constructor pattern</strong></p><p name="ff05" id="ff05" class="graf--p">JavaScript has a special type of function called constructor functions, which act similarly to constructors in other languages. The are called mandatorily with the <em class="markup--em markup--p-em">new</em> keyword and bind the <em class="markup--em markup--p-em">this</em> keyword to the object being created by the constructor function. A typical constructor may look like this:</p><pre name="282c" id="282c" class="graf--pre">function Animal(type){<br>this.type = type;<br>}<br>Animal.isAnimal = function(obj, type){<br>if(!Animal.prototype.isPrototypeOf(obj)){<br>return false;<br>}<br>return type ? obj.type === type : true;<br>};</pre><pre name="5f70" id="5f70" class="graf--pre">function Dog(name, breed){<br>Animal.call(this, "dog");<br>this.name = name;<br>this.breed = breed;<br>}<br>Object.setPrototypeOf(Dog.prototype, Animal.prototype);<br>Dog.prototype.bark = function(){<br>console.log("ruff, ruff");<br>};<br>Dog.prototype.print = function(){<br>console.log("The dog " + this.name + " is a " + this.breed);<br>};</pre><pre name="5b26" id="5b26" class="graf--pre">Dog.isDog = function(obj){<br>return Animal.isAnimal(obj, "dog");<br>};</pre><p name="e0d6" id="e0d6" class="graf--p">The usage of this constructor looks like instantiation in other languages:</p><pre name="1519" id="1519" class="graf--pre">var sparkie = new Dog("Sparkie", "Border Collie");</pre><pre name="869d" id="869d" class="graf--pre">sparkie.name;    // "Sparkie"<br>sparkie.breed;   // "Border Collie"<br>sparkie.bark();  // console: "ruff, ruff"<br>sparkie.print(); // console: "The dog Sparkie is a Border Collie"</pre><pre name="3ca8" id="3ca8" class="graf--pre">Dog.isDog(sparkie); // true</pre><p name="e73e" id="e73e" class="graf--p"><em class="markup--em markup--p-em">bark</em> and <em class="markup--em markup--p-em">print</em> are prototype methods which apply to all dogs. The <em class="markup--em markup--p-em">name </em>and <em class="markup--em markup--p-em">breed</em> properties are own properties that are set by the constructor. Usually, all methods are set in the prototype and all properties are set by the constructor.</p><p name="e07f" id="e07f" class="graf--p"><strong class="markup--strong markup--p-strong">Method 2: ES2015 (ES6) Class definitions</strong></p><p name="2b2a" id="2b2a" class="graf--p"><em class="markup--em markup--p-em">class</em> has been a reserved keyword in JavaScript since the beginning, and now there is finally a use for it. Class definitions in JavaScript look a lot like they do in other languages.</p><pre name="993b" id="993b" class="graf--pre">class Animal {<br>constructor(type){<br>this.type = type;<br>}<br>static isAnimal(obj, type){<br>if(!Animal.prototype.isPrototypeOf(obj)){<br>return false;<br>}<br>return type ? obj.type === type : true;<br>}<br>}</pre><pre name="83a9" id="83a9" class="graf--pre">class Dog extends Animal {<br>constructor(name, breed){<br>super("dog");<br>this.name = name;<br>this.breed = breed;<br>}<br>bark(){<br>console.log("ruff, ruff");<br>}<br>print(){<br>console.log("The dog " + this.name + " is a " + this.breed);<br>}<br>static isDog(obj){<br>return Animal.isAnimal(obj, "dog");<br>}<br>}</pre><p name="4807" id="4807" class="graf--p">A lot of people like this syntax because it combines the constructor, static, and the prototype method declarations into one nice block. The usage is exactly the same as the Constructor method.</p><pre name="d005" id="d005" class="graf--pre">var sparkie = new Dog("Sparkie", "Border Collie");</pre><p name="f76b" id="f76b" class="graf--p"><strong class="markup--strong markup--p-strong">Method 3: Explicit prototype declaration, Object.create, method factory</strong></p><p name="fd7c" id="fd7c" class="graf--p">This method really displays the prototypal inheritance behind the workings of the <em class="markup--em markup--p-em">class </em>syntax, and allows for the omittance of the <em class="markup--em markup--p-em">new </em>keyword.</p><pre name="ead7" id="ead7" class="graf--pre">var Animal = {<br>create(type){<br>var animal = Object.create(Animal.prototype);<br>animal.type = type;<br>return animal;<br>},<br>isAnimal(obj, type){<br>if(!Animal.prototype.isPrototypeOf(obj)){<br>return false;<br>}<br>return type ? obj.type === type : true;<br>},<br>prototype: {}<br>};</pre><pre name="85fc" id="85fc" class="graf--pre">var Dog = {<br>create(name, breed){<br>var dog = Object.create(Dog.prototype); <br>Object.assign(dog, Animal.create("dog"));<br>dog.name = name;<br>dog.breed = breed;<br>return dog;<br>},<br>isDog(obj){<br>return Animal.isAnimal(obj, "dog");<br>},<br>prototype: {<br>bark(){<br>console.log("ruff, ruff");<br>},<br>print(){<br>console.log("The dog " + this.name + " is a " + this.breed);<br>}<br>}<br>};</pre><pre name="4a03" id="4a03" class="graf--pre">Object.setPrototypeOf(Dog.prototype, Animal.prototype);</pre><p name="d6fb" id="d6fb" class="graf--p">This syntax is nice because the prototypes are very explicitly defined. It is very clear exactly which are members of the prototype and which are members of the object. <em class="markup--em markup--p-em">Object.create</em> is nice because it allows the creation of an object with a specific prototype. The&nbsp;<em class="markup--em markup--p-em">.isPrototypeOf</em> check still works in both cases. The usage is different, but not incredible different:</p><pre name="50c3" id="50c3" class="graf--pre">var sparkie = Dog.create("Sparkie", "Border Collie");</pre><pre name="5187" id="5187" class="graf--pre">sparkie.name;    // "Sparkie"<br>sparkie.breed;   // "Border Collie"<br>sparkie.bark();  // console: "ruff, ruff"<br>sparkie.print(); // console: "The dog Sparkie is a Border Collie"</pre><pre name="9168" id="9168" class="graf--pre">Dog.isDog(sparkie); // true</pre><p name="2865" id="2865" class="graf--p"><strong class="markup--strong markup--p-strong">Method 4: Object.create, top-level factory, prototype post-declaration</strong></p><p name="c8e4" id="c8e4" class="graf--p">This method is a slight variation of Method 3, where the factory is the class, versus the class being an object with a factory method. It looks like the constructor example (Method 1), but uses factories and <em class="markup--em markup--p-em">Object.create</em> instead.</p><pre name="1caf" id="1caf" class="graf--pre">function Animal(type){<br>var animal = Object.create(Animal.prototype);<br>animal.type = type;<br>return animal;<br>}<br>Animal.isAnimal = function(obj, type){<br>if(!Animal.prototype.isPrototypeOf(obj)){<br>return false;<br>}<br>return type ? obj.type === type : true;<br>};<br>Animal.prototype = {};</pre><pre name="c621" id="c621" class="graf--pre">function Dog(name, breed){<br>var dog = Object.create(Dog.prototype);<br>Object.assign(dog, Animal("dog"));<br>dog.name = name;<br>dog.breed = breed;<br>return dog;<br>}<br>Dog.isDog = function(obj){<br>return Animal.isAnimal(obj, "dog");<br>};<br>Dog.prototype = {<br>bark(){<br>console.log("ruff, ruff");<br>},<br>print(){<br>console.log("The dog " + this.name + " is a " + this.breed);<br>}<br>};</pre><pre name="853e" id="853e" class="graf--pre">Object.setPrototypeOf(Dog.prototype, Animal.prototype);</pre><p name="6187" id="6187" class="graf--p">This method is nice because it’s usage looks like Method 1, but does not require the <em class="markup--em markup--p-em">new</em> keyword and works with <em class="markup--em markup--p-em">instanceof. </em>The usage is the same as the first method, but without the <em class="markup--em markup--p-em">new:</em></p><pre name="59cd" id="59cd" class="graf--pre">var sparkie = Dog("Sparkie", "Border Collie");</pre><pre name="fcd6" id="fcd6" class="graf--pre">sparkie.name;    // "Sparkie"<br>sparkie.breed;   // "Border Collie"<br>sparkie.bark();  // console: "ruff, ruff"<br>sparkie.print(); // console: "The dog Sparkie is a Border Collie"</pre><pre name="2f05" id="2f05" class="graf--pre">Dog.isDog(sparkie); // true</pre><h4 name="f06c" id="f06c" class="graf--h4">Comparison</h4><p name="a0e7" id="a0e7" class="graf--p"><strong class="markup--strong markup--p-strong">Method 1 vs Method 4</strong></p><p name="de1c" id="de1c" class="graf--p">There is very little reason to use Method 1 over Method 4. Method 1 requires either the use of <em class="markup--em markup--p-em">new</em> in your code or a check like this in the constructor:</p><pre name="0c76" id="0c76" class="graf--pre">if(!(this instanceof Foo)){ <br>return new Foo(a, b, c);<br>}</pre><p name="1898" id="1898" class="graf--p">At which point you may as well just use <em class="markup--em markup--p-em">Object.create </em>in a factory. You also can’t use <em class="markup--em markup--p-em">Function#call </em>or <em class="markup--em markup--p-em">Function#apply </em>on constructor functions, because they mess up <em class="markup--em markup--p-em">this</em>. The check above could remedy that issue as well, but if you want to use an unknown amount of arguments, you have to use a factory.</p><p name="15bb" id="15bb" class="graf--p"><strong class="markup--strong markup--p-strong">Method 2 vs Method 3</strong></p><p name="89c1" id="89c1" class="graf--p">The same arguments about constructors and <em class="markup--em markup--p-em">new</em> that applied above apply to this as well. The <em class="markup--em markup--p-em">instanceof </em>check is necessary for using the <em class="markup--em markup--p-em">class</em> syntax without <em class="markup--em markup--p-em">new </em>or with <em class="markup--em markup--p-em">Function#apply </em>and <em class="markup--em markup--p-em">Function#call</em>.</p><h4 name="233e" id="233e" class="graf--h4">My opinion</h4><p name="f593" id="f593" class="graf--p">A programmer should strive for code clarity. Method 3's explicit syntax very clearly shows exactly what is going on. It also allows for easy multiple inheritance and concatenative inheritance. Since using the <em class="markup--em markup--p-em">new</em> keyword violates the open-closed principle due to incompatibility with <em class="markup--em markup--p-em">apply </em>or <em class="markup--em markup--p-em">call, </em>it should be avoided. The <em class="markup--em markup--p-em">class</em> keyword hides the prototypal nature of JavaScript’s inheritance behind the guise of a classical system.</p><blockquote name="8383" id="8383" class="graf--blockquote graf--startsWithDoubleQuote">“Simple is better than clever,” and using classical syntax because it is considered to be more “sophisticated” is just unnecessary, technical overhead.</blockquote><p name="0614" id="0614" class="graf--p"><em class="markup--em markup--p-em">Object.create</em> is more expressive and clearer than a bound <em class="markup--em markup--p-em">this</em> variable and <em class="markup--em markup--p-em">new</em>. Also, the prototype is stored in an object possibly outside the scope of the factory itself, so it can be modified and improved more easily and with <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Method_definitions" data-href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Method_definitions" class="markup--anchor markup--p-anchor" rel="nofollow"><em class="markup--em markup--p-em">method definition</em></a><em class="markup--em markup--p-em"> </em>syntax, just like ES6 classes.</p><blockquote name="4bf8" id="4bf8" class="graf--blockquote">The class keyword will probably be the most harmful feature in JavaScript. I have enormous respect for the brilliant and hard-working people who have been involved in the standardization effort, but even brilliant people occasionally do the wrong thing. — Eric Elliott</blockquote><p name="9902" id="9902" class="graf--p">Adding something which is unnecessary, possibly damaging, and counter to the very nature of the language is a bad move.</p><p name="d96d" id="d96d" class="graf--p">If you choose to use <em class="markup--em markup--p-em">class, </em>I hope I never have to try to maintain your code. In my opinion, developers should avoid the use of constructors<em class="markup--em markup--p-em">, class, </em>and <em class="markup--em markup--p-em">new, </em>and use methods of inheritance which more closely follow the language architecture.</p><h4 name="beac" id="beac" class="graf--h4">Glossary</h4><p name="9b4d" id="9b4d" class="graf--p"><em class="markup--em markup--p-em">Object.assign(a, b) </em>copies all enumerable properties of object <em class="markup--em markup--p-em">b </em>onto object <em class="markup--em markup--p-em">a </em>and then returns object <em class="markup--em markup--p-em">a</em></p><p name="e4aa" id="e4aa" class="graf--p"><em class="markup--em markup--p-em">Object.create(proto) </em>creates a new bare object with the prototype <em class="markup--em markup--p-em">proto</em></p><p name="b858" id="b858" class="graf--p graf--last"><em class="markup--em markup--p-em">Object.setPrototypeOf(obj, proto) </em>sets the internal <em class="markup--em markup--p-em">[[Prototype]] </em>property of <em class="markup--em markup--p-em">obj</em> to <em class="markup--em markup--p-em">proto</em></p></div>
            </div>
            <script>var _gaq = _gaq || []; _gaq.push(['_setAccount', 'UA-34802167-1']); _gaq.push(['_setDomainName', 'liuzhe.co']); _gaq.push(['_trackPageview']); (function() { var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true; ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'; var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s); })();</script>
        </body>
        </html>