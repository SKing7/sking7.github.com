<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Color Detection | Lyst Engineering</title>
<link rel="stylesheet" href="../css/article.css" />
</head>
<body>
<div class="m-content">
<h1>Color Detection | Lyst Engineering</h1>
<div><p>At <a href="http://www.lyst.com">Lyst</a>, we process millions of fashion products a day from over 500 retailers. One of the goals of the data-team is to transform this stream of semi-structured data into one consistent product catalogue. Colour is one of the most difficult fields to normalise. For example here are a selection of colors we saw in the past week.</p><p>Some of these colors can be deciphered by a human but all are very difficult for a computer. Even simple colors such as <code>snakeskin</code> or <code>periwinkle</code> can be hard to process automatically. In the past, we used a range of techniques to map retailer colors to lyst colors, from simple keyword matching to complex ML models. We found that these methods produced unsatisfactory results due to complexity of color names used by retailers. The only way we've found to accurately determine product color is via the product images.</p><h2 id="toc_0">Color clustering</h2><p>To find the colors of an image we use clustering on an Nx3 matrix where each row of the matrix represents an RGB pixel. The main colors of an image are deemed to be the cluster centers. Our use of clustering was inspired by this <a href="http://charlesleifer.com/blog/using-python-and-k-means-to-find-the-dominant-colors-in-images/">article from Charles Leifer</a>. Instead of using a fixed cluster size, we used an algorithm that dynamically determine the number of clusters (see mean-shift or DBSCAN in <a href="http://scikit-learn.org/">sklearn</a>) because a fixed number of clusters tended to result in muddy colors. </p><p>The images below demonstrate how well this technique works. The first image shows the detected colors ordered by the percentage of pixels in their respective cluster. Even the dots of color in the t-shirt were detected. The second image shows the cluster-space pallet. You can see that shadows have been clustered with green whilst highlights have been clustered with pink.</p><p><img src="/images/color_detection/clustering_example_complete.png" /></p><p>One major issue is that the first color is almost always going to be the background. My colleague Carl has a <a href="/data/images/2014/02/13/background-removal/">blog post</a> on how we remove backgrounds. When used with this clustering technique, we can even detect colors on images with graduated backgrounds.</p><p><img src="/images/color_detection/clustering_example_background.png" /></p><p>Now we can extract accurate hex colors for the majority of our product images. The next step is to translate these hex values into color names.</p><h2 id="toc_1">Color names</h2><p>At Lyst we use a small set of color names to describe products. These names are stored internally and used on the website so that users can filter by color.</p><p><img src="/images/color_detection/lyst_colors.png" /></p><p>Mapping from a hex value to a color name is more complex than it seems; for instance, when is a red considered pink or when does grey become black. The solution to this problem came from Randall Munroe of xkcd fame and his <a href="http://blog.xkcd.com/2010/05/03/color-survey-results/">Color Survey</a>.</p><p><img src="/images/color_detection/xkcd_color_map.png" /></p><p>The survey consisted of asking his readers to identify hex colors by name. The result is a list of 200k RGB values and names for those colors picked from a small set. The mappings required some changes to fit into our color system because we need extra colors such as beige and grey. We also added hardcoded thresholds for white and black as it is almost impossible to have perfectly white and black clothes in images. </p><p>With 200k entries the mapping is not complete over the RGB space (200000 / 255^3 is around 1.2%) so to map all hex colors to names we need to consider the distances between colors.</p><h2 id="toc_2">Color distance</h2><p>The data from xkcd is not complete so we need some way of finding similar colors. To define a metric of color difference we first need a space in which to measure distance. The RGB space is not suited to measuring color difference because distance magnitudes in the color space do not necessarily correspond to the magnitude of color difference as perceived by humans. To rectify this deficiency the International Commission on Illumination (CIE) defined the <a href="http://en.wikipedia.org/wiki/Lab_color_space">Lab color space</a> which aims to attain so called <code>perceptual uniformity</code>.</p><p><img src="/images/color_detection/cie_color_space.png" /></p><p>CIE has defined a number of <a href="http://en.wikipedia.org/wiki/Color_difference">color difference</a> functions. The simplest being CIE1976 which is euclidean distance on the Lab colorspace. The latest, CIE2000, attempts to rectify issues that CIE1976 has with perceptual uniformity as shown in the figure below. Under CIE1976, the two shades of green are considered further apart than blue and purple but under CIE2000 this is no longer a problem (thanks to <a href="https://github.com/rokcarl">Rok Carl</a> for the image).</p><p><img src="/images/color_detection/colors-distance-example.png" /></p><p>Now that we have a measure of distance the issues becomes: give a color C how do we find the nearest color in the xkcd matrix? The xkcd matrix consists nearly 200k colors so we would have to calculated CIE2000 200k times whenever we wanted to name an color.  This process is extremely expensive. On a 2013 macbook finding one color name takes over 5 seconds. </p><p>To speed up the color difference calculations we decided to vectorised deltaE. The standard deltaE functions are already implemented in the <a href="https://github.com/gtaylor/python-colormath">colormath</a> python package. We ported these to numpy and added a function to take a numpy array of Lab coordinates. When used with large data-sets the vectorised implementation is 25-180 times faster depending on which distance function is used. The <a href="https://github.com/gtaylor/python-colormath/blob/master/colormath/color_diff_matrix.py">vectorised delta E functions</a> are now available in the colormath package and can be used in the following manner.</p><div><pre><code><span>import</span> <span>csv</span>
<span>import</span> <span>numpy</span> <span>as</span> <span>np</span>

<span>from</span> <span>colormath.color_objects</span> <span>import</span> <span>LabColor</span>

<span># load list of 1000 random colors from the XKCD color chart</span>
<span>reader</span> <span>=</span> <span>csv</span><span>.</span><span>DictReader</span><span>(</span><span>'lab_matrix.csv)</span>
<span>lab_matrix</span> <span>=</span> <span>np</span><span>.</span><span>array</span><span>([</span><span>map</span><span>(</span><span>float</span><span>,</span> <span>row</span><span>.</span><span>values</span><span>())</span> <span>for</span> <span>row</span> <span>in</span> <span>reader</span><span>])</span>

<span># the reference color</span>
<span>color</span> <span>=</span> <span>LabColor</span><span>(</span><span>lab_l</span><span>=</span><span>69.34</span><span>,</span><span>lab_a</span><span>=-</span><span>0.88</span><span>,</span><span>lab_b</span><span>=-</span><span>52.57</span><span>)</span>

<span># find the closest match to `color` in `lab_matrix`</span>
<span>delta</span> <span>=</span> <span>color</span><span>.</span><span>delta_e_matrix</span><span>(</span><span>lab_matrix</span><span>)</span>
<span>nearest_color</span> <span>=</span> <span>lab_matrix</span><span>[</span><span>np</span><span>.</span><span>argmin</span><span>(</span><span>delta</span><span>)]</span>

<span>print</span> <span>'</span><span>%s</span><span> is closest to </span><span>%s</span><span>'</span> <span>%</span> <span>(</span><span>color</span><span>,</span> <span>nearest_color</span><span>)</span>
</code></pre></div><h2 id="toc_3">Results</h2><p>Now we can quickly deduce the hex color and color name of a product from its image with a high-degree of accuracy.</p><p><img src="/images/color_detection/pretty-white-girl.png" />
<img src="/images/color_detection/pretty-white-girl-color.png" /></p><p><img src="/images/color_detection/green-bag.png" />
<img src="/images/color_detection/green-bag-color.png" /></p><p><img src="/images/color_detection/red-shoe.png" />
<img src="/images/color_detection/red-shoe-color.png" /></p><p>Currently these colors get sent to humans to moderate (they can do this quickly thanks to a powerful interface), but in the future we hope to improve on these technique and completely automate color detection. A couple of Interesting future improvement would be to account for locality in the clustering and to use deltaE as the clustering distance function.</p><p>If you want to try this code you can download the latest version of colormath and look at the example. The full dataset can be downloaded as pickled numpy arrays:</p><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript><a href="http://disqus.com">comments powered by </a></div></div>
<script>var _gaq = _gaq || []; _gaq.push(['_setAccount', 'UA-34802167-1']); _gaq.push(['_setDomainName', 'liuzhe.co']); _gaq.push(['_trackPageview']); (function() { var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true; ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'; var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s); })();</script></body>
</html>