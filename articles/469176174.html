<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Cryptography in the Browser</title>
<link rel="stylesheet" href="../css/article.css" />
</head>
<body>
<div class="m-content">
<h1>Cryptography in the Browser</h1>
<div><p>One of the challenges we encountered in creating Opal was finding a fast and secure way to do encryption and decryption in the browser.</p><p>This post describes why browser-side cryptography has been a difficult problem, and how recent technological advances provide a solution.</p><h2>Three options for doing cryptography in a web app</h2><p>The only language with universal browser support is JavaScript.
Web apps like Opal are written in JavaScript so that they can run in any modern browser.
For cryptographic functions to be useful to a web app like Opal, they must be accessable in JavaScript.</p><p>There are really only three options for exposing cryptographic functions to browser JavaScript:</p><h3>1. Do the cryptography in a plugin.</h3><p>Plugins are compiled code that run inside a browser and can be called by JavaScript.</p><p>For example, there are cryptography libraries that exist in both Java and Flash.
These implementations are often very fast, but unfortunately they require users to install browser plugins, which many are unwilling or unable to do (for example, if they are on a public computer).</p><p>Another option is to use Chrome's <a href="https://developers.google.com/native-client/" title="Native Client">Native Client</a>, which allows browsers to run machine code compiled from C or C++.
Again, such implementations can be very fast, but right now Native Client is only available on Chrome.</p><p>So while plugins and Native Client have the benefit of speed, they lack portability because they require users to install specific plugins or use a specific browser.</p><h3>2. Use a Web API.</h3><p>The upcoming <a href="http://www.w3.org/TR/WebCryptoAPI/" title="Web Crypto API">Web Crypto API</a> will expose native cryptographic primitives to JavaScript, allowing web apps to use fast encryption and decryption routines.
However, this API is still in the draft stage, and it may be a while before it sees wide adoption among the major browser vendors.
As it stands now, only <code>crypto.getRandomValues()</code> has been implemented in most browsers.</p><p>Until the Web Crypto API becomes widely implemented, it's not a viable option for browser-side cryptography.</p><h3>3. Do the cryptography directly in JavaScript.</h3><p>This approach has the benefit of being extremely portable.
All browsers can run JavaScript, so all browsers can run a JavaScript cryptography library.</p><p>There are two main criticisms of doing cryptography in JavaScript: security and speed.
We discuss each of these criticisms in turn.</p><h2>JavaScript cryptography can be safe</h2><p><a href="http://www.matasano.com/articles/javascript-cryptography/" title="Javascript Cryptography Considered Harmful">This post</a> claims that "JavaScript Cryptography Considered Harmful", and lists a lot of evidence to support that claim.</p><p>Some of the statements on that post are no longer accurate.
For example, the post makes the point that <code>Math.random()</code> is not a good source of randomness, and thus it is impossible to get a suitable amount of random numbers for cryptography.
While it is true that <code>Math.random()</code> is not a good source of randomness, modern browsers have a <code>crypto.getRandomValues()</code> function which <em>does</em> provide enough randomness.</p><p>There are certainly use cases where JavaScript cryptography is a bad idea, but there are cases where it makes sense.</p><p><a href="http://blog.meadhbh.org/2013/08/in-defense-of-javascript-cryptography.html" title="In Defense of JavaScript Cryptography">This response</a> does a great job of refuting many of the claims in the first post, and also points out two valid use cases for JavaScript cryptography: end-to-end message security (a.k.a. host-proof applications), and secure remote password authentication.
These are exactly Opal's cryptographic use cases, so from a security standpoint we are comfortable doing cryptography in JavaScript.</p><h2>JavaScript cryptography can be fast</h2><p>Until recently, JavaScript has been too slow to perform the many complex computations required for secure cryptography.
This has caused many applications to rely on plugins for cryptography, which are less portable and often annoying to users.</p><p>Fortunately, JavaScript performance has been increasing at an amazing rate in recent years, so that it is now practical to perform cryptographic operations entirely in JavaScript.
Today, <a href="http://polycrypt.net">there</a> <a href="https://github.com/clipperz/javascript-crypto-library">are</a> <a href="https://github.com/jbt/js-crypto">many</a> <a href="http://crypto.stanford.edu/sjcl/">javascript</a> <a href="https://github.com/tonyg/js-nacl" title="js-nacl">cryptography</a> <a href="https://code.google.com/p/crypto-js/">libraries</a> <a href="http://digitalbazaar.com/forge/">to</a> <a href="http://shop-js.sourceforge.net">choose</a> <a href="https://www.pidder.de/pidcrypt/">from</a>.</p><p>The problem then becomes which one to choose.</p><h2>NaCl: a trusted C cryptography library</h2><p><a href="http://nacl.cr.yp.to">NaCl</a> (pronounced "salt") is a C library that exposes high-level functionality for symmetric and public-key encryption, decryption, signing, verification, etc.
It was written by cryptographers, and is well-known and trusted in the cryptographic community.
The one problem with NaCl is that it's written in C, and C is not JavaScript.</p><h3>js-NaCl: NaCl compiled to JavaScript</h3><p>Luckily, we can compile NaCl to LLVM bytecode, and then use <a href="https://github.com/kripken/emscripten" title="Emscripten">emscripten</a> to compile LLVM bytecode to JavaScript.
Moreover, the LLVM compiler can perform many optimizations during compilation, so the resulting JavaScript is highly optimized.
Thus, we can compile the NaCl C library into JavaScript, ready to be run in a browser!</p><p>The <a href="https://github.com/tonyg/js-nacl" title="js-nacl">js-nacl</a> project is exactly this: the NaCl cryptography library compiled into JavaScript.</p><h3>asm.js is fast!</h3><p>What's even better is that emscripten can compile to a very special subset of JavaScript, called <a href="http://asmjs.org/" title="asm.js">asm.js</a>.
You can think of asm.js as assembly language dressed up like JavaScript.
When a browser encounters a chunk of asm.js code, it can compile it to very efficient machine code which runs at near-native speeds.</p><p>Currently, Firefox is the only major browser to support asm.js optimizations.
This makes the encryption and decryption with js-nacl very fast in Firefox, between 2 and 8 times faster than Chrome, depending on the operation.
But even in Chrome, js-nacl is blazingly fast, outperforming all the other cryptography libraries we tested. <img src="/nacl-benchmarks.png" alt="crazy fast in FF" /></p><p>The combination of a trusted security library like NaCl with fast performance in modern browsers makes js-nacl the obvious cryptography library for web apps like Opal.</p><p>For similar reasons, Opal uses an <a href="https://github.com/tonyg/js-scrypt">emscripten-compiled asm.js version</a> of the popular <a href="http://www.tarsnap.com/scrypt.html">scrypt</a> library for passphrase stretching (working on the post now).
You can see exact benchmarks of js-nacl and js-scrypt from the project maintainer <a href="http://www.eighty-twenty.org/index.cgi/tech/benchmarking-nacl-and-scrypt-in-the-browser-20130815.html" title="New benchmarks of NaCl and scrypt in the browser">here</a>. We also set up some <a href="http://jsperf.com/js-nacl">jsperf tests</a> for js-nacl to get a better idea of performance across browser versions, <a href="http://jsperf.com/js-nacl">feel free to run them</a>.</p><h4>Update: asm.js is getting even faster!</h4><p>Since writing this post, the V8 team has implemented many optimizations that increase asm.js performance.
<img src="/asm-benchmarks.png" alt="asm.js benchmarks" />
However, V8 still ignores the "use asm" pragma, and applies no special optimizations to the asm.js code.
The issue for implementing asm.js-specific optimizations in V8 can be found <a href="https://code.google.com/p/v8/issues/detail?id=2599#c32https://code.google.com/p/v8/issues/detail?id=2599">here</a>.</p><p>In our most recent testing, FireFox is still 2-4 times faster than Chrome when encrypting and decrypting with the NaCl library (both for public key and symmetric encryption), although Chrome is twice as fast at generating a key pair.
A more in-depth post about these benchmarks will be published soon.</p><p>
        <a href="https://twitter.com/share" data-via="opalapp" data-related="jxson" data-count="none">Tweet</a>
      </p></div></div>
<script>var _gaq = _gaq || []; _gaq.push(['_setAccount', 'UA-34802167-1']); _gaq.push(['_setDomainName', 'liuzhe.co']); _gaq.push(['_trackPageview']); (function() { var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true; ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'; var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s); })();</script></body>
</html>