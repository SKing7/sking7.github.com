
        <!doctype html>
        <html>
        <head>
            <meta charset="utf-8"/>
            <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
            <title>Hypertext Transfer Protocol (HTTP/1.1): Conditional Requests</title>
            <link rel="stylesheet" href="../css/article.css" />;
        </head>
        <body>
            <div class="m-content">
                <h1>Hypertext Transfer Protocol (HTTP/1.1): Conditional Requests</h1>
                <div id="rfc.section.2.p.1"><p>This specification defines two forms of metadata that are commonly used to observe resource state and test for preconditions: modification dates () and opaque entity tags (). Additional metadata that reflects resource state has been defined by various extensions of HTTP, such as Web Distributed Authoring and Versioning (WebDAV, <a href="http://greenbytes.de/tech/webdav/rfc7232.html#RFC4918" id="rfc.xref.RFC4918.1"><cite title="HTTP Extensions for Web Distributed Authoring and Versioning (WebDAV)">[RFC4918]</cite></a>), that are beyond the scope of this specification. A resource metadata value is referred to as a "<dfn>validator</dfn>" when it is used within a precondition.<a class="self" href="http://greenbytes.de/tech/webdav/rfc7232.html#rfc.section.2.p.1">¶</a></p></div><section id="weak.and.strong.validators"><h3 id="rfc.section.2.1"><a href="http://greenbytes.de/tech/webdav/rfc7232.html#rfc.section.2.1">2.1</a>&nbsp;<a href="http://greenbytes.de/tech/webdav/rfc7232.html#weak.and.strong.validators">Weak versus Strong</a></h3><div id="rfc.section.2.1.p.1"><p>Validators come in two flavors: strong or weak. Weak validators are easy to generate but are far less useful for comparisons. Strong validators are ideal for comparisons but can be very difficult (and occasionally impossible) to generate efficiently. Rather than impose that all forms of resource adhere to the same strength of validator, HTTP exposes the type of validator in use and imposes restrictions on when weak validators can be used as preconditions.<a class="self" href="http://greenbytes.de/tech/webdav/rfc7232.html#rfc.section.2.1.p.1">¶</a></p></div><div id="rfc.section.2.1.p.2"><p>A "strong validator" is representation metadata that changes value whenever a change occurs to the representation data that would be observable in the payload body of a <a href="http://greenbytes.de/tech/webdav/rfc7231.html#status.200" class="smpl">200 (OK)</a> response to GET.<a class="self" href="http://greenbytes.de/tech/webdav/rfc7232.html#rfc.section.2.1.p.2">¶</a></p></div><div id="rfc.section.2.1.p.3"><p>A strong validator might change for reasons other than a change to the representation data, such as when a semantically significant part of the representation metadata is changed (e.g., <a href="http://greenbytes.de/tech/webdav/rfc7231.html#header.content-type" class="smpl">Content-Type</a>), but it is in the best interests of the origin server to only change the value when it is necessary to invalidate the stored responses held by remote caches and authoring tools.<a class="self" href="http://greenbytes.de/tech/webdav/rfc7232.html#rfc.section.2.1.p.3">¶</a></p></div><div id="rfc.section.2.1.p.4"><p>Cache entries might persist for arbitrarily long periods, regardless of expiration times. Thus, a cache might attempt to validate an entry using a validator that it obtained in the distant past. A strong validator is unique across all versions of all representations associated with a particular resource over time. However, there is no implication of uniqueness across representations of different resources (i.e., the same strong validator might be in use for representations of multiple resources at the same time and does not imply that those representations are equivalent).<a class="self" href="http://greenbytes.de/tech/webdav/rfc7232.html#rfc.section.2.1.p.4">¶</a></p></div><div id="rfc.section.2.1.p.5"><p>There are a variety of strong validators used in practice. The best are based on strict revision control, wherein each change to a representation always results in a unique node name and revision identifier being assigned before the representation is made accessible to GET. A collision-resistant hash function applied to the representation data is also sufficient if the data is available prior to the response header fields being sent and the digest does not need to be recalculated every time a validation request is received. However, if a resource has distinct representations that differ only in their metadata, such as might occur with content negotiation over media types that happen to share the same data format, then the origin server needs to incorporate additional information in the validator to distinguish those representations.<a class="self" href="http://greenbytes.de/tech/webdav/rfc7232.html#rfc.section.2.1.p.5">¶</a></p></div><div id="rfc.section.2.1.p.6"><p>In contrast, a "weak validator" is representation metadata that might not change for every change to the representation data. This weakness might be due to limitations in how the value is calculated, such as clock resolution, an inability to ensure uniqueness for all possible representations of the resource, or a desire of the resource owner to group representations by some self-determined set of equivalency rather than unique sequences of data. An origin server <em class="bcp14">SHOULD</em> change a weak entity-tag whenever it considers prior representations to be unacceptable as a substitute for the current representation. In other words, a weak entity-tag ought to change whenever the origin server wants caches to invalidate old responses.<a class="self" href="http://greenbytes.de/tech/webdav/rfc7232.html#rfc.section.2.1.p.6">¶</a></p></div><div id="rfc.section.2.1.p.7"><p>For example, the representation of a weather report that changes in content every second, based on dynamic measurements, might be grouped into sets of equivalent representations (from the origin server's perspective) with the same weak validator in order to allow cached representations to be valid for a reasonable period of time (perhaps adjusted dynamically based on server load or weather quality). Likewise, a representation's modification time, if defined with only one-second resolution, might be a weak validator if it is possible for the representation to be modified twice during a single second and retrieved between those modifications.<a class="self" href="http://greenbytes.de/tech/webdav/rfc7232.html#rfc.section.2.1.p.7">¶</a></p></div><div id="rfc.section.2.1.p.8"><p>Likewise, a validator is weak if it is shared by two or more representations of a given resource at the same time, unless those representations have identical representation data. For example, if the origin server sends the same validator for a representation with a gzip content coding applied as it does for a representation with no content coding, then that validator is weak. However, two simultaneous representations might share the same strong validator if they differ only in the representation metadata, such as when two different media types are available for the same representation data.<a class="self" href="http://greenbytes.de/tech/webdav/rfc7232.html#rfc.section.2.1.p.8">¶</a></p></div><div id="rfc.section.2.1.p.9"><p>Strong validators are usable for all conditional requests, including cache validation, partial content ranges, and "lost update" avoidance. Weak validators are only usable when the client does not require exact equality with previously obtained representation data, such as when validating a cache entry or limiting a web traversal to recent changes.<a class="self" href="http://greenbytes.de/tech/webdav/rfc7232.html#rfc.section.2.1.p.9">¶</a></p></div></section>
            </div>
            <script>var _gaq = _gaq || []; _gaq.push(['_setAccount', 'UA-34802167-1']); _gaq.push(['_setDomainName', 'liuzhe.co']); _gaq.push(['_trackPageview']); (function() { var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true; ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'; var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s); })();</script>
        </body>
        </html>