
        <!doctype html>
        <html>
        <head>
            <meta charset="utf-8"/>
            <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
            <title>唯一ID生成原理与PHP实现</title>
            <link rel="stylesheet" href="../css/article.css" />;
        </head>
        <body>
            <div class="m-content">
                <h1>唯一ID生成原理与PHP实现</h1>
                <section data-role="outer" label="Powered by 135editor.com"><section class="_135editor" data-tools="135编辑器" data-id="86486"><section><section data-style="text-align: center;color:rgb(255,255,255);"><section><p><span>snowflake算法</span></p></section><section></section></section></section></section><p>虽然PHP提供了一个生成唯一ID的函数uniqid()，但这个函数真的可以生成唯一ID吗？我们来看看uniqid()的具体实现：<br></p><p><span>PHP_FUNCTION(uniqid)<br>{<br>...<br>gettimeofday((</span><span>struct</span><span>&nbsp;timeval&nbsp;*)&nbsp;&amp;tv,&nbsp;(</span><span>struct</span><span>&nbsp;timezone&nbsp;*)&nbsp;NULL);<br>sec&nbsp;=&nbsp;(</span><span>int</span><span>)&nbsp;tv.tv_sec;<br>usec&nbsp;=&nbsp;(</span><span>int</span><span>)&nbsp;(tv.tv_usec&nbsp;%&nbsp;0x100000);<br>spprintf(&amp;uniqid,&nbsp;0,&nbsp;</span><span>"%s%08x%05x"</span><span>,&nbsp;prefix,&nbsp;sec,&nbsp;usec);<br>RETURN_STRING(uniqid,&nbsp;0);<br>}</span></p><p>&nbsp;从代码可以看出，uniqid()是通过微妙级时间戳来实现的，在分布式高并发的情况下，ID的重复率是很高的，所以我们不能使用uniqid()来生成唯一ID。<br></p><section class="_135editor" data-tools="135编辑器" data-id="86517"><section><p class="135brush" data-brushtype="text">snowflake算法</p></section></section><p>既然不能单纯靠时间戳来保证唯一性，那么是不是可以增加以下特征值来保证呢？为此，Twitter公司发明了snowflake算法。snowflake算法的核心原理是把一个64位的整数分为3个部分，如下图：</p><p><img data-s="300,640" data-type="jpeg" data-src="http://mmbiz.qpic.cn/mmbiz_jpg/ciab8jTiab9J4qoI6rlhksLNIbh5Xo2svwrJngesUmaYDIMN750JlVkhzBQ352jCiaSvDcJc9PqIKMxKupDOJo5AA/0?wx_fmt=jpeg" data-ratio="0.3388834476003918" data-w="1021"></p><p>如上图所示，高端的第一位不使用，接着的41位字节用于存储毫秒级的时间戳，紧跟着时间戳的10位作为机器ID，而最后12位为序列号。</p><ol class=" list-paddingleft-2"><li><p>对于不同的机器来说，可以为每一台机器分配一个唯一的机器ID，这样就可以保证每台机器锁生成的ID不会重复。</p></li><li><p>对于同一台机器，如果同一时刻多个客户端并发请求，那么可以通过增加序列号来保证ID唯一性。</p></li></ol><p>默认情况下41位的时间戳可以支持该算法使用到2082年（需要通过减去一个起始时间戳），10位的工作机器ID可以支持1023台机器，12位的序列号支持1毫秒产生4095个自增序列ID。<br>也就是说1台机器1秒可以承受4095000个并发，可以胜任任何场景。snowflake算法的代码实现大概如下：<br></p><p><span>static</span><span>&nbsp;uint64_t&nbsp;last_ts&nbsp;=&nbsp;0;<br></span><span>static</span><span>&nbsp;uint64_t&nbsp;sequence&nbsp;=&nbsp;0;<br></span><span>static</span><span>&nbsp;uint64_t&nbsp;datacenter_id&nbsp;=&nbsp;0;<br><span>// 获取毫秒时间戳</span><br>uint64_t&nbsp;current_timestamp()<br>{<br></span><span>struct</span><span>&nbsp;timeval&nbsp;tv;<br>uint64_t&nbsp;retval;<br></span><span>if</span><span>&nbsp;(gettimeofday(&amp;tv,&nbsp;NULL)&nbsp;==&nbsp;-1)&nbsp;{<br></span><span>return</span><span>&nbsp;0ULL;<br>}<br>retval&nbsp;=&nbsp;(u64_t)tv.tv_sec&nbsp;*&nbsp;1000ULL&nbsp;+<br>(u64_t)tv.tv_usec&nbsp;/&nbsp;1000ULL;<br></span><span>return</span><span>&nbsp;retval;<br>}<br><span>// 如果在同一毫秒内超过了并发现在, 那么等待下一毫秒</span><br>uint64_t&nbsp;skip_next_millis()<br>{<br>uint64_t&nbsp;ts;<br></span><span>while</span><span>&nbsp;(1)&nbsp;{<br>ts&nbsp;=&nbsp;current_timestamp();<br></span><span>if</span><span>&nbsp;(ts&nbsp;&gt;&nbsp;last_ts)&nbsp;{<br></span><span>break</span><span>;<br>}<br>}<br></span><span>return</span><span>&nbsp;ts;<br>}<br><span>// 获取下一个ID</span><br>uint64_t&nbsp;get_next_id()<br>{<br>uint64_t&nbsp;retval,&nbsp;ts;<br>ts&nbsp;=&nbsp;current_timestamp();<br></span><span>if</span><span>&nbsp;(ts&nbsp;==&nbsp;last_ts)&nbsp;{<span>&nbsp;// 同一毫秒内多个并发</span><br>sequence&nbsp;=&nbsp;(sequence&nbsp;+&nbsp;1)&nbsp;&amp;&nbsp;0xFFF; <span>// 增加序列号计数器</span><br></span><span>if</span><span>&nbsp;(sequence&nbsp;==&nbsp;0)&nbsp;{ &nbsp;<span>// 计数器用完</span><br>ts&nbsp;=&nbsp;skip_next_millis(); <span>// 等待下一毫秒</span><br>}<br>}&nbsp;</span><span>else</span><span>&nbsp;{<br>sequence&nbsp;=&nbsp;0; <span>// 清空序列号计数器</span><br>}<br>last_ts&nbsp;=&nbsp;ts;<br>retval&nbsp;=&nbsp;(ts&nbsp;&lt;&lt;&nbsp;22)&nbsp;|&nbsp;(datacenter_id&nbsp;&lt;&lt;&nbsp;12)&nbsp;|&nbsp;sequence;<br></span><span>return</span><span>&nbsp;retval;<br>}</span></p><section class="_135editor" data-tools="135编辑器" data-id="86486"><section><section></section><section data-style="text-align: center;color:rgb(255,255,255);"><section><p><span class="135brush" data-brushtype="text">PHP实现唯一ID生成函数</span></p></section><section></section></section></section></section><p>严格来说使用PHP是不能实现snowflake算法的，这是因为PHP的运行机制导致的。一般一台机器会启动多个PHP进程，而且进程之间是不能共享内存的，就是说多个PHP进程之间不能使用同一个序列号，这样就会导致不同进程生成的ID可能会重复。而且每次请求完，PHP都会释放本次请求的所有资源，那么就不能记录最后一次时间戳和序列号计数器的值（虽然可以使用文件或者memcached之类实现，当这样性能就会降低很多）。所以说使用PHP是不能实现snowflake算法的。</p><p>不能使用PHP代码实现snowflake算法，但是可以通过PHP扩展来实现，下图是PHP-FPM的运行机制：</p><p><img data-s="300,640" data-type="jpeg" data-src="http://mmbiz.qpic.cn/mmbiz_jpg/ciab8jTiab9J54W4F2454uQ9ChdfMkqrMhxG0IibqqJibcr5FKQfVrIXMhWz6slOxPdN4DrZN6pJ1iacT2hvmPN1czA/0?wx_fmt=jpeg" data-ratio="0.7934065934065934" data-w="455"></p><p>从上图可以看出，在创建worker进程之前先会调用每个扩展的init()函数（PHP_MINIT_FUNCTION函数），所以我们可以在init()函数创建一块共享内存，然后每个worker进程就可以共用这块内存（因为fork之前创建的共享内存可以在子进程中共用）。</p><p>因为不同的进程并发访问共享内存可能会导致数据不一致的问题，所以必须解决资源竞争的问题，解决资源竞争最常用的方法就是使用锁。<br></p><p>进程间一般使用的锁有：信号量和自旋锁。信号量与自旋锁的不同之处是，信号量会发生进程上下文切换，而自旋锁不会。</p><p>当然这两种锁都可以解决资源竞争问题，但是相对于生成唯一ID这种场景，使用自旋锁会有更好的性能，这是因为生成ID这个过程非常短，而自旋锁锁不需要切换上下文。</p><section class="_135editor" data-tools="135编辑器" data-id="86517"><section><p class="135brush" data-brushtype="text">自旋锁</p></section></section><p>自旋锁的原理是不断测试锁是否能够被上锁，如果能够上锁就进行上锁操作，否则就不断重复上面的操作。下面代码是一个简单的实现：</p><p><span>void</span><span>&nbsp;spin_lock(atomic_t&nbsp;*</span><span>lock</span><span>,&nbsp;</span><span>int</span><span>&nbsp;id)<br>{<br></span><span>int</span><span>&nbsp;i,&nbsp;n;<br></span><span>for</span><span>&nbsp;(&nbsp;;;&nbsp;)&nbsp;{<br></span><span>if</span><span>&nbsp;(*</span><span>lock</span><span>&nbsp;==&nbsp;0&nbsp;&amp;&amp;<br>__sync_bool_compare_and_swap(</span><span>lock</span><span>,&nbsp;0,&nbsp;id))&nbsp;{<br></span><span>return</span><span>;<br>}<br></span><span>if</span><span>&nbsp;(ncpu&nbsp;&gt;&nbsp;1)&nbsp;{<br></span><span>for</span><span>&nbsp;(n&nbsp;=&nbsp;1;&nbsp;n&nbsp;&lt;&nbsp;129;&nbsp;n&nbsp;&lt;&lt;&nbsp;1)&nbsp;{<br></span><span>for</span><span>&nbsp;(i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;n;&nbsp;i++)&nbsp;{<br>__asm(</span><span>"pause"</span><span>);<br>}<br></span><span>if</span><span>&nbsp;(*</span><span>lock</span><span>&nbsp;==&nbsp;0&nbsp;&amp;&amp;<br>__sync_bool_compare_and_swap(</span><span>lock</span><span>,&nbsp;0,&nbsp;id))&nbsp;{<br></span><span>return</span><span>;<br>}<br>}<br>}<br>sched_yield();<br>}<br>}</span></p><p>__sync_bool_compare_and_swap(var, old, new)函数是一个原子性操作，作用就是比较var与old的值，如果相等就把var的值改为new，如果不相等就继续进行这个操作直到成功为止。这里有个小技巧，就是当长时间获取不到锁的情况下，我们会调用sched_yield()系统调用让出CPU，从而避免过度使用CPU资源。</p><section class="_135editor" data-tools="135编辑器" data-id="86486"><section><section></section><section data-style="text-align: center;color:rgb(255,255,255);"><section><p><span><span>总结</span></span></p></section><section></section></section></section></section><p>snowflake算法可以有效的生成唯一ID，而且通过配置机器ID可以很好地支持分布式环境。本文介绍了怎么使用PHP扩展来实现<span>snowflake算法，具体实现可以参考本人所写的Atom扩展： https://github.com/liexusong/atom&nbsp;</span></p></section>
            </div>
            <script>var _gaq = _gaq || []; _gaq.push(['_setAccount', 'UA-34802167-1']); _gaq.push(['_setDomainName', 'liuzhe.co']); _gaq.push(['_trackPageview']); (function() { var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true; ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'; var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s); })();</script>
        </body>
        </html>