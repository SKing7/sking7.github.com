<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Faster, smaller and more beautiful web with WebP</title>
<link rel="stylesheet" href="../css/article.css" />
</head>
<body>
<div class="m-content">
<h1>Faster, smaller and more beautiful web with WebP</h1>
<div id="post" itemscope="" itemtype="http://schema.org/Article"><p>By <a href="/" rel="author" itemprop="author">Ilya Grigorik</a> on <b itemprop="datePublished" datetime="2013-03-07">March 07, 2013</b></p><p><img src="http://1-ps.googleusercontent.com/h/www.igvita.com/posts/13/xwebp-small.png.pagespeed.ic.bPLWKohE0b.png" width="130" height="100" />At the risk of sounding repetitive... An average page is now <a href="http://httparchive.org/interesting.php#bytesperpage">over 1300 kB</a> in size and over 60% of that is in images. Hence, if you have limited time, then <strong>inspecting and optimizing your image assets will likely yield the highest rate of return</strong>.</p><p>Case in point, the new <a href="https://developers.google.com/chrome/mobile/docs/data-compression">data compression proxy for Chrome</a> applies dozens of different content optimizations, but image optimization almost invariably comes out at the top. End result? On average, data usage is reduced by 50%! The strategy? Simple, transcode all images to <a href="https://developers.google.com/speed/webp/">WebP</a>!</p><p>With that in mind, I had a chance to sit down with Stephen Konig (Product Manager on the WebP team), to chat about the latest news, team progress over last two years, and where WebP is heading. You can scan through the <a href="https://docs.google.com/presentation/d/1NidHQ-HAWpgQiYJ44gOfgcp_FQ2u59WE4eHuSvwddXY/present">slides</a>, or watch the <a href="http://www.youtube.com/watch?v=4tu2SJfSalA">GDL on YouTube</a>, but below are a few highlights and resources to help you get started.</p><h2>Focus on adoption in 2013</h2><p>The primary focus and goal for the WebP team over the course of the past two years has been on developing the necessary features of the format itself - i.e., the engineering part. The good news is, end of 2012 marked an important milestone: support for lossy and lossless compression, alpha channel, animation, metadata, color profiles, and more. With all of these features in place, <strong>the focus is shifting towards tooling and driving adoption</strong>.</p><p><img src="http://1-ps.googleusercontent.com/h/www.igvita.com/posts/13/xchrome-webstore.png.pagespeed.ic.avJMKe9_Ae.jpg" width="98" height="85" />In fact, in the time-honored tradition of dogfooding own products, there is already a large and growing list of Google properties (Gmail, Drive, Picasa, Instant Previews, Play Magazines, Image Search, YouTube, ...) with WebP support. Most recently, Chrome Web Store <a href="http://blog.chromium.org/2013/02/using-webp-to-improve-speed.html">switched to WebP</a>, saw ~30% byte reduction on average, and is now saving <strong>several terabytes of bandwidth per day!</strong></p><p>In parallel, there are now over 300,000 sites using the open-source <a href="https://developers.google.com/speed/pagespeed/">PageSpeed</a> libraries, which enable transparent WebP transcoding on Apache (<a href="https://developers.google.com/speed/pagespeed/mod">mod_pagespeed</a>) and Nginx (<a href="https://github.com/pagespeed/ngx_pagespeed">ngx_pagespeed</a>), and there is a growing list of commercial products (Torbit, EdgeCast) which can do similar optimizations - the bandwidth savings are hard to argue against!</p><h2>"Time to Glass" vs. Bandwidth</h2><p>WebP achieves better compression by spending more CPU cycles - that's an inherent tradeoff of any compression algorithm. Today, when compared to JPEG, the encoding speed for WebP is <em>~10x</em> slower, and decoding is <em>~1.4x</em> slower when done on the CPU. Is that big deal? The answer depends on your application: if you are generating unique and dynamic images on every request, then the extra CPU overhead is something you'll notice. But if the files are (mostly) static, then the encoding time is a non-issue.</p><p>More likely, the concern is not over encoding, but over decoding speeds. Is <em>1.4x</em> going to hurt your performance? Once again, it depends on your application - as with any performance metric, <em>measure it.</em> The Ebay tech team recently published a <a href="http://www.ebaytechblog.com/2013/02/22/a-picture-is-worth-a-thousand-words/">great overview of various image optimization techniques</a>:</p><p><img src="http://1-ps.googleusercontent.com/h/www.igvita.com/posts/13/xwebp-jpeg.png.pagespeed.ic.Go8LZo2rdr.jpg" /></p><blockquote><a href="http://www.webpagetest.org/video/compare.php?tests=130125_6N_KZA%2C130125_NH_KZ8&amp;thumbSize=200&amp;ival=100&amp;end=full">This test from webpagetest.org</a> compares the page load time of WebP vs. JPEG. The test has one page with 50 images in the WebP format, and another page with the same 50 images in the JPEG format. Because the WebP page had to download fewer bytes (474484 vs. 757228), it completes loading much earlier compared to the JPEG page... <b>If you track your web site's browser usage stats and find that Chrome/Opera users are a sizable chunk, using WebP images will improve the page load time for these users</b>.</blockquote><p>Despite the extra decoding time, the visual rendering time is much faster due to fewer bytes shipped. Further, for a significant segment of the population, bytes are (literally) expensive: <strong>bandwidth caps are a real constraint for many users, especially on mobile devices and in the developing world.</strong></p><h2>Deploying WebP on Native and Web platforms</h2><p><img src="/posts/13/android-ios.png" />Deploying WebP in a native app, iOS or Android, is actually very straightforward: Android 4.x.x+ has <a href="https://docs.google.com/presentation/d/1NidHQ-HAWpgQiYJ44gOfgcp_FQ2u59WE4eHuSvwddXY/present#slide=id.gaf279013_033">native support</a> for WebP, and there is a <a href="https://github.com/alexey-pelykh/webp-android-backport">backport</a> for earlier versions; on iOS you can use the official libraries provided by the WebP team (<a href="http://www.ioncannon.net/programming/1483/using-webp-to-reduce-native-ios-app-size/">tutorial</a>, <a href="https://github.com/carsonmcdonald/WebP-iOS-example">demo app</a>). Since you control the display logic and the platform, you can safely convert all assets to WebP and save on data transfers both from and to the device - WebP helps for upload cases equally well!</p><p>On the web, things get a bit more difficult, but still manageable. Chrome and Opera have native support for WebP, and there is an <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=600919">open discussion</a> with the Firefox team. There are also third party plugins for <a href="http://seiryu.home.comcast.net/~seiryu/weppy.html">Safari</a> and <a href="https://developers.google.com/chrome/chrome-frame/">Chrome Frame</a> provides support for IE - however, you can't rely on these plugins being present. Instead, for time being you have to fall back to <code>User-Agent</code> detection on the server, or use a <a href="https://github.com/Modernizr/Modernizr/tree/master/feature-detects/img">JavaScript check</a> - in fact, there is even a <a href="http://webpjs.appspot.com/">JS polyfill</a>! Finally, there is <a href="https://code.google.com/p/chromium/issues/detail?id=169182">work in progress</a> to fix <code>Accept</code> negotiation to make this entire process <a href="http://www.igvita.com/2012/12/18/deploying-new-image-formats-on-the-web/">much easier</a>.</p><p><img src="http://1-ps.googleusercontent.com/h/www.igvita.com/posts/13/xwebp-serverside.png.pagespeed.ic.q-SHi6FTdP.jpg" /></p><p>The most popular technique today and one that is used by PageSpeed and other optimization products, is to rely on server detection: run a <code>User-Agent</code> check, and serve the HTML with WebP image links, or non-WebP links. What are the <code>User-Agent</code> rules? PageSpeed is open-source, so the answer is <a href="https://code.google.com/p/modpagespeed/source/browse/trunk/src/net/instaweb/http/user_agent_matcher.cc#86">right in the code</a>. Further, to simplify this process, I've translated the rules into <strong>sample configuration files for Varnish and Nginx</strong>:</p><p>With above detection in place, Varnish and Nginx will report an extra <code>WebP: lossy, lossless</code> header to the app server, allowing your application to generate customized HTML based on available WebP support. In turn, the static image assets can be safely cached either on the local file system or on any CDN service. The only other caveat is that the HTML must be marked with <code>Cache-Control: private</code> to ensure that an intermediate cache does not accidentally serve the wrong file to the wrong browser.</p><p>For more details on WebP, scan through the <a href="https://docs.google.com/presentation/d/1NidHQ-HAWpgQiYJ44gOfgcp_FQ2u59WE4eHuSvwddXY/present">slides</a>, and check out the <a href="http://www.youtube.com/watch?v=4tu2SJfSalA">GDL on YouTube</a> for additional context.</p></div></div>
<script>var _gaq = _gaq || []; _gaq.push(['_setAccount', 'UA-34802167-1']); _gaq.push(['_setDomainName', 'liuzhe.co']); _gaq.push(['_trackPageview']); (function() { var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true; ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'; var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s); })();</script></body>
</html>