<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>High performance touch interactions</title>
<link rel="stylesheet" href="../css/article.css" />
</head>
<body>
<div class="m-content">
<h1>High performance touch interactions</h1>
<div class="BlogPost-body" itemprop="articleBody"><p>The tools we use to build interfaces for the web browser are pretty low level, browsers currently expose no APIs to interpret a user’s gestures and there isn’t a standard library for mixing in real-life behaviours such as gravity or resistance. Our users will increasingly expect websites to behave like native applications so if we want to compete we have to implement everything ourselves on the client-side in JavaScript.</p><p>This can mean we end up with a lot of code but at the same time we can’t afford to make our sites clunky because we’ve known for a long time <a href="http://www.nngroup.com/articles/response-times-3-important-limits/">users expect feedback in around 100ms</a>.</p><p>Stripping back the complexity, a basic draggable element is straightforward to implement - try moving the red square around in the example below (don’t worry, it works with a mouse too):</p><figure class="Embed js-embed" role="widget"><button class="Embed-cover">Click to load demo</button></figure><p>Moving the square around should be fairly smooth, it’s just one element on a blank surface and it’s much simpler than anything we’d be asked to build. But moving on quickly to <a href="http://jsfiddle.net/i_like_robots/eo299L9v/2/">a more complex test with gradients, transparency and shadows</a> the performance can noticeably degrade on lower powered devices.</p><p>Using the timeline panel of the web inspector to diagnose the performance problem it’s easy to see what that problem is; each time the square is moved the browser is repainting the complex layers. If the interaction is going to be smooth then that has to be avoided.</p><figure><img class="u-imgCenter u-imgShadow" src="http://maketea.co.uk/images/2015-02-16-high-performance-touch-interactions/timeline-demo-2.png" alt="Web inspector timeline showing repeated repainting for each movement" /><figcaption><p>Each time the element is re-positioned it’s being repainted.</p></figcaption></figure><p>To avoid repainting the element each time only requires a small change to the code; instead of changing the absolute position of the element <a href="http://jsfiddle.net/i_like_robots/eo299L9v/3/">it can be transformed</a> using the <code>translate3d</code> CSS function. Browsers that support the property will attempt to switch to hardware compositing for the page and promote the element to <a href="http://aerotwist.com/blog/on-translate3d-and-layer-creation-hacks/">its own accelerated context</a>.</p><p>The transform function also has a second benefit, <a href="http://www.paulirish.com/2012/why-moving-elements-with-translate-is-better-than-posabs-topleft/">it can move the element into sub-pixel positions</a>. This means instead of snapping the element to the nearest pixel it can interpolate between them and maintain a smoother appearance overall.</p><aside class="Insert Insert--aside"><p>Only promote elements to accelerated layers when necessary as they consume memory that may be in short supply. Always use conscientiously and remove transforms from elements that no longer need it.</p></aside><p>Employing the timeline panel again to review the difference we can see that the spent time painting has been reduced and the frame rate now remains comfortably at 60 FPS for most the recorded period:</p><figure><img class="u-imgCenter u-imgShadow" src="http://maketea.co.uk/images/2015-02-16-high-performance-touch-interactions/timeline-demo-3.png" alt="Web inspector timeline showing no repaints triggered by each event" /><figcaption><p>Using a CSS 3D transform to create an accelerated layer avoids repainting an element each time it is moved.</p></figcaption></figure><p>The example code handling the interaction has so far been very basic, if it’s going to be useful then it needs to imply some meaning from the user’s movements. The following example tracks the current direction and velocity of the gesture, the distance the square has moved from its starting position, and updates that information on screen:</p><figure class="Embed js-embed" role="widget"><button class="Embed-cover">Click to load demo</button></figure><p>The example above can get quite janky on low powered devices, the extra work added to each event callback is apparently really slowing it down. Investigating with the timeline panel again it’s clear that although each callback is taking longer they’re not complex enough to make a device suffer.</p><p>The jank in this situation is actually being caused by the events not coinciding with the browser’s update rate. This was happening insidiously in the previous examples but the additional (<a href="http://wilsonpage.co.uk/preventing-layout-thrashing/">relatively expensive</a>) changes to the DOM required by the calculation displays are exacerbating it.</p><aside class="Insert Insert--aside"><p>JavaScript in the browser is single-threaded so while it’s busy it will ignore events being triggered. Slow touch event handlers or performing work other than processing the events may cause input latency.</p></aside><p>Because the events can be triggered in a continuous stream the code handling them is likely to bunch too much work into a single frame:</p><figure><img class="u-imgCenter u-imgShadow" src="http://maketea.co.uk/images/2015-02-16-high-performance-touch-interactions/timeline-demo-4.png" alt="Web inspector timeline with 100ms highlighted" /><figcaption><p>Multiple events can be processed unnecessarily in each frame, causing regular dips below 60 FPS.</p></figcaption></figure><p>The issue can be remedied by using the browser’s animation timing API which allows a callback to be scheduled to fit the next available frame. This stops the browser being dictated to by the event callbacks and allows it to decide when the best time is for it to make changes.</p><p>Switching to take advantage of animation timing is really simple, just store the values generated by each event in a buffer and move any slower calculations and DOM updates into a <code>requestAnimationFrame</code> callback:</p><figure class="Embed js-embed" role="widget"><button class="Embed-cover">Click to load demo</button></figure><p>This pattern avoids doing unnecessary or untimely work and allows the browser to optimise its workload for each frame. The technique does add a little complication by making DOM changes asynchronous, if related code relies on knowing the state of the DOM or when change are made then more code will be required to handle that. But, as the timeline below shows–it’s totally worth the extra effort:</p><figure><img class="u-imgCenter u-imgShadow" src="http://maketea.co.uk/images/2015-02-16-high-performance-touch-interactions/timeline-demo-5.png" alt="Web inspector timeline with 100ms highlighted" /><figcaption><p>The animation timing API can distributed work evenly between frames leading to less work and smoother performance.</p></figcaption></figure><ol><li>Translate elements on their own compositing layer when necessary</li><li>Ensure event callbacks are as lean as possible</li><li>Buffer calculations and changes to the DOM with <code>requestAnimationFrame</code></li></ol><p><a href="http://jsfiddle.net/i_like_robots/eo299L9v/5/" class="LinkCTA LinkCTA--jsfiddle">View the source on JSFiddle</a></p></div></div>
<script>var _gaq = _gaq || []; _gaq.push(['_setAccount', 'UA-34802167-1']); _gaq.push(['_setDomainName', 'liuzhe.co']); _gaq.push(['_trackPageview']); (function() { var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true; ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'; var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s); })();</script></body>
</html>