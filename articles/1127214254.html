
        <!doctype html>
        <html>
        <head>
            <meta charset="utf-8"/>
            <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
            <title>Battling BEM – 5 common problems and how to avoid them</title>
            <link rel="stylesheet" href="../css/article.css" />;
        </head>
        <body>
            <div class="m-content">
                <h1>Battling BEM – 5 common problems and how to avoid them</h1>
                <div class="section-inner layoutSingleColumn"><h3 name="2426" id="2426" class="graf--h3 graf-after--figure">Battling BEM – 5 common problems and how to avoid them</h3><p name="ee57" id="ee57" class="graf--p graf-after--h3">Whether you’ve just discovered BEM or are an old hand (in Web terms anyway!) and have been using it for the past few years, you can probably already appreciate what a useful methodology it is.</p><p name="a77f" id="a77f" class="graf--p graf-after--p">If you don’t know what BEM is I suggest you <a href="https://en.bem.info/" data-href="https://en.bem.info/" class="markup--anchor markup--p-anchor" rel="nofollow">read about it here</a> before continuing with the post.</p><p name="5fc0" id="5fc0" class="graf--p graf-after--p">Now, I’m under no illusion that this is a beautiful way of naming things. It’s absolutely not. One of things that put me off adopting it for such a long time was how eye-gougingly ugly the syntax is. The designer in me didn’t want my sexy markup cluttered with dirty double underscores and foul double hyphens.</p><p name="3cde" id="3cde" class="graf--p graf-after--p">The developer in me looked at it pragmatically and eventually the logical, modular way of building UI outweighed the right-side of my brain complaining “but it’s not pretty enough”.</p><p name="1668" id="1668" class="graf--p graf-after--p">I certainly don’t recommend picking living room centre-piece this way, but when you need a life jacket (as you do in a sea of CSS) I’d take function over form any day.</p><p name="416a" id="416a" class="graf--p graf-after--p">Anyway – onto the dilemmas:</p><h4 name="4b12" id="4b12" class="graf--h4 graf-after--p">1. Grandchildren selectors</h4><p name="8921" id="8921" class="graf--p graf-after--h4">These bad boys are the bane of my life — and I’m sure their misuse is one of the reasons people have an immediate aversion to BEM. I’ll give you an example:</p><figure name="d327" id="d327" class="graf--figure graf--iframe graf-after--p"><figcaption class="imageCaption">How not to use BEM grandchild selectors</figcaption></figure><p name="9e87" id="9e87" class="graf--p graf-after--figure">As you can imagine, this can quickly get out of hand and the more nested your component is, the more hideous and unreadable the classnames become. I’ve used short words like card, body, text and link but you can imagine how out of control it becomes when your block element is called something like drop-down-menu.</p><p name="f8a7" id="f8a7" class="graf--p graf-after--p">My belief is the double underscore pattern should only appear once in a selector name. You should never end up with anything like: parent__child__grandchild__greatgrandchild. If you’re getting to great great great grandchild levels you might want to revisit your component structure anyway.</p><p name="317d" id="317d" class="graf--p graf-after--p">BEM naming isn’t strictly tied to the DOM so it doesn’t matter how many nested levels deep a descendent element is. The naming convention is there to help you identify relationships with the top level component block — in this case, card.</p><p name="afd3" id="afd3" class="graf--p graf-after--p">This is how I would treat the same card component:</p><figure name="c852" id="c852" class="graf--figure graf--iframe graf-after--p"><figcaption class="imageCaption">The right way to deal with nesting in BEM</figcaption></figure><p name="3793" id="3793" class="graf--p graf-after--figure">This means all the descendent elements are only affected by the card block. So, we would be able to move the text and images into card__header or a new card__footer element without breaking anything.</p><h4 name="a79e" id="a79e" class="graf--h4 graf-after--p">2. Cross component… components</h4><p name="4dc5" id="4dc5" class="graf--p graf-after--h4">Another issue commonly faced is if a component’s styling or positioning is affected by it’s parent container. This specific problem is covered in a lot <a href="http://simurai.com/blog/2015/05/11/nesting-components/" data-href="http://simurai.com/blog/2015/05/11/nesting-components/" class="markup--anchor markup--p-anchor" rel="nofollow">more detail here</a> and <a href="https://en.bem.info/forum/4/" data-href="https://en.bem.info/forum/4/" class="markup--anchor markup--p-anchor" rel="nofollow">here</a>. I’m just going to fill you in on my preferred approach.</p><p name="6bf6" id="6bf6" class="graf--p graf-after--p">To summarise, let’s assume we want to add a button into the card body of our previous example. Button is already it’s own component. It looks like this:</p><figure name="0177" id="0177" class="graf--figure graf--iframe graf-after--p"><figcaption class="imageCaption">BEM button example</figcaption></figure><p name="3e56" id="3e56" class="graf--p graf-after--figure">If there are no styling differences to the regular button component, then there is no problem, we just drop it in like so:</p><figure name="6da5" id="6da5" class="graf--figure graf--iframe graf-after--p"><figcaption class="imageCaption">BEM nested components</figcaption></figure><p name="8e52" id="8e52" class="graf--p graf-after--figure">However, what happens if there are a few subtle styling differences, e.g we want to make it a bit smaller, have rounded corners, and add a drop shadow but it’s specifically only when part of a card component? I find a cross component class to be the most robust solution i.e:</p><figure name="0698" id="0698" class="graf--figure graf--iframe graf-after--p"><figcaption class="imageCaption">Cross component BEM</figcaption></figure><p name="c87b" id="c87b" class="graf--p graf-after--figure">The unique styling attributes are applied to card__button which lives in the with the rest of the CSS for card. This means if you decide to remove the card component, the unique button styles are removed with it, without you having to remember to do so. It’s worth putting a comment in your CSS to indicate that it is a cross component style.</p><p name="c2c3" id="c2c3" class="graf--p graf-after--p">Of course, the other option is to go back to your designer and tell them the button should be consistent with the rest of the buttons on the site and avoid this issue altogether… but that’s one for another day&nbsp;;)</p><p name="b033" id="b033" class="graf--p graf-after--p">I would also apply the rule of 3 here. This means, if later on in development this same button styling crops up a further two times, then abstract it to it’s own modifier.</p><h4 name="de0c" id="de0c" class="graf--h4 graf-after--p">3. Modifiers or a new component?</h4><p name="ceee" id="ceee" class="graf--p graf-after--h4">One of the biggest problems is deciding where a component ends and a new one begins. In our card example, you might later create another component called panel with very similar styling attributes but a few noticeable differences.</p><p name="6717" id="6717" class="graf--p graf-after--p">But what determines whether there should be two components panel and card or whether you simply create a modifier for card that applies the unique styles.</p><p name="5d9c" id="5d9c" class="graf--p graf-after--p">It’s very easy to over modularise and make everything a component. I recommend starting with modifiers but if you’re finding your specific component CSS file is getting difficult to manage then it’s probably time to break a few of those modifiers out. A good indicator is when you find you’re having to reset all the “Block” CSS to be able to style your new modifier, this to me suggests new component time.</p><p name="7cf8" id="7cf8" class="graf--p graf-after--p">The best way if you work with other developers or designers is to ask them for an opinion. Grab them for a couple of minutes and discuss it. I know it’s a bit of a cop-out answer but on a large application its vital that you all understand what modules are available and agree on exactly what constitutes a component.</p><h4 name="f322" id="f322" class="graf--h4 graf-after--p">4. What should I name wrappers / containers?</h4><p name="a278" id="a278" class="graf--p graf-after--h4">Some components require a parent wrapper or container that dictates the layout of the children. In these cases I always try to abstract the layout away into a grid and the component is simply the contents of each grid cell. In our card example, if we wanted to layout a list of 4 cards, I would use the following markup:</p><figure name="5c73" id="5c73" class="graf--figure graf--iframe graf-after--p"><figcaption class="imageCaption">BEM grids for layout</figcaption></figure><p name="65fc" id="65fc" class="graf--p graf-after--figure">Don’t be afraid to use a little extra markup to save yourself a massive headache. No-one is going to pat you on the back for shaving off a couple of &lt;div&gt; tags!</p><p name="9c2a" id="9c2a" class="graf--p graf-after--p">In some instances this isn’t possible, for example your grid isn’t going to give you the result you want or you simply want something semantic to name the parent element. In this case I tend to opt for the word container or list depending on the scenario. Sticking with our cards example, I might use &lt;div class=“cards-container”&gt;[…]&lt;/div&gt; or &lt;ul class=“cards-list”&gt;[...]&lt;/ul&gt; depending on the specific use case. The key is to be consistent with your naming convention.</p><h4 name="628e" id="628e" class="graf--h4 graf-after--p">5. How to handle states?</h4><p name="de05" id="de05" class="graf--p graf-after--h4">This is a common problem, particularly when styling a component in an active or open state. Let’s say for example our cards have an active state, so when they’re clicked on they get a nice border styling treatment to make them stand out. How do you go about naming that class?</p><p name="6b8e" id="6b8e" class="graf--p graf-after--p">The way I see it you have two options really, either a standalone state hook or BEM like naming as a modifier:</p><figure name="1d68" id="1d68" class="graf--figure graf--iframe graf-after--p"><figcaption class="imageCaption">State hook vs BEM naming</figcaption></figure><p name="01f6" id="01f6" class="graf--p graf-after--figure">Whilst I like the idea of keeping the BEM like naming for consistency, the advantage of the standalone class is that it makes it easy to use javascript to apply generic classes to any component. This proves to be more problematic when you have to apply specific state classes for each component. Possible, but it means writing a lot more JS.</p><p name="a3cc" id="a3cc" class="graf--p graf-after--p">It makes sense to stick to a standard set of state hooks, <a href="https://medium.com/u/5a285923fa03" data-href="https://medium.com/u/5a285923fa03" data-anchor-type="2" data-user-id="5a285923fa03" data-action="show-user-card" data-action-type="hover" class="markup--user markup--p-user">Chris Pearce</a> has <a href="https://github.com/chris-pearce/css-guidelines#state-hooks" data-href="https://github.com/chris-pearce/css-guidelines#state-hooks" class="markup--anchor markup--p-anchor" rel="nofollow">compiled a good list</a> so I recommend you just pinch those&nbsp;:)</p><h4 name="248b" id="248b" class="graf--h4 graf-after--p">Conclusion</h4><p name="149b" id="149b" class="graf--p graf-after--h4 graf--last">BEM has been an absolute life saver for me in terms of creating applications in a modular, component driven way. I’ve been using it for around 2 years now and these were the few stumbling blocks I’ve hit along the way. I hope you’ve found this article useful, and if you’ve not given BEM a go yet, I highly encourage you to do so.</p></div>
            </div>
            <script>var _gaq = _gaq || []; _gaq.push(['_setAccount', 'UA-34802167-1']); _gaq.push(['_setDomainName', 'liuzhe.co']); _gaq.push(['_trackPageview']); (function() { var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true; ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'; var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s); })();</script>
        </body>
        </html>