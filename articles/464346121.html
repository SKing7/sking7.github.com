<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>How the Browser Pre-loader Makes Pages Load Faster</title>
<link rel="stylesheet" href="../css/article.css" />
</head>
<body>
<div class="m-content">
<h1>How the Browser Pre-loader Makes Pages Load Faster</h1>
<div><p>The pre-loader (also known as the speculative or look-ahead pre-parser) may be the single biggest improvement ever made to browser performance.</p><p>During their implementation <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=364315#c38">Mozilla reported a 19% improvement in load times</a>, and in a test against the Alexa top 2,000 sites <a href="https://plus.google.com/+IlyaGrigorik/posts/8AwRUE7wqAE">Google found around a 20% improvement</a>.</p><p>It’s not a new browser feature but some seem to believe it’s Chrome only and yet others suggest it’s “the most destructive ‘performance enhancement’ there’s ever been”!</p><p>So what is the pre-loader and how does it improve performance?</p><!-- MORE --><p>Web pages are full of dependencies – a page can’t start rendering until the relevant CSS has downloaded, then when a script is encountered the HTML parser pauses until the script has executed (of course if the script is external it needs to be downloaded too).</p><p>Let’s consider how a browser might load a page:</p><ul>
<li><p>First the HTML is downloaded and the browser starts parsing it. It finds a reference to an external CSS resource and fires off a request to download it.</p></li>
<li><p>The browser can carry on parsing the HTML while the CSS is downloading but then it finds a script tag with an external URL, now (unless the script has <code>async</code> or <code>defer</code> attributes) it must wait until the script has downloaded and executed.</p></li>
<li><p>Once the script has downloaded and executed, the browser can continue parsing the HTML, when it finds non-blocking resources such as images it will request them and carry on parsing, but when it finds a script it must stop and wait for the script to be retrieved and executed.</p></li>
</ul><p>Although a browser is capable of making multiple requests in parallel, one that behaved like this often wouldn’t be downloading any resources in parallel with a script.</p><p>This is how browsers used to behave and using <a href="http://stevesouders.com/cuzillion/">Curzillion</a> by <a href="http://twitter.com/souders">Steve Sounders</a> we can create a test page that demonstrates this in IE7.</p><p>The <a href="http://man.gl/1cPmbyI">test page</a> has two stylesheets followed by two scripts in the head, then in the body it has two images, a script and finally another image.</p><p>The waterfall makes it easy to see parallel downloads stop while a script is being downloaded.</p><p><img src="/blog/images/no-pre-loader-waterfall-ie7.png" title="'Pre-loader priority issue in IE9'" /> <br />Waterfall of Cuzillion generated <a href="http://man.gl/1cPmbyI">test page</a> in IE7</p><p>If browsers still worked like this then pages would be slower to load as every time a script was encountered the browser would need to wait for the script to be downloaded and executed before it could discover more resources.</p><p>Internet Explorer, WebKit and Mozilla all implemented pre-loaders in 2008 as a way of overcoming the low network utilisation while waiting for scripts to download and execute.</p><p>When the browser is blocked on a script, a second lightweight parser scans the rest of the markup looking for other resources e.g. stylesheets, scripts, images etc., that also need to be retrieved.</p><p>The pre-loader then starts retrieving these resources in the background with the aim that by the time the main HTML parser reaches them they may have already been downloaded and so reduce blocking later in the page.</p><p> (Of course if the resource is already in the cache then the browser won’t need download it)</p><p>Repeating the previous test with IE8 shows other resources are now downloaded in parallel with scripts, delivering a huge performance improvement for this test case: 7s vs 14s.</p><p><img src="/blog/images/pre-loader-waterfall-ie8.png" title="'Pre-loader priority issue in IE8'" /> <br />Waterfall of Cuzillion generated <a href="http://man.gl/1cPmbyI">test page</a> in IE8</p><p>Pre-loader behaviour varies between browsers and is still an area of experimentation, some browsers seem to have naive implementations where they download the resources in order of discovery but other browsers prioritise the downloads, for example Safari gives stylesheets that don’t apply to the current viewport a low priority, Chrome schedules scripts (even those at the foot of a page) with a higher priority than most of the images on the page.</p><p>The prioritisation mechanisms aren’t well documented (you can read the source for some browsers!) but if you want to get a better understanding of what they can do, James Simonsen wrote some excellent <a href="https://docs.google.com/document/d/1JQZXrONw1RrjrdD_Z9jq1ZKsHguh8UVGHY_MZgE63II/preview?hl=en-GB&amp;forcehl=1">notes about the approaches they’re trying in Chrome</a>.</p><p>Pre-loaders extract URLs from markup and don’t / cannot execute javascript so any URLs inserted using javascript aren’t visible to it and the download of these resources will be delayed until the HTML parser discovers and executes the javascript that loads them.</p><p>There are cases where inserting resources using javascript can also trip up some pre-loaders.</p><p>I came across an answer on Stack Overflow suggesting javascript should be used to insert a link to either a mobile or desktop stylesheet depending on browser width:</p><figure><figcaption><span></span></figcaption><div><table><tr><td><pre><span>1</span>
<span>2</span>
<span>3</span>
<span>4</span>
<span>5</span>
<span>6</span>
<span>7</span>
<span>8</span>
<span>9</span>
<span>10</span>
<span>11</span>
<span>12</span>
<span>13</span>
<span>14</span>
<span>15</span>
<span>16</span>
</pre></td><td><pre><code><span><span>&lt;html&gt;</span>
</span><span><span>&lt;head&gt;</span>
</span><span>  <span>&lt;script&gt;</span>
</span><span>      <span>var</span> <span>file</span> <span>=</span> <span>window</span><span>.</span><span>innerWidth</span> <span>&lt;</span> <span>1000</span> <span>?</span> <span>"mobile.css"</span> <span>:</span> <span>"desktop.css"</span><span>;</span>
</span><span>      <span>document</span><span>.</span><span>write</span><span>(</span><span>'&lt;link rel="stylesheet" type="text/css" href="css/'</span> <span>+</span> <span>file</span> <span>+</span> <span>'"/&gt;'</span><span>);</span>
</span><span>  <span>&lt;/script&gt;</span>
</span><span><span>&lt;/head&gt;</span>
</span><span><span>&lt;body&gt;</span>
</span><span><span>&lt;img</span> <span>src=</span><span>"img/gallery-img1.jpg"</span> <span>/&gt;</span>
</span><span><span>&lt;img</span> <span>src=</span><span>"img/gallery-img2.jpg"</span> <span>/&gt;</span>
</span><span><span>&lt;img</span> <span>src=</span><span>"img/gallery-img3.jpg"</span> <span>/&gt;</span>
</span><span><span>&lt;img</span> <span>src=</span><span>"img/gallery-img4.jpg"</span> <span>/&gt;</span>
</span><span><span>&lt;img</span> <span>src=</span><span>"img/gallery-img5.jpg"</span> <span>/&gt;</span>
</span><span><span>&lt;img</span> <span>src=</span><span>"img/gallery-img6.jpg"</span> <span>/&gt;</span>
</span><span><span>&lt;/body&gt;</span>
</span><span><span>&lt;/html&gt;</span>
</span></code></pre></td></tr></table></div></figure><p>There are several reasons why I wouldn’t use this approach but even this simple example is enough to trip up IE9’s pre-loader – notice how the images grab all the connections and the CSS is delayed until one of the images completes and a connection becomes available.</p><p><img src="/blog/images/pre-loader-issue-ie9.png" title="'Pre-loader priority issue in IE9'" /> <br />Test page loaded in IE9</p><p>Some of the responsive image approaches use a fallback image and the pre-loader will often initiate the fallback image download before the javascript to select the appropriate image has executed leading to extra downloads.</p><p>Currently there are limited ways we can influence the pre-loader’s priorities (hiding resources using javascript is one), but the <a href="https://dvcs.w3.org/hg/webperf/raw-file/tip/specs/ResourcePriorities/Overview.html">W3C Resource Priorities</a> spec proposes two attributes to help signal our intent.</p><p> <code>lazyload</code> : resource should not be downloaded until other resources that aren’t marked lazyload have started downloading</p><p> <code>postpone</code> : resource must not be downloaded until it’s visible to the user i.e. within the viewport and display is not none.</p><p>Although I’m not sure how easy it is to polyfill, perhaps postpone might enable a simple way of implementing responsive images?</p><p>Pre-fetching is a way of hinting to the browser about resources that are definitely going to or might be used in the future, some hints apply to the current page, others to possible future pages.</p><p>At the simplest level we can tell the browser to resolve the DNS for another hostname that we will access later on the page:</p><figure><figcaption><span></span></figcaption><div><table><tr><td><pre><span>1</span>
</pre></td><td><pre><code><span><span>&lt;link</span> <span>rel=</span><span>"dns-prefetch"</span> <span>href=</span><span>"other.hostname.com"</span><span>&gt;</span>
</span></code></pre></td></tr></table></div></figure><p>Chrome also allows us to hint that we’re going to use another resource later in the current page and so it should be downloaded as a high priority:</p><figure><figcaption><span></span></figcaption><div><table><tr><td><pre><span>1</span>
</pre></td><td><pre><code><span><span>&lt;link</span> <span>rel=</span><span>"subresource"</span>  <span>href=</span><span>"/some_other_resource.js"</span><span>&gt;</span>
</span></code></pre></td></tr></table></div></figure><p>(Chromium’s source code suggests it’s actually downloaded as a lower priority than stylesheets/scripts and fonts but at an equal or higher priority than images)</p><p>There are two more link types that allow us to speculatively hint about what comes next and will be downloaded at a lower priority than the resources on the current page.</p><p>Prefetch an individual resource that might be on the next page:</p><figure><figcaption><span></span></figcaption><div><table><tr><td><pre><span>1</span>
</pre></td><td><pre><code><span><span>&lt;link</span> <span>rel=</span><span>"prefetch"</span>  <span>href=</span><span>"/some_other_resource.jpeg"</span><span>&gt;</span>
</span></code></pre></td></tr></table></div></figure><p>Prefetch and render a whole page in a background tab:</p><figure><figcaption><span></span></figcaption><div><table><tr><td><pre><span>1</span>
</pre></td><td><pre><code><span><span>&lt;link</span> <span>rel=</span><span>"prerender"</span>  <span>href=</span><span>"//domain.com/next_page.html"</span><span>&gt;</span>
</span></code></pre></td></tr></table></div></figure><p>Ilya Grigorik’s <a href="https://docs.google.com/presentation/d/18zlAdKAxnc51y_kj-6sWLmnjl6TLnaru_WH0LJTjP-o/present">Preconnect, prefetch, prerender… talk</a> from WebPerfDays New York is a good place to start if you want to learn more about pre-fetching.</p><p>The pre-loader isn’t new, it delivers a significant performance boost and as authors we don’t need to do anything special to take advantage of it.</p><p>It’s widely implemented - I tested the following browsers to confirm they had a pre-loader:</p><ul>
<li>IE8 / 9 / 10</li>
<li>Firefox</li>
<li>Chrome (inc Android)</li>
<li>Safari (inc iOS)</li>
<li>Android 2.3</li>
</ul><p>Bruce Lawson also confirmed Opera Mini uses the Presto engine which has a pre-loader.</p><p>Resource Priorities (and perhaps <code>&lt;link rel=subresource...</code>) will give us some ways to indicate our priorities to it.</p><p>If you spot any typos, or have and questions add them in the comments and I’ll do my best to fix and answer.</p><p>If you’re interested in digging further here’s some presentations, posts, bug reports etc. I read while writing this:</p><p><a href="http://gent.ilcore.com/2011/01/webkit-preloadscanner.html">The WebKit PreloadScanner</a></p><p><a href="http://gent.ilcore.com/2011/05/how-web-page-loads.html">How a web page loads</a></p><p><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=364315">Speculatively load referenced files while “real” parsing is blocked on a &lt;script src=&gt; load</a></p><p><a href="https://bugs.webkit.org/show_bug.cgi?id=17480">Implement speculative preloading</a></p><p><a href="http://blogs.msdn.com/b/ieinternals/archive/2011/07/18/optimal-html-head-ordering-to-avoid-parser-restarts-redownloads-and-improve-performance.aspx">Best Practice: Get your HEAD in order</a></p><p><a href="http://blogs.msdn.com/b/ieinternals/archive/2009/07/27/bugs-in-the-ie8-lookahead-downloader.aspx">Bugs in IE8’s Lookahead Downloader</a></p><p><a href="https://dvcs.w3.org/hg/webperf/raw-file/tip/specs/ResourcePriorities/Overview.html">W3C Resource Priorities</a></p><p><a href="https://docs.google.com/document/d/1JQZXrONw1RrjrdD_Z9jq1ZKsHguh8UVGHY_MZgE63II/preview?hl=en-GB&amp;forcehl=1#heading=h.5tq224qeoth4">Chrome PLT Improvements Q1 2013</a></p><p><a href="https://docs.google.com/spreadsheet/ccc?key=0As3TLupYw2RedG50WW9hNldQaERDTlFHMEc2S2FBTXc#gid=4">Chrome Pre-Loader Test</a></p><p><a href="https://docs.google.com/presentation/d/18zlAdKAxnc51y_kj-6sWLmnjl6TLnaru_WH0LJTjP-o/present#slide=id.p19">Preconnect, prefetch, prerender</a></p></div></div>
<script>var _gaq = _gaq || []; _gaq.push(['_setAccount', 'UA-34802167-1']); _gaq.push(['_setDomainName', 'liuzhe.co']); _gaq.push(['_trackPageview']); (function() { var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true; ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'; var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s); })();</script></body>
</html>