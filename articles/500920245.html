<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>7 lines JavaScript library for calling asynchronous functions</title>
<link rel="stylesheet" href="../css/article.css" />
</head>
<body>
<div class="m-content">
<h1>7 lines JavaScript library for calling asynchronous functions</h1>
<div>
                
                <p>I was surprised by the good feedback for <a href="http://krasimirtsonev.com/blog/article/Javascript-template-engine-in-just-20-line">JavaScript template engine in just 20 lines</a> and decided to blog for another small utility function which I'm using often. While we are talking about JavaScript in the browser, most of the operations are asynchronous. We are dealing with callbacks all the time and sometimes we end up with awesome callback hell.</p><p>Let's say that we have two  functions and we want to call them one after each other. They both operate with same variable. The first one sets its value and the second one uses it.</p><pre>var value;var A = function() {    setTimeout(function() {        value = 10;    }, 200);}var B = function() {    console.log(value);}</pre><p>So, if we now run <em>A();B();</em> we will get <em>undefined</em> in the console. It's like that because the <em>A</em> function sets the value asynchronously. What we could do is to send a callback and execute it once the job is done.</p><pre>var value;var A = function(callback) {  setTimeout(function() {    value = 10;    callback();  }, 200);};var B = function() {  console.log(value);};A(function() {  B();});</pre><p>This works, but imagine what will happen if we need to run five or more methods. Passing callbacks all the time will lead to messy and unpleasant code. </p><p>The idea is to write a helper function which accept our workers and handle the whole process. Let's start with the simplest thing:</p><pre>var queue = function(funcs) {    // magic here}</pre><p>So, what we have to do is to run that function by passing the both <em>A</em> and <em>B</em> - <em>queue([A, B])</em>. We need to get the first function and execute it.</p><pre>var queue = function(funcs) {    var f = funcs.shift();    f();}</pre><p>If you run this code you will see an error <em>TypeError: undefined is not a function</em>. That's because <em>A</em> function doesn't accept callback but it tries to run it. Let's pass one.</p><pre>var queue = function(funcs) {    var next = function() {        // ...    };    var f = funcs.shift();    f(next);};</pre><p>The <em>next</em> method is getting called once <em>A</em> finishes its job. That's the perfect place for continuing to the next function in the list. We could arrange the code a bit and we are able to go through the whole array. </p><pre>var queue = function(funcs) {    var next = function() {        var f = funcs.shift();        f(next);    };    next();};</pre><p>If we leave the things like that we will reach our goal. I.e. function <em>A</em> is called and just after that <em>B</em>, which prints the correct value of the variable. The key moment here is the usage of <em>shift</em> method. It removes the first element of the array and returns the element. Step by step <em>funcs</em> array becomes empty. So, this could lead to an error. To prove this theory, let's assume that we still need to run the both functions, but we don't know their order. In this case, they both should accept callback and execute it.</p><pre>var A = function(callback) {    setTimeout(function() {        value = 10;        callback();    }, 200);};var B = function(callback) {    console.log(value);    callback();};</pre><p>And of course we got <em>TypeError: undefined is not a function</em>. To prevent this we should check if the <em>funcs</em> array is empty.</p><pre>var queue = function(funcs) {    (function next() {        if(funcs.length &gt; 0) {            var f = funcs.shift();            f(next);        }    })();};</pre><p>What I did also is to invoke the <em>next</em> function just after its definition. It saves few bytes.</p><p>Let's try to cover as many cases as possible. What about the current scope of the executed functions. The <em>this</em> keyword inside the functions probably points the global <em>window</em> object. It will be cool if we set our own scope.</p><pre>var queue = function(funcs, scope) {    (function next() {          if(funcs.length &gt; 0) {              var f = funcs.shift();              f.apply(scope, [next]);          }    })();};</pre><p>We added one more parameter to the tiny library. Later instead of <em>f(next)</em> we use the <em>apply</em> function, set the scope and pass <em>next</em> as a parameter. Pretty much the same thing. </p><p>And the last feature which we need is the ability pass arguments between the functions. Of course we don't have an idea how many parameters will be send. That's why we need to use the <em>arguments</em> variable. As you probably know, that variable is available in every JavaScript function and represents the coming parameters. It's something like an array, but not exactly. And because in <em>apply</em> method we need to use real array, a little trick is used.</p><pre>var queue = function(funcs, scope) {    (function next() {          if(funcs.length &gt; 0) {              var f = funcs.shift();              f.apply(scope, [next].concat(Array.prototype.slice.call(arguments, 0)));          }    })();};</pre><p>And here is the full example which demonstrates all the features of the library.</p><pre>var obj = {    value: null};queue([    function(callback) {        var self = this;        setTimeout(function() {            self.value = 10;            callback(20);        }, 200);    },    function(callback, add) {        console.log(this.value + add);        callback();    },    function() {        console.log(obj.value);    }], obj);</pre><p>If you run this code you will see:</p><pre>3010</pre><p>And to match the lines mentioned in the title of this article we could write the main code in only one line:</p><pre>var queue = function(funcs, scope) {    (function next() {          if(funcs.length &gt; 0) {              funcs.shift().apply(scope || {}, [next].concat(Array.prototype.slice.call(arguments, 0)));          }    })();};</pre><p>Here is a JSBin to play with:</p><p><a href="http://jsbin.com/AhirAlOV/5/embed?js,console">JS Bin</a></p>
                
                </div></div>
<script>var _gaq = _gaq || []; _gaq.push(['_setAccount', 'UA-34802167-1']); _gaq.push(['_setDomainName', 'liuzhe.co']); _gaq.push(['_trackPageview']); (function() { var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true; ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'; var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s); })();</script></body>
</html>