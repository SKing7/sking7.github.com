<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Five Patterns to Help You Tame Asynchronous JavaScript</title>
<link rel="stylesheet" href="../css/article.css" />
</head>
<body>
<div class="m-content">
<h1>Five Patterns to Help You Tame Asynchronous JavaScript</h1>
<div itemprop="articleBody"><img src="//tpstatic.com/img/usermedia/zSvgVinS40ykaVRODOoqzg/cropped-w220-h220.png" itemprop="image" /><!-- ko stopBinding: true --><p>You can hardly write ten lines of JavaScript before you're confronted with asynchronous behavior. In this post we're going to look at 5 patterns that can help you tame the beast - or at least keep it at bay. It would be nearly impossible to cover each pattern in depth in this post alone, but my aim is to provide enough information to get you started, with an additional reading section at the end.</p><p>Let me emphasize here that none of these patterns are <em>only</em> asynchronous. In fact, all of them work well in synchronous contexts also. </p><p>Your JavaScript code is executed in an event loop, on a single thread. The reality is that <em>all</em> JavaScript executes synchronously - it's the event loop that allows you to queue up an action that won't take place until the loop is available some time <em>after</em> the code that queued the action has finished executing. So code is said to execute asynchronoulsy when it is queued to run sometime after the event loop is available. Or, as Trevor Burnham said in his book <a href="http://pragprog.com/book/tbajs/async-javascript">Async JavaScript</a>:</p><blockquote>
  <p>"Events can be queued while code is running, but they can't fire until the runtime is free."</p>
</blockquote><p>Enough talk, code is proof:</p><pre><code>function maybe() {
    console.log("…execute async, maybe?");
}

function proveIt() {
    setTimeout(maybe, 0);
    console.log("Hey, you just invoked me, and this is crazy…");
    console.log("But I'll queue you up");
    return "and you'll…";
}

proveIt();
</code></pre><p>Running this in Chrome's JavaScript console will give you the following:</p><p><img src="http://tpstatic.com/img/usermedia/K9z3UePCckizCYzBPYKxJg/original.png" alt="Async Proof" /></p><p>We used <code>setTimeout</code> in the above example to queue up the <code>maybe</code> function to execute 0 milliseconds after the event loop is available. The event loop won't be available until it completes its current execution stack - in this case, the rest of the <code>proveIt</code> function which includes two <code>console.log</code> statements &amp; the return. As soon as the <code>proveIt</code> function returns, the runtime is free, and the queued up <code>maybe</code> function can execute. You can actually see where <code>proveIt</code> returns in the above output: where you see the string "and you'll…" printed on the console. You can tell from the console output that at this point, <code>proveIt</code> has completed, and our queued <code>maybe</code> function's output appears after that.</p><blockquote>
  <p>Just in case <code>setTimeout</code> is new to you (or you are new to JavaScript), two async 'primitives' exist across all major runtimes:</p>
  
  <ul>
  <li><code>setTimeout(fn, x)</code> (which queues a function <code>f</code> to be invoked after <code>x</code> milliseconds, though the actual delay could be longer)</li>
  <li><code>setInterval(fn, x)</code> (which allows repeated invocations of function <code>fn</code> with a delay of <code>x</code> between each - though the delay could be longer).</li>
  </ul>
  
  <p>For more information, check out the MDN articles on <a href="https://developer.mozilla.org/en-US/docs/Web/API/window.setTimeout">setTimeout</a> and <a href="https://developer.mozilla.org/en-US/docs/Web/API/window.setInterval">setInterval</a>. Some environments provide additional async primitives: node.js has <a href="http://nodejs.org/api/process.html#process_process_nexttick_callback"><code>process.nextTick</code></a> and many browsers support <a href="https://developer.mozilla.org/en-US/docs/Web/API/window.requestAnimationFrame"><code>requestAnimationFrame</code></a> - which also provides a means to queue a callback to be invoked before a repaint.</p>
</blockquote><p>Even our contrived example above shows you that the JavaScript code you write will need to handle the reality of asynchronicity. Whether it's waiting for an AJAX response, a button click, a mouseover or any number of other possibilities, there's no escape. No need to worry - we have the tools to meet the challenge. The first one we'll cover is the foundation upon which all the others stand.</p><p>Callbacks are the currency…the fundamental building block…the <em>lynchpin</em> of asynchronicity in JavaScript. No matter where you go from here, the higher-level abstractions are just intelligent wrappers (for good reason, btw) around plain, vanilla callbacks. If you're new to JavaScript – and depending on what language you hail from –&nbsp;seeing functions passed as arguments might be a bit unfamiliar, but don't fret, it's easy and fun:</p><pre><code>// plain, non-jQuery version of hooking up an event handler
var clickity = document.getElementById("clickity");
clickity.addEventListener("click", function (e) {
    //console log, since it's like ALL real world scenarios, amirite?
    console.log("Alas, someone is pressing my buttons…");
});

// the obligatory jQuery version
$("#clickity").on("click", function (e) {
    console.log("Alas, someone is pressing my buttons…");
});
</code></pre><p>Even if you're new to JavaScript, if you've spent <em>any</em> amount of time in the web, you've probably written something similar to the above code. Both <code>addEventListener</code> and <code>on</code> take a callback argument - the second argument being passed. This function will be invoked when the <code>click</code> event occurs. At the moment, we're just taking advantage of the fact our DOM element (presumably a button) has the underlying functionality to store the callback we pass to it and invoke it later when the event occurs (btw - this is an implementation of the <a href="http://en.wikipedia.org/wiki/Observer_pattern">Observer Pattern</a>, more on that later when we talk about Events). However, it's very easy to write your own objects to be capable of invoking callbacks:</p><pre><code>var worker = {
    updateCustomer: function (customerInfo, cb) {
        $.ajax({
            url: "/some/api",
            type: "POST",
            data: customerInfo
        }).done(function (data) {
            // let's pretend there's some DOM to update…
            $("#update-status").removeClass("editing").addClass("saved");
            cb(null, data);
        }).fail(function (data) {
            // let's pretend there's some DOM to update…
            $("#update-status").removeClass("editing").addClass("failed");
            cb(data);
        });
    }
    // other methods, properties, etc
};

// and somewhere else, the calling code:
// (assuming we already have a currentCustomer instance, etc)
worker.updateCustomer(currentCustomer, function (err, data) {
    alert(err || data); // *sigh*, who really uses alerts these days?!
});
</code></pre><blockquote>
  <p>There are some problems with the above <code>worker</code> instance (it's tightly coupling AJAX &amp; DOM updates, for one), but we'll overlook those <em>for now</em>.</p>
</blockquote><p>Since functions in JavaScript are <a href="http://en.wikipedia.org/wiki/First-class_function">first class citizens</a>, we are able to pass them as arguments to other functions. In our example above, the <code>updateCustomer</code> method takes two arguments, the second of which – <code>cb</code> – is a callback function that is to be invoked once <code>updateCustomer</code> has completed executing. This is the essence of passing callbacks, and writing methods that take callback arguments - it doesn't get much lower-level than this. This is often referred to as "<a href="http://en.wikipedia.org/wiki/Continuation-passing_style">continuation passing style</a>" (CPS). The callback is the "continuation", and the invoked function passes control to it as it invokes it, passing in the result(s).</p><p>I should mention that you will often run into situations where you want to specify the "context" of your callback function (i.e. - what <code>this</code> will be inside the function when invoked by the method to which you are passing it). You will need to bind your function (in most cases) prior to passing it as an argument. For example:</p><pre><code>// assuming we have a notifier instance, with a "showAlert" method on it...

// ES5 bind function (or using a shim)
worker.updateCustomer(currentCustomer, function(err, data) {
    this.showAlert(err || data);
}.bind(notifier));

// using underscore/lodash
worker.updateCustomer(currentCustomer, _.bind(function(err, data) {
    this.showAlert(err || data);
}, notifier));


// using jquery
worker.updateCustomer(currentCustomer, $.proxy(function(err, data) {
    this.showAlert(err || data);
}, notifier));
</code></pre><p>In the examples above, we've bound the "this" context of our callback to be the <code>notifier</code> instance, so that <code>this.showAlert</code> inside our callback function will be the same as if the worker had access to call <code>notifier.showAlert</code>. But why is this useful?</p><p>The method we pass our callback into may belong to an instance that has no knowledge of (nor even a reference to) the object calling it - this is a good thing! It's called separation of concerns &amp; encapsulation. However, if we're passing a callback that's actually a <em>method</em> on the calling object, we have to bind the context, or we're going to have a bad experience. Let's check a slightly modified example:</p><pre><code>var updateForm = {
    submit: function() {
        // get the data and store it in currentCustomer
        worker.updateCustomer(currentCustomer, this.showAlert.bind(this));
    },
    showAlert: function(err, data) {
        // I don't care how, just show an alert :-)
    }
};
</code></pre><p>We could spend an entire post on binding and context alone, but we'll stop there. If you're interested in reading more, I recommend checking out "<a href="http://freshbrewedcode.com/jimcowart/2013/02/12/getting-into-context-binds/">Getting Into Context Binds</a>".</p><h2 id="callback_conclusion">Callback Conclusion</h2><h3 id="pros">Pros</h3><ul>
<li><strong>Simplicity</strong> - Callbacks are simple! (The caveat being that you are responsible for maintaining the correct context, if needed.) You pass a function, it gets invoked at some point in the future.</li>
<li><strong>Lightweight</strong> - No extra libs required. Functions-as-first-class-citizens is built into the language. No need for additional code to make it work.</li>
</ul><h3 id="cons">Cons</h3><ul>
<li><strong>Can Be An Insufficient Abstraction</strong> - Sometimes you need additional 'sugar'. This is where patterns 2-5 will come into play, each build upon the foundation of callbacks in different ways.</li>
<li><strong>Complex When Nested</strong> - Callbacks are difficult to read, debug and maintain when deeply nested. The goto-example these days to describe this problem is "the pyramid of doom". </li>
</ul><p>Let's take a look:</p><pre><code>var allTheCustomerThings;
$("#getCustomer").click(function (cust) {
    var id = $("#cust-id").val();
    getCustomer(id, function (cust) {
        allTheCustomerThings = cust;
        getContacts(id, function (contacts) {
            allTheCustomerThings.contacts = contacts;
            getOrders(id, function (orders) {
                allTheCustomerThings.orders = orders;
                getAccountsRecv(id, function (ar) {
                    allTheCustomerThings.ar = ar;
                    // OK - we got all the data, NOW WHAT?! :-)
                });
            });
        });
    });
});
</code></pre><p>The deeper the nesting, the more you see the pyramid. This is both a <em>real problem</em> and a <em>straw man</em>. It's real problem in that I've seen it happen - but primarily by developers new to JavaScript and/or developers not spending the time to properly plan and architect their application. It's a straw man in that it's often blindly cited as <em>the knee-jerk reason</em> to use promises, without proper attention being paid to good design, even <em>if</em> promises are used to mitigate the nesting. (There are legitimate and compelling reasons to use promises, of course! But I can just as easily slap promises on a terribly written code base only to eliminate nesting.) Low level patterns don't fix higher level design problems - so be sure to think through how you are modeling a problem in code if you end up with deep callback nesting, and consider it both a code <em>and</em> design smell that should prompt you to address the systemic issue(s) with the overall design and not just the nesting strategy.</p><p>One of the cons of plain callbacks – that it can be an insufficient abstraction" – is the perfect segue to where events can be useful. What if we don't want to keep passing a callback each time we invoke the target method? What if we wanted our own callback to be invoked if <em>another piece of calling code</em> also invoked the target method? The <a href="http://en.wikipedia.org/wiki/Observer_pattern">Observer Pattern</a> fits well here.</p><p>The what?!</p><p>The Observer Pattern isn't hard at all. You have a <em>subject</em> that emits events (often referred to as an "event emitter"), and <em>observers</em>, which register callbacks with the <em>subject</em> to be notified as to when those events occur. In other words, let's assume <a href="http://dougneiner.com/">Doug Neiner</a> and I are playing Halo 4. <a href="http://freshbrewedcode.com/alexrobson/">Alex Robson</a> tells me that he'd like to know when Doug steals one of my kills. In this case, I am the subject and Alex is the observer. Unfortunately, Alex will want to <a href="http://davidwalsh.name/function-debounce">debounce</a> his callback, since he will receive <em>a lot</em> of event notifications.</p><p>There are a few key details to bear in mind with the Observer Pattern:</p><ul>
<li>Observers must have a direct reference to the subject.</li>
<li>Subjects are responsible for maintaining the internal state of subscriber callbacks</li>
<li>JavaScript implementations of this pattern usually involve subscriber callback method signatures of 0-n arguments (in other words, every event could have a different signature).</li>
</ul><p>Let's demonstrate the Observer pattern in code, describing our Halo 4 example (you can view this in a fiddle <a href="http://jsfiddle.net/ifandelse/gstrW/">here</a>):</p><pre><code>// This observer object can be mixed into any object, giving it the basic
// API necessary to add and remove subscribers as well as emit events
var observer = {
    // 'subscribers' will keep track of subscribers by event name
    // each event name subscribed to will be a member name on
    // this object, w/ the value as an array of objects containing
    // the subscriber callback and optional function context
    subscribers: {},

    // the 'on' method is used by subscribers to add a callback
    // to be invoked when a specific event is emitted
    on: function (event, cb, context) {
        this.subscribers[event] = this.subscribers[event] || [];
        this.subscribers[event].push({
            callback: cb,
            context: context
        });
    },

    // 'off' allows subscribers to remove their callbacks
    off: function (event, cb, context) {
        var idx, subs, sub;
        if ((subs = this.subscribers[event])) {
            idx = subs.length - 1;
            while (idx &gt;= 0) {
                sub = subs[event][idx];
                if (sub.callback === cb &amp;&amp; (!context || sub.context === context)) {
                    subs[event].splice(idx, 1);
                    break;
                }
                idx--;
            }
        }
    },

    // iterates over the subscriber list for 
    // a given event and invokes the callbacks
    emit: function (event) {
        var subs, idx = 0,
            args = Array.prototype.slice.call(arguments, 1);
        if ((subs = this.subscribers[event])) {
            while (idx &lt; subs.length) {
                sub = subs[idx];
                sub.callback.apply(sub.context || this, args);
                idx++;
            }
        }
    }
};
// We're using jQuery's extend function to copy the observer
// object's members over a new object, creating the "jim" instance
var jim = $.extend({
    dangItDoug: function (numberStolen) {
        this.emit("stolenkill", numberStolen);
    }
}, observer);

var alex = {
    tauntJim: function(numStolen, dt) {
        $('body').append("&lt;div&gt;Jim, your incompetence has cost you " + 
            numStolen + (numStolen &gt; 1 ? " kills" : " kill") + ".&lt;/div&gt;");
    }
};
// the "jim" instance is a subject, and we're subscribing to it, to 
// have alex.tauntJim invoked any time the 'stolenkill' event occurs
jim.on("stolenkill", alex.tauntJim);
var i = 0;
jim.dangItDoug(++i);
jim.dangItDoug(++i);
jim.dangItDoug(++i);
jim.dangItDoug(++i);
</code></pre><p>Many popular libaries already provide built-in event-emitting behavior – backbone.js &amp; jQuery, for example. There are several other stand-alone implementations worth checking out as well – here are a few:</p><h2 id="events_conclusion">Events Conclusion</h2><h3 id="pros">Pros</h3><ul>
<li><strong>Encourages Good De-coupling</strong> - Using the Observer pattern will help you tease apart behaviors in your application since it's forcing you to think through the interactions that can occur. This leads to well-encapsulated components, and typically results in a design more resistant to the traps of deeply nested callbacks.</li>
<li><strong>Lends Itself to Testability</strong> - Due to the bias towards de-coupling that comes with this approach, you end up with components that are testable in isolation and easy to mock in most cases.</li>
</ul><h3 id="cons">Cons</h3><ul>
<li><strong>Direct Reference Required</strong> - This is the Achilles' heel for event-emitters. If you have a subject that's <em>very</em> interesting to most of your application, you will end up passing a reference to it everywhere. This begins to undermine any 'loose coupling' gains you've racked up, creating a kind of tight coupling that can be harder to detect until you have to change the subject's API and break most of your app in the process.</li>
</ul><h2 id="elephant_meet_room">Elephant, Meet Room</h2><p>So, let's tackle what I've avoided until now:</p><ul>
<li>Many popular libraries (like jQuery) provide what looks like an "Observer pattern" implementation, when in fact they are acting as a mediator between observer and subject yet still presenting the API as if it were being called directly on the subject. This isn't a problem, of course! It's just good to know how things work.</li>
<li>Many of these implementations provide event-emitting behaviors, with the intent that the API is on the prototype, or mixed-in as instance members, etc. However, many developers take these event-emitting libraries and create a singleton instance and use this instance as a generalized "emitter", so subjects no longer have the on/off/etc. calls themselves. When this happens, we are, in my opinion, leaving the observer pattern behind and we've begun to wander into the territory of messaging.</li>
</ul><p>Well, it turns out that <a href="http://freshbrewedcode.com/jonathancreamer/">Jonathan Creamer</a> found out Alex is watching some friends play Halo 4 and he's curious to hear how things are going. Only problem is, he has no idea how to get to my house and, in fact, doesn't want to leave his own house. So he calls Alex and asks to be notified whenever we win or lose, when we start a game, and when we earn a medal. Alex is now acting as a mediator, or broker. Jonathan isn't subscribing directly to me or Doug (in fact, he may not have any idea who's playing), instead he's told Alex what he's interested in, and Alex will relay any relevant information back to Jonathan, whether it comes from me, Doug or someone else. This is the essence of "messaging" in JavaScript.</p><p>This is much like the Observer pattern, in that we have observers interested in events occuring - but we've introduced a third party to handle managing subscriptions and matching events (which we'll now refer to as messages) to the correct subscribers. There's some debate about the best pattern name to apply here, but here are some descriptions that can be legitimately argued:</p><ul>
<li><a href="http://en.wikipedia.org/wiki/Mediator_pattern">Mediator</a> - "Communication between objects is encapsulated within a mediator. Objects no longer communicate directly with each other, but instead communicate through the mediator."</li>
<li><a href="http://martinfowler.com/eaaDev/EventAggregator.html">Event Aggregator</a> - "Channel events from multiple objects into a single object to simplify registration for clients."</li>
<li><a href="http://www.enterpriseintegrationpatterns.com/MessageBroker.html">(Client-side) Message Broker</a> - "Receives messages from multiple destinations, determines the correct destination &amp; routes the message."</li>
</ul><h3 id="regardless_of_the_actual_pattern_used_people_still_call_it_pubsub._sigh.">Regardless of the actual pattern used, people still call it "PubSub". Sigh.</h3><p><img src="http://tpstatic.com/img/usermedia/koA2LFNktkOvqh06Rl4_mw/original.png" alt="3rd Party Facepalm" /></p><p>I personally lean towards "message broker", though I'm guilty of using all three pattern names to describe this approach. Regardless, it's important to realize that we aren't trying to re-create full blown server-side message brokers (i.e. - RabbitMQ or ZeroMQ). Instead, this approach accepts the weaknesses that can appear with the Observer pattern, especially in larger applications, and provides one common dependency (the message bus) for all subscribers and publishers to use, rather than requiring direct references to subjects be passed all over the application. Here are some common features of JavaScript message bus implementations:</p><ul>
<li>The message "payload" uses a structured envelope, rather than 0-n arguments passed into a callback. This envelope contains the data of the message as well as other metadata about the message (event name, channel name, timestamp, etc.). <em>Inlcuding behavior on a message is strongly discouraged. Ideally, the entire message envelope should be preserved if passed to <code>JSON.stringify</code>.</em></li>
<li>Subscriber callbacks have a consistent signature. Thanks to the above point, subscriber callbacks usually end up with a 1 or 2 argument method signature that's consistent for every message.</li>
<li>Where the Observer pattern might have "event" names, messages in JavaScript usually have "topics" that can often be hierarchical (or namespaced). This opens the door for wildcard bindings - we'll see that in a moment.</li>
<li>Some, not all, implementations allow topics to be segmented by 'channel' - a logical grouping of topics – for both performance and architectural reasons.</li>
</ul><h2 id="why_would_i_choose_this_over_events">Why Would I Choose This Over Events?</h2><p>You wouldn't. In fact, some of the most elegant scenarios I've seen used the Observer and Message Broker patterns in tandem. As you look at your application's JavaScript, you'll often see several distinct "bounded contexts" (to steal and liberally twist a phrase from <a href="http://gorodinski.com/blog/2012/04/03/bounded-contexts-as-a-strategic-pattern-beyond-ddd/">Mr. Evans</a>). Within these contexts (for example, a Backbone view and model), the Observer pattern fits very well, since the observers already have a direct reference to the subject. However, it's often the case that separate "contexts" (often in separate modules) within the application are interested in the same data. Instead of coupling those separate modules just to share the data, we can have both modules subscribe to a message bus. So - using messaging in tandem with events can help you de-couple components at a different level of abstraction as you move from finer grained instance-to-instance communication (events) up to module-to-module communication (messaging).</p><p>Another important benefit arises if you follow the general rule of "Don't publish behavior on a message" (in other words, your message data shouldn't have functions, only data). You now have the ability to easily extend the reach of your messages across iframes, Web Workers or even websocket connections. <a href="https://github.com/postaljs/postal.js">postal.js</a> – a library I've written – has a <a href="https://github.com/postaljs/postal.federation">federation</a> add-on that allows this kind of bridging. These approaches will become more important as larger numbers of web applications are taking advantage of background processing in Web Workers and iframes.</p><h2 id="less_talk_more_code">Less Talk, More Code</h2><p>This example is using <a href="https://github.com/postaljs/postal.js">postal.js</a> – a JavaScript message bus implemention I've created:</p><pre><code>var jonathan = (function() {
    // postal allows you to group topics by channel.
    // Here we get a channel for "xbox" related topics.
    // From it we can publish and subscribe.
    var xboxChannel = postal.channel("xbox");
    var reactions = {
        newgame: function(data, env) {
            return "I hope this goes better than the last one did!";
        },
        newmedal: function(data, env) {
            return "Nice, a new medal - about time!";
        },
        lostgame: function(data, env) {
            return "Ouch, you got pwned!";  
        },
        wongame: function(data, env) {
            return "Stroke of luck, perhaps?";
        }
    };
    var module = {
        handleMessage: function(data, env) {
            // if we have a reaction for this kind
            // of message we'll call makeComment.
            if(reactions[env.topic]) {
                this.makeComment(reactions[env.topic](data, env));    
            }
        },
        makeComment: function(msg) {
            $('body').append("&lt;div&gt;" + msg + "&lt;/div&gt;");
        }
    };

    // we are subscribing using the "#" wildcard
    // which would match ANY topic of any length
    // (postal follows the AMQP binding approach)
    // notice we're using a 'fluent' configuration 
    // method to provide the function context we
    // want to be present (the value of "this")
    // in our subscriber callback
    xboxChannel
        .subscribe("#", module.handleMessage)
        .withContext(module);

    return module;
}());

var chan = postal.channel("xbox");
// we're briding a socket.io connection to our message bus
var socket = io.connect(location.origin);
_.each(['newgame', 'newmedal', 'lostgame', 'wongame'], function(evnt){
    socket.on(evnt, function(data){
        chan.publish(evnt, data);
    });
});
</code></pre><p>The above example is just a <em>taste</em> of messaging. We have a websocket connection, over which we're subscribing to <code>newgame</code>, <code>newmedal</code>, <code>lostgame</code> and <code>wongame</code> events. As we handle those websocket events (which will happen asynchronously, btw), we publish the received data to our local message bus and any subscriber will receive the message without having to know anything about the websocket connection, nor any other subscriber to the same data. This kind of loose coupling lends itself to good testability, portability (across boundaries such as iframes and Web Workers) and composability. When messaging is the communications glue between your modules, the message is the contract. As long as you honor the contract – or even go a step further and version your message types – you can compose your app of any number of drop-in modules that subscribe to the topics they need and adhere to message contracts on what they publish.</p><h2 id="messaging_conclusion">Messaging Conclusion</h2><h3 id="pros">Pros</h3><ul>
<li><strong>Promotes clean separation of concerns</strong> - you don't have to build a large app. Instead, build several smaller ones and use messaging for communications between them.</li>
<li><strong>Very testable</strong> - it's super easy to fake a message or test for message output.</li>
<li><strong>Complements events nicely</strong> - Observer pattern 'events' work nicely for local concerns. Messaging complements this when those events need to be promoted to app-level messages.</li>
</ul><h3 id="cons">Cons</h3><ul>
<li><strong>Can be prone to "boilerplate proliferation"</strong> - you can mitigate this by writing app-specific helpers</li>
<li><strong>Can be confusing to devs who are new to the concept in general</strong> - take the proper time to explain and teach.</li>
</ul><p>Promises provide a very powerful way to express asynchronous code. Instead of "<a href="http://en.wikipedia.org/wiki/Continuation-passing_style">continuation passing style</a>" (which we see with plain callbacks), our target methods return a promise - an "eventual value". The <a href="http://wiki.commonjs.org/wiki/Promises/A">Promises/A spec</a> defines a promise as "an object that has a function as the value for the property then". The <code>then</code> property on a promise is a method that takes a success and (optional) error callback argument, and returns a new promise. Under the hood, a promise can be in 1 of 3 states: unfulfilled, fulfilled or failed. Once it has been fulfilled (resolved) or failed (rejected), the state should NOT change again. Success callbacks are invoked when the promise is fulfilled, error callbacks when it fails. If the success handler(s) are added after the promise has already been fulfilled, they will be queued on the event loop and invoked as soon as the runtime is free** (same goes for error – if the promise failed – and 'finally' callbacks). </p><p><em>**UPDATE: The original version of this post stated that queued callbacks on resolved promises were invoked immediately - this is not correct. Each major implementation I've checked effectively uses a setTimeout of 0ms (or an equivalent). Thanks to Calvin Metcalf for pointing this out.</em></p><p>You get an idea of the power a promise provides when you see it in action. Consider this nested-callback-laden login viewmodel:</p><pre><code>// fictional viewmodel for a mobile login screen
// the ugly nested callback version
var loginViewModel = (function () {
  var login = function () {
    var username = $('#loginUsername').val();
    var password = $('#loginPassword').val();
    el.Users.login(
      username,
      password,
      function () {
        usersModel.load(
          function () {
            mobileApp.navigate(
              'views/notesView.html',
              function () {
                // YAY! We made it!
              },
              function (err) {
                showError(err.message);
              });
          },
          function (err) {
            showError(err.message);
          });
      },
      function (err) {
        showError(err.message);
      });
  };
}());
</code></pre><p>What would this look like if we could use promises instead?</p><pre><code>// Converted to use promises
var loginViewModel = (function () {
  var login = function () {
    var username = $('#loginUsername').val();
    var password = $('#loginPassword').val();
    el.Users.login(username, password)
      .then(function () {
        return usersModel.load();
      })
      .then(function () {
        mobileApp.navigate('views/notesView.html');
      })
      .then(
        null, // YAY! We made it!
        function (err) {
          showError(err.message);
        }
    );
  };
  return {
    login: login
  };
}());
</code></pre><p>Arguments over 'readability' are often a time-sucking-black-hole-of-subjectivity, but this is an instance where I will definitely argue that promises made this code <em>much</em> more readable. The important thing to realize is that this isn't just syntactic/API sugar. Promises enable developers to think and express asynchronous code in a more synchronous way - giving you back return values (promises) and enabling error handling in a convenient way. Note that in our snippet above, the very last <code>then</code> call handles <em>any</em> error that could occur while logging in, loading the users model, or navigating to the notesView.html view.</p><h2 id="taking_it_further">Taking it Further</h2><p>While the basline of the spec defines a promise as an object that has a function value for the <code>then</code> property, popular promise libraries provide additional utilities that you will quickly become addicted to! For example, the <a href="https://github.com/kriskowal/q">Q</a> library provides a <code>spread</code> method that allows you to pass an array of promises, and the result of each promise will be passed, in order, as arguments to the fulfillment handler. Let's re-visit one of our callback examples and apply this:</p><pre><code>// In this refactor, our getCustomer, getContacts, getOrders &amp;
// getAccountsRecv methods now all return promises
$("#getCustomer").click(function(cust) {
    var id = $("#cust-id").val();
    Q.spread([
            getCustomer(id),
            getContacts(id),
            getOrders(id),
            getAccountsRecv(id)
        ],
        function(cust, contacts, orders, ar){
            cust.contacts = contacts;
            cust.orders = orders;
            cust.ar = ar; 
            // Now we can do something with
            // our fully-hydrated customer
        }
    );
});
</code></pre><p>If you've used promises before, it's quite likely that your library of choice provides shorthand methods for adding only a success, or error or "finally" callback. jQuery provides <code>done</code>, <code>fail</code> and <code>always</code>. Q provides <code>fail</code> (or <code>catch</code>) and <code>fin</code>. Due to the overwhelming populariy of jQuery, I've encountered many developers that think promises are defined by <code>done</code>, <code>fail</code> and <code>always</code> being present, rather than <code>then</code>. This leads me to a complaint…<em>*pulls pin, throws grenade*</em>…</p><h2 id="conversation_grenades">Conversation Grenades</h2><p>My first exposure to promise implementations in JavaScript was through jQuery. When I compared it to the Promises/A spec, I was very frustrated! jQuery didn't return a new promise from <code>then</code> (until version 1.8) - so developers depending on jQuery were not only <em>not</em> getting the full power of promises, but they were, IMO, cranking out a lot of code that didn't play well with other promise implementations that <em>did</em> follow the spec. Using a properly implemented promises library should mean that you "<a href="http://domenic.me/2012/10/14/youre-missing-the-point-of-promises/">can write very extensive libraries that are entirely agnostic to the implementation of the promises they accept</a>". I don't think anyone has explained this issue better than Domenic Denicola in his post "<a href="http://domenic.me/2012/10/14/youre-missing-the-point-of-promises/">You're Missing the Point of Promises</a>" – I highly recommend reading it. If all the major promise lib authors would follow his advice, my complaints about having a non-standard promise implementation forced on me when I use libs that take it as a dependency would disappear entirely.</p><h2 id="promises_conclusion">Promises Conclusion</h2><h3 id="pros">Pros</h3><ul>
<li><strong>Reduces Complexity of Nesting &amp; Flow</strong> - Flattening pyramids of doom is nearly always a win. Being able to express certain aspects of asynchronous code in a synchronous style (with return values, etc.) empowers developers at nearly any level to quickly understand what a section of code is doing.</li>
<li><strong>Results Can be "Cached"</strong> - If you need to keep a resolved promise around, any additional success handlers added to it are invoked (as soon as the runtime is free) and passed the resulting value. This can save you some boilerplate as well as prevent unnecessary operations (like a duplicate AJAX request, for example).</li>
</ul><h3 id="cons">Cons</h3><ul>
<li><strong>Results Can be "Cached"</strong> - Wait - wasn't this a PRO?! Yes - but it's a double-edged sword. If you're keeping promise instances around, avoid doing so for values that frequently change (and, for example, might require another HTTP request to fetch the latest).</li>
<li><strong>Opinionated on OSS APIs</strong> - If you're an open source author writing libraries for general consumption, please use a spec-compliant library! When you don't, you force a highly opinionated dependency on consuming developers.</li>
<li><strong>Many Non-Spec-Adhering Implementations Exist</strong> - Choosing one of these can get you past that:
</li>
</ul><h2 id="one_more_thought">One More Thought</h2><p>Promises are not the only alternative to plain callbacks. We've already discussed eventing and messaging, and we're about to discuss finite state machines (FSMs). In my experience I've found promises to be a powerful tool for concise units of behavior (handling a login, handling an HTTP request, etc.). However, I've seen promises used in longer-running workflows where an FSM is better suited to the task, and also in high level UI management between views where something more reactive (events, messaging) would have been a better choice.</p><p>Sometimes you need an abstraction that can react differently to the same input. No - I promise I didn't just lose my marbles. Consider a client-side router in a single page app: you may want any attempts to navigate while the user isn't authenticated, to do <em>nothing</em> other than direct them to the login screen. However, once they are authenticated, the same attempts to navigate should actually take them to the desired view(s), etc. A Finite State Machine (FSM) can manage this sort of behavior in a concise and extendable way.</p><p>In <a href="http://www.icenium.com/blog/icenium-team-blog/2013/05/09/is-this-thing-on-(part-2)">another post</a>, I described FSMs this way:</p><blockquote>
  <p>"A finite state machine is a "computational abstraction" – in other words, it's something we use in order to compute a yes or no answer to a question – that is capable of reacting differently to the same input, given a change in its internal state."</p>
</blockquote><p>You're already using state machines, and may not even realize it. The most basic of FSMs can be produced by a simple switch statement:</p><pre><code>var fsmLite = (function(){
    var _state = "notReady";
    var _result;
    // We're watching a subject somewhere to know
    // when we can move to ready state
    someSubject.once("ready", function() {
        _state = "ready";
    });
    return {
        doSomething: function(callback) {
            switch(_state) {
                // if someone wants us to "doSomething"
                // but we aren't ready, we invoke their
                // callback and pass an error message.
                // Other strategies are applicable here
                // as well - such as queueing up any
                // callbacks to be invoked once we reach
                // the "done" state, etc.
                case "notReady":
                    callback("Not ready yet!", null);
                break;
                // we actually do the work
                case "ready":
                    worker.doWork(function(result) {
                        // Do other work, etc. and then:
                        _result = result;
                        _state = "done";
                        callback(null, _result);
                    });     
                break;
                // The work has already been done, we just
                // invoke the callback and pass the result
                case "done":
                    callback(null, _result);
                break;
                default:
                    console.log("Invalid state for FSM!");
                break;
            }
        }
    };
}());
</code></pre><p>The above example responds differently to the same input (<code>doSomething</code>), depending on the <code>_state</code> value. It also demonstrates a few other FSM characteristics:</p><ul>
<li>It has a finite number of states in which it can exist</li>
<li>It can only exist in one state at a given time</li>
<li>It accepts input</li>
<li>It might produce output (in this case, the <code>_result</code> value passed to the <code>callback</code>)</li>
<li>It can transition from one state to another</li>
</ul><h2 id="promises_are_specialized_state_machines">Promises are Specialized State Machines</h2><p>You might have already put these together, but a promise is an FSM. It can be in one of three states: unfulfilled, fulfilled or failed. It accepts input (at least) from callers using the <code>then</code> method. It transitions from unfulfilled to fulfilled or failed, and won't transition again. Let's take a look at a directed graph representation of a promise-FSM (this is a common way to represent FSMs visually):</p><p><img src="http://tpstatic.com/img/usermedia/78OqSwBM20ScyMjHZVDGkQ/original.png" alt="Promise FSM Directed Graph" /></p><p>Each circle represents a state in which the promise can exist. The arrows represent the input each state handles (<code>then</code>, <code>fulfill</code> and <code>fail</code>). If the arrow points back to the state, this means the input does not cause a transition to a new state. If the input <em>does</em> cause a transition, the arrow points to the new state. Both the <code>Fulfilled</code> and <code>Failed</code> states have "entry actions" - behavior performed as soon as we enter the state (listed next to the "E:" on the state bubble).</p><h2 id="when_would_i_use_this">When Would I Use This?</h2><p>Once you grasp the nature of an FSM, it's hard to <em>not</em> see areas where it could serve well. A few of the areas I've encountered where FSMs have been a huge help are:</p><ul>
<li><strong>Online/Offline connectivity</strong>. (In fact I have a <a href="http://www.icenium.com/blog/icenium-team-blog/2013/04/23/is-this-thing-on-(part-1)">series on this topic already</a>.)</li>
<li><strong>Managing Views</strong>. For example, a Backbone view might be in an "accepting-input" or "not-accepting-input" state. The view still presents the same API to any calling code, but will respond differently based on the state. This is useful for submitting forms or any number of other scenarios.</li>
<li><strong>Initialization/Bootstrapping</strong>. Standing up a single page app, or a <a href="https://github.com/a2labs/amqp-bootstrapper">RabbitMQ client</a> in node.js (just to name two examples) can involve a number of asynchronous calls that need to be performed in a certain order, and may involve a need to replay part or all of that workflow. FSMs fit this like a glove.</li>
<li><strong>State-based Routing</strong>. I mentioned this in the leading example. You might want your client side router to behave differently based on some state in the app.</li>
<li><strong>Wizard/Step-Driven UI</strong>. You can use an FSM to control a wizard-style workflow - and even have sibling/reactive FSMs that drive menu-ing, etc. in tandem with the wziard FSM.</li>
</ul><h2 id="can_i_get_some_help_here">Can I Get Some Help Here?</h2><p>Rolling your own FSM is easy - but you might quickly outgrow the limited capabilities. I created <a href="https://github.com/ifandelse/machina.js">machina.js</a> because I wanted a low-level FSM utility library packed with some powerful features. Let's convert our switch-based FSM above to a machina FSM (be sure to read the comments!):</p><pre><code>var fsm = new machina.Fsm({

    // This will be the FSM's starting state
    initialState: "notReady",

    // initialize is invoked as soon as the
    // constructor has completed executing
    initialize: function() {
        var self = this;
        someSubject.on("ready", function() {
            self.handle("someSubject.ready");
        });
    },

    // The states object lets you organize your
    // states and input handlers. Each top level
    // member name is a state. The state object 
    // for each state contains function handlers
    // OR a string value, indicating the only
    // action is to transition to the state name
    // specified in the string value.
    states: {
        notReady: {
            "do.something" : function() {
                // deferUntilTransition is one of my
                // favorite machina features. It queues
                // the input up to be replayed in the
                // specified state name. The argument
                // is optional, and if not provided
                // machina will try to replay this
                // input again on the next transition
                this.deferUntilTransition("done");
            },
            // machina gives you a shortcut by allowing
            // the input handler value to be string state
            // name if the only reaction to an input is
            // to transition to a new state
            "someSubject.ready": "ready"        
        },
        ready: {
            "do.something" : function() {
                worker.doWork(function(result) {
                    // Do other work, etc. and then:
                    this.result = result;
                    // machina FSMs are event-emitters!
                    this.emit("result.ready", this.result);
                    this.transition("done");
                });     
            }
        },
        done: {
            "do.something" : function() {
                this.emit("result.ready", this.result); 
            }
        }
    },

    // this is a top level method that wraps the "handle"
    // call that machina provides.
    doSomething: function(callback) {
        // we could have easily required that callers
        // subscribe to events themselves, but we're
        // trying to be nice here
        this.once("result.ready", function(result){
            callback(result);
        });
        this.handle("do.something");
    }
});
</code></pre><p>So, machina provides features such as (but not limited to): </p><ul>
<li>providing custom post-construction initialization behavior</li>
<li>deferring input until a later time without requiring the caller to do anything</li>
<li>the ability to provide "catch-all" handlers to match unexpected input (this isn't shown above - check the <a href="https://github.com/ifandelse/machina.js/tree/master/example">examples in the repo</a> for more information)</li>
<li>FSMs are event emitters, so other components can observe them as subjects</li>
<li>_onEnter and _onExit handlers for any state (not shown above)</li>
</ul><h2 id="fsm_conclusion">FSM Conclusion</h2><h3 id="pros">Pros</h3><ul>
<li><strong>Extremely Versatile</strong> - FSMs can model so many real-world problems, it's hard to find a scenario that they don't work well for.</li>
<li><strong>Wokflow</strong> - FSMs handle long-running, asynchronous workflow well.</li>
</ul><h3 id="cons">Cons</h3><ul>
<li><strong>Lesser known Pattern</strong> - FSM awareness in the JavaScript developer community <em>appears</em> to be low. As a result, the pattern is often not known, feared or rejected as too complex.</li>
</ul><h2 id="complementary_patterns">Complementary Patterns</h2><p>You'll notice that our FSM above makes use of continuation-passing as well as events. In fact, our entire journey through these 5 patterns has progressively advanced to higher-level abstractions. Don't be surprised to see yourself mixing these patterns together to produce the abstraction you need. If anything, focusing on <em>just</em> the lower level pattern of passing callbacks and using promises to eliminate nesting has, in my opinion, done our community a disservice. In addition to grasping these patterns, we need to see the potential of higher-level abstractions which we can create from these patterns working <em>together</em>.</p><p>So - we survived our whirlwind tour together through these 5 patterns. It's worth emphasizing that these aren't the <em>only</em> five that can be useful in taming asynchronous code, but I do consider them "<em>must-know</em>". I'm interested in your feedback and war stories, as well. What have you found to be useful in this space?</p><h2 id="callbackscontinuation_passing_style">Callbacks/Continuation Passing Style</h2><h2 id="eventing__messaging">Eventing &amp; Messaging</h2><h3 id="libraries">Libraries</h3><h2 id="promises">Promises</h2><h3 id="libraries">Libraries</h3><h2 id="finite_state_machines">Finite State Machines</h2><h3 id="libraries">Libraries</h3><!-- /ko --></div></div>
</body>
</html>