
        <!doctype html>
        <html>
        <head>
            <meta charset="utf-8"/>
            <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
            <title>Currying in JavaScript</title>
            <link rel="stylesheet" href="../css/article.css" />;
        </head>
        <body>
            <div class="m-content">
            <h1>Currying in JavaScript</h1>
            <div class="section-inner layoutSingleColumn"><h3 name="3764" id="3764" class="graf--h3 graf--first">Currying in JavaScript</h3><p name="403b" id="403b" class="graf--p">I’ve been thinking a lot lately about functional programming, and I thought it might be kind of fun to walk through the process of writing a <strong class="markup--strong markup--p-strong">curry</strong> function.</p><p name="335b" id="335b" class="graf--p">For the uninitiated, currying refers to the process of taking a function with <strong class="markup--strong markup--p-strong">n</strong> arguments and transforming it into <strong class="markup--strong markup--p-strong">n</strong> functions that each take a single argument. It essentially creates a chain of partially applied functions that eventually resolves with a value.</p><p name="2812" id="2812" class="graf--p">Here’s a basic example of how you’d use it:</p><pre name="eb6e" id="eb6e" class="graf--pre">function volume( l, w, h ) {<br>return l * w * h;<br>}</pre><pre name="8eb7" id="8eb7" class="graf--pre">var curried = curry( volume );</pre><pre name="9d67" id="9d67" class="graf--pre">curried( 1 )( 2 )( 3 ); // 6</pre><h3 name="f385" id="f385" class="graf--h3">Disclaimer</h3><p name="2c73" id="2c73" class="graf--p">This post assumes basic familiarity with closures and higher-order functions, as well as stuff like <strong class="markup--strong markup--p-strong">Function#apply()</strong>. If you’re not comfortable with those concepts, you might want to brush up before reading further.</p><h3 name="ce69" id="ce69" class="graf--h3">Writing our curry function</h3><p name="7358" id="7358" class="graf--p">The first thing you’ll notice is that <strong class="markup--strong markup--p-strong">curry</strong> expects a function as its argument, so we’ll start there.</p><pre name="d899" id="d899" class="graf--pre">function curry( fn ) {</pre><pre name="077a" id="077a" class="graf--pre">}</pre><p name="8795" id="8795" class="graf--p">Next, we need to know how many arguments our function expects (called its “arity”). Otherwise, we won’t know when to stop returning new functions and give back a value instead.</p><p name="0214" id="0214" class="graf--p">We can tell how many arguments a function expects by accessing its <strong class="markup--strong markup--p-strong">length</strong> property.</p><pre name="81e5" id="81e5" class="graf--pre">function curry( fn ) {<br>var arity = fn.length;<br>}</pre><p name="6ef8" id="6ef8" class="graf--p">From there, things get a little bit trickier.</p><p name="a24c" id="a24c" class="graf--p">Essentially, every time a curried function is called, we add any new arguments to an array that’s saved in a closure. If the number of arguments in that array is equal to the number of arguments that our original function expects, then we call it. Otherwise, we return a new function.</p><p name="a32f" id="a32f" class="graf--p">To do that, we need (1) a closure that can retain that list of arguments and (2) a function that can check the total number of arguments and either return another partially applied function <em class="markup--em markup--p-em">or</em> the return value of the original function with all of the arguments applied.</p><p name="24d9" id="24d9" class="graf--p">I usually do this with an immediately invoked function called `resolver`.</p><pre name="11b5" id="11b5" class="graf--pre">function curry( fn ) {<br>var arity = fn.length;</pre><pre name="23ea" id="23ea" class="graf--pre">  return (function resolver() {<br>}());<br>}</pre><p name="28fd" id="28fd" class="graf--p">Now, the first thing we need to do in <strong class="markup--strong markup--p-strong">resolver</strong> is make a copy of any arguments it received. We’ll do that by creating a variable called <strong class="markup--strong markup--p-strong">memory</strong> that uses <strong class="markup--strong markup--p-strong">Array#slice</strong> to make a copy of the <strong class="markup--strong markup--p-strong">arguments</strong> object.</p><pre name="d496" id="d496" class="graf--pre">function curry( fn ) {<br>var arity = fn.length;</pre><pre name="ae28" id="ae28" class="graf--pre">  return (function resolver() {<br>var memory = Array.prototype.slice.call( arguments );<br>}());<br>}</pre><p name="ffac" id="ffac" class="graf--p">Next, <strong class="markup--strong markup--p-strong">resolver</strong> needs to return a function. This is what the outside world sees when it calls a curried function.</p><pre name="13d2" id="13d2" class="graf--pre">function curry( fn ) {<br>var arity = fn.length;</pre><pre name="f024" id="f024" class="graf--pre">  return (function resolver() {<br>var memory = Array.prototype.slice.call( arguments );<br>return function() {</pre><pre name="5359" id="5359" class="graf--pre">    };<br>}());<br>}</pre><p name="684f" id="684f" class="graf--p">Since this internal function is the one that ends up actually being called, it needs to accept arguments. But it also needs to <em class="markup--em markup--p-em">add</em> those to any arguments that might be stored in <strong class="markup--strong markup--p-strong">memory</strong>. So first, we’ll make a copy of <strong class="markup--strong markup--p-strong">memory</strong> by calling <strong class="markup--strong markup--p-strong">slice()</strong> on it.</p><pre name="82e0" id="82e0" class="graf--pre">function curry( fn ) {<br>var arity = fn.length;</pre><pre name="98f2" id="98f2" class="graf--pre">  return (function resolver() {<br>var memory = Array.prototype.slice.call( arguments );<br>return function() {<br>var local = memory.slice();<br>};<br>}());<br>}</pre><p name="07fe" id="07fe" class="graf--p">Now, lets add our new arguments by using <strong class="markup--strong markup--p-strong">Array#push</strong>.</p><pre name="c6c9" id="c6c9" class="graf--pre">function curry( fn ) {<br>var arity = fn.length;</pre><pre name="a8fe" id="a8fe" class="graf--pre">  return (function resolver() {<br>var memory = Array.prototype.slice.call( arguments );<br>return function() {<br>var local = memory.slice();<br>Array.prototype.push.apply( local, arguments );<br>};<br>}());<br>}</pre><p name="47d5" id="47d5" class="graf--p">Good. Now we have a new array containing all the arguments we’ve received so far in this chain of partially applied functions.</p><p name="0396" id="0396" class="graf--p">The last thing to do is to compare the length of arguments we’ve received with the arity of our curried function. If the lengths match, we’ll call the original function. If not, we’ll use <strong class="markup--strong markup--p-strong">resolver</strong> to return yet another function that has all of our current arguments stored in memory.</p><pre name="a237" id="a237" class="graf--pre">function curry( fn ) {<br>var arity = fn.length;</pre><pre name="be9d" id="be9d" class="graf--pre">  return (function resolver() {<br>var memory = Array.prototype.slice.call( arguments );<br>return function() {<br>var local = memory.slice(), next;<br>Array.prototype.push.apply( local, arguments );<br>next = local.length &gt;= arity ? fn : resolver;<br>return next.apply( null, local );<br>};<br>}());<br>}</pre><p name="4884" id="4884" class="graf--p">This can be a little bit difficult to wrap your head around, so let’s take it step by step in an example.</p><pre name="7529" id="7529" class="graf--pre">function volume( l, w, h ) {<br>return l * w * h;<br>}</pre><pre name="a191" id="a191" class="graf--pre">var curried = curry( volume );</pre><p name="3289" id="3289" class="graf--p">Okay, so <strong class="markup--strong markup--p-strong">curried</strong> is the result of passing <strong class="markup--strong markup--p-strong">volume</strong> into our <strong class="markup--strong markup--p-strong">curry</strong> function.</p><p name="5951" id="5951" class="graf--p">If you look back, what’s happening here is:</p><p name="94b5" id="94b5" class="graf--p">1. We store the arity of <strong class="markup--strong markup--p-strong">volume</strong>, which is <strong class="markup--strong markup--p-strong">3</strong>.<br>2. We immediately invoke <strong class="markup--strong markup--p-strong">resolver</strong> with no arguments, which means that its <strong class="markup--strong markup--p-strong">memory</strong> array is empty.<br>3. <strong class="markup--strong markup--p-strong">resolver</strong> returns an anonymous function.</p><p name="7c58" id="7c58" class="graf--p">Still with me? Now let’s call our <strong class="markup--strong markup--p-strong">curried</strong> function and pass in a length.</p><pre name="a6b9" id="a6b9" class="graf--pre">function volume( l, w, h ) {<br>return l * w * h;<br>}</pre><pre name="5bb4" id="5bb4" class="graf--pre">var curried = curry( volume );<br>var length = curried( 2 );</pre><p name="86c8" id="86c8" class="graf--p">Again, here are the steps:</p><p name="b32a" id="b32a" class="graf--p">1. What we actually called here was the anonymous function being returned by <strong class="markup--strong markup--p-strong">resolver</strong>.<br>2. We made a copy of <strong class="markup--strong markup--p-strong">memory</strong> (which was empty) and called it <strong class="markup--strong markup--p-strong">local</strong>.<br>3. We added our argument (<strong class="markup--strong markup--p-strong">2</strong>) to the <strong class="markup--strong markup--p-strong">local</strong> array.<br>4. Since the length of <strong class="markup--strong markup--p-strong">local</strong> is less than the arity of <strong class="markup--strong markup--p-strong">volume</strong>, we call <strong class="markup--strong markup--p-strong">resolver</strong> again with the list of arguments we have so far. That creates a new closure with a new <strong class="markup--strong markup--p-strong">memory</strong> array, which contains our first argument of <strong class="markup--strong markup--p-strong">2</strong>.<br>5. Finally, <strong class="markup--strong markup--p-strong">resolver</strong> returns a new function that has access to an outer closure with our new <strong class="markup--strong markup--p-strong">memory</strong> array.</p><p name="9d20" id="9d20" class="graf--p">So what we get back is that inner anonymous function again. But this time, it has access to a <strong class="markup--strong markup--p-strong">memory</strong> array that isn’t empty. It has our first argument (a <strong class="markup--strong markup--p-strong">2</strong>) inside of it.</p><p name="750a" id="750a" class="graf--p">If we call our <strong class="markup--strong markup--p-strong">length</strong> function, the process repeats.</p><pre name="3187" id="3187" class="graf--pre">function volume( l, w, h ) {<br>return l * w * h;<br>}</pre><pre name="0bc7" id="0bc7" class="graf--pre">var curried = curry( volume );<br>var length = curried( 2 );<br>var lengthAndWidth = length( 3 );</pre><p name="8722" id="8722" class="graf--p">1. Again, what we actually called was the anonymous function being returned by <strong class="markup--strong markup--p-strong">resolver</strong>.<br>2. This time, <strong class="markup--strong markup--p-strong">resolver</strong> had been primed with some previous arguments. So we make a copy of that array <strong class="markup--strong markup--p-strong">[ 2 ]</strong>.<br>3. We add our new argument, <strong class="markup--strong markup--p-strong">3</strong>, to the <strong class="markup--strong markup--p-strong">local</strong> array.<br>4. Since the length of <strong class="markup--strong markup--p-strong">local</strong> is still less than the arity of <strong class="markup--strong markup--p-strong">volume</strong>, we call <strong class="markup--strong markup--p-strong">resolver</strong> again with the list of arguments we have so far — and that returns a new function.</p><p name="5fd9" id="5fd9" class="graf--p">Now it’s time to call our <strong class="markup--strong markup--p-strong">lengthAndWidth</strong> function and get back a value.</p><pre name="aa6b" id="aa6b" class="graf--pre">function volume( l, w, h ) {<br>return l * w * h;<br>}</pre><pre name="9658" id="9658" class="graf--pre">var curried = curry( volume );<br>var length = curried( 2 );<br>var lengthAndWidth = length( 3 );</pre><pre name="d8b2" id="d8b2" class="graf--pre">console.log( lengthAndWidth( 4 ) ); // 24</pre><p name="f1d8" id="f1d8" class="graf--p">This time, the steps are a little bit different at the end:</p><p name="366d" id="366d" class="graf--p">1. Once again, what we actually called was the anonymous function being returned by <strong class="markup--strong markup--p-strong">resolver</strong>.<br>2. This time, <strong class="markup--strong markup--p-strong">resolver</strong> had been primed with two previous arguments. So we make a copy of that array <strong class="markup--strong markup--p-strong">[ 2, 3 ] </strong>and assigned it to <strong class="markup--strong markup--p-strong">local</strong>.<br>3. We add our new argument, <strong class="markup--strong markup--p-strong">4</strong>, to the <strong class="markup--strong markup--p-strong">local</strong> array.<br>4. Now the length of <strong class="markup--strong markup--p-strong">local</strong> is <strong class="markup--strong markup--p-strong">3</strong>, which is the arity of <strong class="markup--strong markup--p-strong">volume</strong>. So instead of returning a new function, we return the result of calling <strong class="markup--strong markup--p-strong">volume</strong> with all of the arguments we’ve been saving up, and that gives us a value of <strong class="markup--strong markup--p-strong">24</strong>.</p><h3 name="735f" id="735f" class="graf--h3">Wrapping up</h3><p name="9bcb" id="9bcb" class="graf--p">Admittedly, I have yet to find a super compelling use-case for currying in my day-to-day work. But I still think that going through the process of writing functions like this is a great way to improve your understanding of functional programming, and it helps reinforce concepts like closures and first-class functions.</p><p name="92f7" id="92f7" class="graf--p">By the way, if you like nerdy JavaScript things and live in the Boston area, I’m hiring at <a href="http://projectdecibel.com/" data-href="http://projectdecibel.com" class="markup--anchor markup--p-anchor" rel="nofollow">Project Decibel</a>. Shoot me an <a href="mailto:kennis84@gmail.com" data-href="mailto:kennis84@gmail.com" class="markup--anchor markup--p-anchor">email</a>.</p><p name="713b" id="713b" class="graf--p graf--last">And if you liked this post, follow me here or on <a href="http://twitter.com/kevincennis" data-href="http://twitter.com/kevincennis" class="markup--anchor markup--p-anchor" rel="nofollow">Twitter</a>. I’m gonna try to write once a day for the next 30 days.</p></div>
            </div>
            <script>var _gaq = _gaq || []; _gaq.push(['_setAccount', 'UA-34802167-1']); _gaq.push(['_setDomainName', 'liuzhe.co']); _gaq.push(['_trackPageview']); (function() { var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true; ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'; var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s); })();</script>
        </body>
        </html>